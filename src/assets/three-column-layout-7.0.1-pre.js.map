{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@dojo/framework/shim/global.mjs","webpack:///./node_modules/@dojo/framework/core/vdom.mjs","webpack:///./node_modules/@dojo/framework/shim/Set.mjs","webpack:///./node_modules/@dojo/framework/core/middleware/icache.mjs","webpack:///./node_modules/@dojo/framework/core/diff.mjs","webpack:///./src/three-column-layout/styles/three-column-layout.m.css","webpack:///./node_modules/@dojo/framework/shim/array.mjs","webpack:///./src/theme/default/three-column-layout.m.css","webpack:///./node_modules/@dojo/framework/core/RegistryHandler.mjs","webpack:///./src/middleware/theme.tsx","webpack:///./node_modules/@dojo/framework/core/middleware/theme.mjs","webpack:///./node_modules/@dojo/framework/core/Injector.mjs","webpack:///./node_modules/@dojo/framework/core/middleware/injector.mjs","webpack:///./node_modules/@dojo/framework/shim/Map.mjs","webpack:///./node_modules/@dojo/framework/core/Destroyable.mjs","webpack:///./src/common/styles/base.m.css","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/@dojo/framework/shim/object.mjs","webpack:///./node_modules/@dojo/cli-build-widget/template/custom-element.js?9c44","webpack:///./src/three-column-layout/index.tsx","webpack:///./node_modules/@dojo/framework/core/registerCustomElement.mjs","webpack:///./node_modules/@dojo/framework/core/has.mjs","webpack:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.js","webpack:///./node_modules/@dojo/framework/core/Registry.mjs","webpack:///./node_modules/@dojo/framework/shim/ResizeObserver.mjs","webpack:///./node_modules/@dojo/framework/shim/util/wrapper.mjs","webpack:///./node_modules/@dojo/framework/core/middleware/resize.mjs","webpack:///./node_modules/@dojo/framework/shim/WeakMap.mjs","webpack:///./node_modules/@dojo/framework/core/ThemeInjector.mjs","webpack:///./node_modules/@dojo/framework/shim/support/util.mjs","webpack:///./node_modules/@dojo/framework/shim/Promise.mjs","webpack:///./node_modules/@dojo/framework/core/middleware/breakpoint.mjs","webpack:///./node_modules/@dojo/framework/core/Evented.mjs"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","globalObject","window","navigator","userAgent","indexOf","globalThis","self","__webpack_exports__","isTextNode","isWNode","isVNode","w","v","dom","tsx","widgetInstanceMap","invalidator","node","diffProperty","destroy","getRegistry","renderer","_shim_global__WEBPACK_IMPORTED_MODULE_0__","_core_has__WEBPACK_IMPORTED_MODULE_1__","_shim_WeakMap__WEBPACK_IMPORTED_MODULE_2__","_shim_Set__WEBPACK_IMPORTED_MODULE_3__","_shim_Map__WEBPACK_IMPORTED_MODULE_4__","_shim_array__WEBPACK_IMPORTED_MODULE_5__","_Registry__WEBPACK_IMPORTED_MODULE_6__","_diff__WEBPACK_IMPORTED_MODULE_7__","_RegistryHandler__WEBPACK_IMPORTED_MODULE_8__","__rest","e","getOwnPropertySymbols","length","EMPTY_ARRAY","nodeOperations","NAMESPACE_SVG","NAMESPACE_W3","NAMESPACE_XLINK","WNODE","VNODE","DOMVNODE","scope","__DOJO_SCOPE","setRendering","rendering","item","nodeType","isWNodeWrapper","child","isVNodeWrapper","isVirtualWrapper","tag","isBodyWrapper","wrapper","Boolean","type","isDomVNode","isElementNode","tagName","widgetConstructorOrNode","properties","children","__children__","assign","widgetConstructor","propertiesOrChildren","deferredPropertiesCallback","Array","isArray","classes","styles","newProperties","_a","nodeClasses","nodeStyles","nodeProperties","attrs","props","on","diffType","onAttach","toLowerCase","attributes","events","domNode","text","undefined","data","REGISTRY_ITEM","FromRegistry","[object Object]","this","__properties__","Infinity","__autoRegistryItem","buildPreviousProperties","current","deferredProperties","keys","forEach","propName","attrName","getAttribute","reduce","same","dnode1","dnode2","widgetConstructor1","registryItem","widgetConstructor2","props1","props2","instance","every","findIndexOfChild","sameAs","start","createClassPropValue","classNames","className","updateAttribute","attrValue","namespace","setAttributeNS","removeAttribute","setAttribute","arrayFrom","arr","slice","createFactory","callback","middlewares","factory","result","isWidget","middlewareName","middleware","isFactory","returns","widgetMetaMap","requestedDomNodes","wrapperId","metaId","addNodeToMap","id","widgetMeta","nodeMap","set","has","delete","destroyHandles","meta","destroyMap","middlewareIds","size","clear","widgetId","split","mountNode","contains","document","body","add","propertyName","propertiesOrDiff","diff","customDiffMap","customDiffProperties","propertyDiffMap","originalProperties","propertiesCalled","console","warn","widgetName","destroyFunction","registryHandler","base","registry","isDeferred","deferRefs","wrapFunctionProperties","propertyNames","args","unwrap","_renderScheduled","parentInvalidate","_appWrapperId","_mountOptions","sync","merge","transition","_invalidationQueue","_processQueue","_deferredProcessQueue","_applicationQueue","_eventMap","_idToWrapperMap","_wrapperSiblingMap","_idToChildrenWrappers","_insertBeforeMap","_nodeToWrapperMap","_deferredRenderCallbacks","_allMergedNodes","_deferredProcessIds","nodeOperation","propValue","previousValue","push","updateEvent","eventName","currentValue","previousEvent","removeEventListener","evt","target","addEventListener","removeOrphanedEvents","previousProperties","onlyEvents","isEvent","substr","eventCallback","resolveRegistryItem","owningNode","instanceData","registryLabel","label","isLazyDefine","define","renderedToWrapper","rendered","parent","currentParent","requiresInsertBefore","hasPreviousSiblings","depth","wrappedRendered","hasParentWNode","hasVirtualParentNode","hasCurrentParentChildren","insertBefore","previousItem","nodes","pop","mapNodeToInstance","renderedItem","order","parentId","exitAnimation","hasAnimations","nextParent","owningId","runDeferredProperties","next","processProperties","findInsertBefore","searchNode","nextSibling","childDomWrapperId","findDomNodeOnParentWrapper","childWrapper","parentNode","setValue","domValue","onInputValue","onSelectValue","setProperties","currentProperties","nextWrapper","includesEventsAndAttributes","propNames","propCount","previousClassString","currentClassString","merged","domClasses","styleNames","styleCount","j","styleName","newStyleValue","style","lastIndexOf","_createDeferredRenderCallback","callbacks","shift","_scheduleDeferredRenderCallbacks","run","requestAnimationFrame","previousAttributes","attrNames","attrCount","updateAttributes","event","_schedule","_runInvalidationQueue","getWNodeWrapper","invalidationQueue","previouslyRendered","sort","a","b","_runProcessQueue","sibling","_updateWidget","_runDomInstructionQueue","_cleanUpMergedNodes","mergedNode","removeChild","_process","reverse","parentDomNode","parentElement","enterAnimation","enterAnimationActive","enter","owningWrapper","nodeHandler","inserted","currentDomNode","replaceChild","exitAnimationActive","exit","attached","addRoot","onDetach","distinguishableCheck","childNodes","index","wrappers","parentWNodeWrapper","wrapperToCheck","parentName","nodeIdentifier","checkDistinguishable","createKeyMap","mergeNodes","oldIndex","newIndex","currentLength","nextLength","instructions","replace","currentKeys","nextKeys","currentWrapper","domElement","toUpperCase","mergeNodeIndex","splice","_processMergeNodes","_processOne","widget","currentNode","parentWrapper","findParentDomNode","isVirtual","isBody","createTextNode","createElementNS","createElement","_createDom","invalidate","Constructor","dirty","__setProperties__","__setChildren__","__render__","ids","resolveMiddleware","results","uniqueId","payload","createWidgetOptions","resolvedMiddleware","_createWidget","currentChildren","_updateDom","remove","bodyIds","wrapperChildren","_removeDom","processResult","_removeWidget","didRender","customProperties","diffMap","runDiffs","ignoreProperties","changed","propertiesDiff","values","childId","mount","mountOptions","renderResult","wrapNodes","siblingId","unmount","cancelAnimationFrame","_global__WEBPACK_IMPORTED_MODULE_0__","Set","createICacheMiddleware","icache","_shim_Map__WEBPACK_IMPORTED_MODULE_0__","_vdom__WEBPACK_IMPORTED_MODULE_1__","cacheMap","api","cachedValue","status","then","getOrSet","reference","shallow","auto","_Registry__WEBPACK_IMPORTED_MODULE_0__","isObjectOrArray","toString","previousProperty","newProperty","validOldProperty","validNewProperty","previousKeys","newKeys","some","_type","ignore"," _key","root","center","from","findIndex","flat","_support_util__WEBPACK_IMPORTED_MODULE_1__","of","copyWithin","fill","find","includes","flatMap","leading","trailing","_core_Evented__WEBPACK_IMPORTED_MODULE_1__","_Registry__WEBPACK_IMPORTED_MODULE_2__","super","_registry","_registryWidgetLabelMap","_registryInjectorLabelMap","own","baseRegistry","injector","defineInjector","hasInjector","globalPrecedence","_get","getFunctionName","labelMap","registries","registeredLabels","handle","action","emit","theme","_dojo_framework_core_vdom__WEBPACK_IMPORTED_MODULE_0__","_dojo_framework_core_middleware_theme__WEBPACK_IMPORTED_MODULE_1__","_dojo_framework_core_ThemeInjector__WEBPACK_IMPORTED_MODULE_2__","coreTheme","uppercaseFirstChar","charAt","isThemeWithVariant","compose","baseCss","css","prefix","themePayload","variant","getTheme","baseKey","variantKey","virtualCss","virtualTheme","variantTheme","baseTheme","prefixedCss","prefixCss","classKey","lowercaseFirstChar","trim","variants","constructedTheme","variantComposesClass","_vdom__WEBPACK_IMPORTED_MODULE_0__","_icache__WEBPACK_IMPORTED_MODULE_1__","_injector__WEBPACK_IMPORTED_MODULE_2__","_diff__WEBPACK_IMPORTED_MODULE_4__","_ThemeInjector__WEBPACK_IMPORTED_MODULE_5__","INJECTED_THEME_KEY","themeKeys","themeInjector","themeRegistry","setInvalidator","registerThemeInjector","subscribe","cachedTheme","currentClasses","currentTheme","classKeys","join","Injector","_core_Evented__WEBPACK_IMPORTED_MODULE_0__","_payload","_invalidator","injectorFactory","handles","getInjector","Map","Destroyable","_shim_Promise__WEBPACK_IMPORTED_MODULE_0__","noop","resolve","destroyed","Error","_handles","visuallyHidden","focusable","hidden","g","Function","eval","getOwnPropertyDescriptor","getOwnPropertyNames","is","getOwnPropertyDescriptors","entries","widgetFactory","registerCustomElement","default","defaultExport","ThreeColumnLayout","_dojo_framework_core_middleware_breakpoint__WEBPACK_IMPORTED_MODULE_1__","_middleware_theme__WEBPACK_IMPORTED_MODULE_2__","_styles_three_column_layout_m_css__WEBPACK_IMPORTED_MODULE_3__","_common_styles_base_m_css__WEBPACK_IMPORTED_MODULE_4__","_theme_default_three_column_layout_m_css__WEBPACK_IMPORTED_MODULE_5__","breakpoint","twoColumnBreakpoint","oneColumnBreakpoint","bias","currentBreakpoint","LARGE","MEDIUM","SMALL","shouldCollapseLeading","shouldCollapseTrailing","CustomElementChildType","DomToWidgetWrapper","register","_shim_array__WEBPACK_IMPORTED_MODULE_2__","_shim_global__WEBPACK_IMPORTED_MODULE_3__","_ThemeInjector__WEBPACK_IMPORTED_MODULE_4__","RESERVED_PROPS","wrappedWNode","setTimeout","dispatchEvent","CustomEvent","bubbles","detail","options","wrappedDomNode","descriptor","WidgetConstructor","registryFactory","attributeMap","attributeName","HTMLElement","arguments","_properties","_children","_eventProperties","_propertiesMap","_initialised","_childType","childType","_waitTillReady","readyState","element","_hasBeenParsed","_readyCallback","domProperties","_propertiesWithAttributes","_attributesToProperties","isReservedProp","filteredPropertyName","_getProperty","_setProperty","_getEventProperty","_setEventProperty","defineProperties","filter","childNode","isElement","isDojoChild","DOJO","NODE","_render","_childConnected","widgetProperties","renderChildren","Wrapper","themeContext","_getVariant","_getTheme","_renderer","display","getComputedStyle","dojoce","themes","slots","slotName","slotResult","existingSlotValue","Child","map","oldValue","parsedValue","JSON","parse","observedAttributes","__customElementDescriptor","customElements","testCache","testFunctions","staticFeatures","DojoHasEnvironment","staticCache","apply","feature","overwrite","normalizedFeature","exists","TypeError","strict","Promise","finally","Animation","KeyframeEffect","AbortController","AbortSignal","IntersectionObserver","ResizeObserver","onpointerdown","Element","MapShim","getIndex","entry","anonymous","__entries__","prototypeAccessors","configurable","ctx","list","isBrowser","global$1","Math","requestAnimationFrame$1","Date","now","trailingTimeout","transitionKeys","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","refresh","delay","leadingCall","trailingCall","lastCallTime","resolvePending","proxy","timeoutCallback","timeStamp","throttle","addObserver","observer","connect_","removeObserver","observers","disconnect_","updateObservers_","activeObservers","gatherActive","hasActive","broadcastActive","observe","childList","characterData","subtree","disconnect","ref","getInstance","instance_","defineConfigurable","writable","getWindowOf","ownerDocument","defaultView","emptyRect","createRectInit","toFloat","parseFloat","getBordersSize","positions","len","position","getHTMLElementContentRect","clientWidth","clientHeight","paddings","getPaddings","horizPad","left","right","vertPad","top","bottom","width","height","boxSizing","round","documentElement","isDocumentElement","vertScrollbar","horizScrollbar","abs","isSVGGraphicsElement","SVGGraphicsElement","SVGElement","getBBox","getContentRect","bbox","getSVGContentRect","x","y","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","isActive","rect","broadcastRect","ResizeObserverEntry","rectInit","Constr","contentRect","DOMRectReadOnly","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","callback_","controller_","callbackCtx_","observations","unobserve","clearActive","this$1","observation","WeakMap","method","WIDGET_BASE_TYPE","isWidgetBaseConstructor","isWidgetFunction","isWNodeFactory","Registry","_shim_Map__WEBPACK_IMPORTED_MODULE_1__","_core_Evented__WEBPACK_IMPORTED_MODULE_2__","widgetLabel","_widgetRegistry","widgetCtor","emitLoadedEvent","error","_injectorRegistry","injectorItem","promise","isWidgetConstructorDefaultExport","ResizeObserver_default","nameOnGlobal","constructor","resize","_shim_ResizeObserver__WEBPACK_IMPORTED_MODULE_0__","_icache__WEBPACK_IMPORTED_MODULE_2__","resizeObserver","isThemeWithVariants","isThemeInjectorPayloadWithVariant","ThemeInjector_ThemeInjector","createThemeInjectorPayload","isVariantModule","wrapNative","nativeFunction","isThenable","ShimPromise","onFinally","reason","_resize__WEBPACK_IMPORTED_MODULE_1__","breakpoints","SM","MD","LG","XL","defaultBreakpoints","createBreakpointMiddleware","Evented","_Destroyable__WEBPACK_IMPORTED_MODULE_1__","regexMap","listenersMap","methods","globString","targetString","regex","RegExp","test","isGlobMatch","listener","_addListener","listeners"],"mappings":";;;;;;;;aACA,IAAAA,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,GAAA,CACAG,EAAAH,EACAI,GAAA,EACAH,QAAA,IAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,IAAAmC,EAAA,uCClFA,SAAAC,GAAA,MAAAC,EAIA,oBAAAC,eAAAC,UAAAC,UAAAC,QAAA,YACAH,OAEA,oBAAAI,WACAA,WAEA,oBAAAC,KACAA,KAEA,oBAAAL,OACAA,YAEA,IAAAF,EACAA,OADA,EAIeQ,EAAA,uDCpBf5C,EAAAU,EAAAkC,EAAA,sBAAAC,IAAA7C,EAAAU,EAAAkC,EAAA,sBAAAE,IAAA9C,EAAAU,EAAAkC,EAAA,sBAAAG,IAAA/C,EAAAU,EAAAkC,EAAA,sBAAAI,IAAAhD,EAAAU,EAAAkC,EAAA,sBAAAK,IAAAjD,EAAAU,EAAAkC,EAAA,sBAAAM,IAAAlD,EAAAU,EAAAkC,EAAA,sBAAAO,IAAAnD,EAAAU,EAAAkC,EAAA,sBAAAlB,IAAA1B,EAAAU,EAAAkC,EAAA,sBAAAQ,IAAApD,EAAAU,EAAAkC,EAAA,sBAAAS,IAAArD,EAAAU,EAAAkC,EAAA,sBAAAU,KAAAtD,EAAAU,EAAAkC,EAAA,sBAAAW,KAAAvD,EAAAU,EAAAkC,EAAA,sBAAAY,KAAAxD,EAAAU,EAAAkC,EAAA,sBAAAa,KAAAzD,EAAAU,EAAAkC,EAAA,sBAAAc,KAAA,IAAAC,EAAA3D,EAAA,GAAA4D,EAAA5D,EAAA,GAAA6D,EAAA7D,EAAA,GAAA8D,EAAA9D,EAAA,IAAA+D,EAAA/D,EAAA,GAAAgE,EAAAhE,EAAA,IAAAiE,EAAAjE,EAAA,GAAAkE,EAAAlE,EAAA,IAAAmE,EAAAnE,EAAA,IAAAoE,EAA0B,SAAAjC,EAAAkC,GAC1B,IAAA/C,EAAA,GACA,QAAAY,KAAAC,EAAArB,OAAAkB,UAAAC,eAAA1B,KAAA4B,EAAAD,IAAAmC,EAAA5B,QAAAP,GAAA,IACAZ,EAAAY,GAAAC,EAAAD,IACA,SAAAC,GAAA,mBAAArB,OAAAwD,sBACA,KAAAlE,EAAA,MAAA8B,EAAApB,OAAAwD,sBAAAnC,GAA4D/B,EAAA8B,EAAAqC,OAAcnE,IAAAiE,EAAA5B,QAAAP,EAAA9B,IAAA,IAC1EkB,EAAAY,EAAA9B,IAAA+B,EAAAD,EAAA9B,KACA,OAAAkB,GAWA,MAAAkD,EAAA,GACAC,EAAA,0CAEAC,EAAAC,6BACAC,EAAAD,+BACAE,EAAA,eACAC,EAAA,eACAC,EAAA,kBAEAC,EAAA,iBAAAC,0BAAA,aAIO,SAAAC,EAAA7D,GACHsC,EAAA,EAAMqB,GAAAG,UAAA9D,EAUH,SAAAwB,EAAAuC,GACP,OAAAA,GAAA,IAAAA,EAAAC,SAKA,SAAAC,EAAAC,GACA,OAAAA,GAAAzC,EAAAyC,EAAAjC,MAEA,SAAAkC,EAAAD,GACA,QAAAA,GAAAxC,EAAAwC,EAAAjC,MAEA,SAAAmC,EAAAF,GACA,OAAAC,EAAAD,IAAA,YAAAA,EAAAjC,KAAAoC,IAEA,SAAAC,EAAAC,GACA,OAAAJ,EAAAI,IAAA,SAAAA,EAAAtC,KAAAoC,IAKO,SAAA5C,EAAAyC,GACP,OAAAM,QAAAN,IAAA,IAAAA,GAAA,iBAAAA,KAAAO,OAAAjB,GAEO,SAAA9B,EAAAwC,GACP,OAAAM,QAAAN,IAAA,IAAAA,GAAA,iBAAAA,MAAAO,OAAAhB,GAAAS,EAAAO,OAAAf,IAEO,SAAAgB,EAAAR,GACP,OAAAM,QAAAN,IAAA,IAAAA,GAAA,iBAAAA,KAAAO,OAAAf,GAEO,SAAAiB,EAAA3E,GACP,QAAAA,EAAA4E,QAuBO,SAAAjD,EAAAkD,EAAAC,EAAAC,GAIP,OAHAD,EAAAE,qBACAF,EAAAE,aAEQvF,OAAAmD,EAAA,EAAAnD,CAAcoF,GACtBA,EAAAC,EAAAC,IAEAtD,EAAAoD,KACAC,EAAArF,OAAAwF,OAAA,GAAqCJ,EAAAC,cACrCC,KAAAF,EAAAE,SACAF,IAAAK,mBAEA,CACAH,YAAA,GACAG,kBAAAL,EACAC,aACAL,KAAAjB,IAGO,SAAA5B,EAAAyC,EAAAc,EAAA,GAAyCJ,GAChD,IACAK,EADAN,EAAAK,EAEA,sBAAAd,MACA,OAAAA,MAAAS,EAAAC,GAUA,GARAM,MAAAC,QAAAH,KACAJ,EAAAI,EACAL,EAAA,IAEA,mBAAAA,IACAM,EAAAN,EACAA,EAAA,IAEApD,EAAA2C,GAAA,CACA,IAAAkB,QAAaA,EAAA,GAAAC,SAAA,IAA4BV,EAAAW,EAAA1C,EAAA+B,EAAA,sBACzCY,EAAArB,EAAAS,YAAkCS,QAAAI,EAAA,GAAAH,OAAAI,EAAA,IAAqDF,EAAAG,EAAA9C,EAAA2C,EAAA,sBACvFC,EAAAN,MAAAC,QAAAK,KAAA,CAAAA,GACAJ,EAAAF,MAAAC,QAAAC,KAAA,CAAAA,GACAC,EAAA/F,OAAAwF,OAAA,GAAiCW,EAAAJ,GACjCV,EAAArF,OAAAwF,OAAA,GAAqCY,EAAAJ,EAAA,CAAkCF,QAAA,IAAAI,KAAAJ,GAAAC,WACvET,KAAAV,EAAAU,SACAV,QAEA,OACAA,MACAe,6BACAL,WACAD,aACAL,KAAAhB,GAMO,SAAA5B,GAAAI,KAAcA,EAAA6D,QAAA,GAAiBC,QAAA,GAAYC,KAAA,GAASC,WAAA,OAAAC,YAA+BnB,GAC1F,OACAV,IAAAM,EAAA1C,KAAA2C,QAAAuB,cAAA,GACArB,WAAAiB,EACAK,WAAAN,EACAO,OAAAL,EACAjB,WACAN,KAAAf,EACA4C,QAAArE,EACAsE,KAAA5B,EAAA1C,QAAAuE,EAAAvE,EAAAwE,KACAR,WACAC,YArIK5D,EAAA,EAAMqB,KACPrB,EAAA,EAAMqB,GAAA,IAuIH,MAAA+C,EAAA,kBACA,MAAAC,EACPC,cAEAC,KAAAC,eAAA,IAgBO,SAAAhF,EAAAuC,EAAAS,EAAA,MAAiCC,GAGxC,GAFAA,EAAetF,OAAAkD,EAAA,EAAAlD,CAAIsF,EAAAgC,KACnBjC,EAAA,OAAAA,EAAA,GAAyCA,EACzC,iBAAAT,EACA,OAAAzC,EAAAyC,EAAAS,EAAAC,GAEA,gBAAAV,EAAAI,MAAAK,EAAAkC,mBAAA,CACA,MAAA1H,EAAAwF,EAAAkC,mBAEA,cADAlC,EAAAkC,mBACArF,EAAArC,EAAAwF,EAAAC,GAEA,GAAAV,EAAAI,OAAAiC,EAAA,CAEA,OAAA/E,GADA,IAAA0C,GACA/E,KAAAwF,EAAAC,GAGA,OAAApD,EAAA0C,EAAAS,EAAAC,GAiBA,SAAAkC,EAAAX,EAAAY,GACA,MAAWjF,MAAAgE,SAAQA,EAAAnB,aAAAsB,eAAqCc,EACxD,IAAAjB,GAAA,SAAAA,EACA,OACAnB,WAAAoC,EAAAC,mBACA1H,OAAAwF,OAAA,GAAkCiC,EAAAC,mBAAAD,EAAAjF,KAAA6C,YAAAoC,EAAAjF,KAAA6C,WAClCsB,WAAAc,EAAAjF,KAAAmE,WACAC,OAAAa,EAAAjF,KAAAoE,QAGA,YAAAJ,EACA,OACAnB,WAAA,GACAsB,WAAAc,EAAAjF,KAAAmE,WAAA,QAAoDI,EACpDH,OAAAa,EAAAjF,KAAAoE,QAGA,IAAAZ,EAAA,CACAX,WAAA,IAEA,OAAAsB,GACAX,EAAAW,WAAA,GACAX,EAAAY,OAAAa,EAAAjF,KAAAoE,OACA5G,OAAA2H,KAAAtC,GAAAuC,QAAAC,IACA7B,EAAAX,WAAAwC,GAAAhB,EAAAgB,KAEA7H,OAAA2H,KAAAhB,GAAAiB,QAAAE,IACA9B,EAAAW,WAAAmB,GAAAjB,EAAAkB,aAAAD,KAEA9B,IAEAA,EAAAX,WAAArF,OAAA2H,KAAAtC,GAAA2C,OAAA,CAAA1B,EAAArF,KACAqF,EAAArF,GAAA4F,EAAAkB,aAAA9G,IAAA4F,EAAA5F,GACAqF,GACK,IACLN,GAgCA,SAAAiC,EAAAC,EAAAC,GACA,GAAAzD,EAAAwD,IAAAxD,EAAAyD,GACA,QAAAlD,EAAAiD,EAAA1F,QAAAyC,EAAAkD,EAAA3F,OACA0F,EAAA1F,KAAAqE,UAAAsB,EAAA3F,KAAAqE,WAIAqB,EAAA1F,KAAAoC,MAAAuD,EAAA3F,KAAAoC,KAGAsD,EAAA1F,KAAA6C,WAAAxE,MAAAsH,EAAA3F,KAAA6C,WAAAxE,KAKA,GAAA2D,EAAA0D,IAAA1D,EAAA2D,GAAA,CACA,MAAAC,EAAAF,EAAAG,cAAAH,EAAA1F,KAAAiD,kBACA6C,EAAAH,EAAAE,cAAAF,EAAA3F,KAAAiD,mBACejD,MAAQ6C,WAAAkD,IAAuBL,GAC/B1F,MAAQ6C,WAAAmD,IAAuBL,EAC9C,YAAApB,IAAAmB,EAAAO,UAAA,iBAAAH,KAGAF,IAAAE,IAGAC,EAAA1H,MAAA2H,EAAA3H,QAGAuH,EAAAT,MAAA,IAAAe,MAAA7H,GAAA0H,EAAA1H,KAAA2H,EAAA3H,MAKA,SAEA,SAAA8H,EAAArD,EAAAsD,EAAAC,GACA,QAAAvJ,EAAAuJ,EAAuBvJ,EAAAgG,EAAA7B,OAAqBnE,IAC5C,GAAA2I,EAAA3C,EAAAhG,GAAAsJ,GACA,OAAAtJ,EAGA,SAEA,SAAAwJ,EAAAhD,EAAA,IACA,IAAAiD,EAAA,GACA,GAAAnD,MAAAC,QAAAC,GAAA,CACA,QAAAxG,EAAA,EAAuBA,EAAAwG,EAAArC,OAAoBnE,IAAA,CAC3C,IAAA0J,EAAAlD,EAAAxG,GACA0J,IAAA,IAAAA,IACAD,OAA6CA,KAAcC,IAAUA,GAGrE,OAAAD,EAKA,OAHAjD,IAAA,IAAAA,IACAiD,EAAAjD,GAEAiD,EAEA,SAAAE,EAAApC,EAAAiB,EAAAoB,EAAAC,GACAA,IAAAvF,GAAA,SAAAkE,GAAAoB,EACArC,EAAAuC,eAAAtF,EAAAgE,EAAAoB,GAEA,SAAApB,GAAA,KAAAoB,QAAAnC,IAAAmC,EACArC,EAAAwC,gBAAAvB,GAGAjB,EAAAyC,aAAAxB,EAAAoB,GAGA,SAAAK,EAAAC,GACA,OAAA5D,MAAA1E,UAAAuI,MAAAhK,KAAA+J,GAEA,SAAAE,EAAAC,EAAAC,EAAA/I,GACA,MAAAgJ,EAAA,CAAAxE,EAAAC,KACA,GAAAD,EAAA,CACA,MAAAyE,EAAA5H,EAAAyH,EAAAtE,EAAAC,GAGA,OAFAqE,EAAAI,UAAA,EACAJ,EAAAC,cACAE,EAEA,OACAF,cACAD,aAGAhC,EAAA3H,OAAA2H,KAAAiC,GAAA5B,OAAA,CAAAL,EAAAqC,KACA,MAAAC,EAAAL,EAAAI,GAIA,OAHAC,EAAAtC,OACAA,EAAA,IAAAA,KAAAsC,EAAAtC,OAEAA,GACK9G,EAAA,CAAAA,GAAA,IAIL,OAHA8I,EAAAhC,OACAkC,EAAAlC,OACAkC,EAAAK,WAAA,EACAL,EAEO,SAAAjJ,EAAAgJ,EAAA,IAgDP,SAAAO,EAAAR,GACA,OAAAD,EAAAC,EAAAC,GAIA,OAFAO,EAAA7E,SAvBA,WAcA,SAAA6E,EAAAR,GACA,OAAAD,EAAAC,EAAAC,GAGA,OADAO,EAAA9E,WAhBA,WACA,SAAA8E,EAAAR,GACA,OAAAD,EAAAC,EAAAC,GASA,OADAO,EAAAtJ,IANA,SAAAA,GAIA,OAHA,SAAA8I,GACA,OAAAD,EAAAC,EAAAC,EAAA/I,KAKAsJ,GAMAA,GAMAA,EAAA9E,WAnDA,WACA,SAAA8E,EAAAR,GACA,OAAAD,EAAAC,EAAAC,GAuBA,OAFAO,EAAA7E,SAbA,WACA,SAAA6E,EAAAR,GACA,OAAAD,EAAAC,EAAAC,GASA,OADAO,EAAAtJ,IANA,SAAAA,GAIA,OAHA,SAAA8I,GACA,OAAAD,EAAAC,EAAAC,EAAA/I,KAKAsJ,GAGAA,EAAAtJ,IApBA,SAAAA,GAIA,OAHA,SAAA8I,GACA,OAAAD,EAAAC,EAAAC,EAAA/I,KAmBAsJ,GA2BAA,EAzQAjD,EAAAlC,KAAAiC,EA2QA,MAAA4C,EAAAjJ,IAUO,MAAA0B,EAAA,IAA8BS,EAAA,EACrCqH,EAAA,IAA0BnH,EAAA,EAC1BoH,EAAA,IAA8BrH,EAAA,EAC9B,IAAAsH,EAAA,EACAC,EAAA,EACA,SAAAC,EAAAC,EAAA5J,EAAA2B,GACA,MAAAkI,EAAAN,EAAAjK,IAAAsK,GACAC,IACAA,EAAAC,QAAAD,EAAAC,SAAA,IAAuD1H,EAAA,EACvDyH,EAAAC,QAAAC,IAAA/J,EAAA2B,GACA6H,EAAAQ,OAAqCJ,KAAM5J,OAC3C6J,EAAAnI,cACA8H,EAAAS,UAAwCL,KAAM5J,OAI9C,SAAAkK,EAAAC,GACA,MAAAC,WAAWA,EAAAC,iBAA4BF,EACvC,GAAAC,EAAA,CAGA,QAAA3L,EAAA,EAAmBA,EAAA4L,EAAAzH,OAA0BnE,IAAA,CAC7C,MAAAmL,EAAAS,EAAA5L,GACAoD,EAAAuI,EAAA9K,IAAAsK,GAGA,GAFA/H,OACAuI,EAAAH,OAAAL,GACA,IAAAQ,EAAAE,KACA,MAGAF,EAAAG,SAiBO,MAAA7I,EAAAsH,EAAA,EAA8BY,SACrC,MAAAY,GAAAZ,EAAAa,MAAA,KACA,WACA,MAAAZ,EAAAN,EAAAjK,IAAAkL,GACA,GAAAX,EACA,OAAAA,EAAAnI,iBAIOC,GAAAqH,EAAA,EAAuBY,SAC9B,CACAtD,IAAAtG,GACA,MAAAwK,GAAAZ,EAAAa,MAAA,KACAZ,EAAAN,EAAAjK,IAAAkL,GACA,GAAAX,EAAA,CACAA,EAAAC,QAAAD,EAAAC,SAAA,IAA+D1H,EAAA,EAC/D,MAAAsI,EAAAb,EAAAa,UACA/I,EAAAkI,EAAAC,QAAAxK,IAAAU,GACA,GAAA2B,IACA+I,EAAAC,SAAAhJ,IACyBK,EAAA,EAAM4I,SAAAC,OAAAH,GAAgC1I,EAAA,EAAM4I,SAAAC,KAAAF,SAAAhJ,IACrE,OAAAA,EAEA6H,EAAAsB,OAAyCN,KAAYxK,KAErD,gBAIO4B,GAAAoH,EAAA,EAA+BY,SA2BtC,OA1BA,SAAAmB,EAAAC,EAAAC,GACA,MAAAT,GAAAZ,EAAAa,MAAA,KACAZ,EAAAN,EAAAjK,IAAAkL,GAIA,GAHAS,IACAA,EAAAD,GAEAnB,EAAA,CACAA,EAAAqB,cAAArB,EAAAqB,eAAA,IAAuE9I,EAAA,EACvEyH,EAAAsB,qBAAAtB,EAAAsB,sBAAA,IAAqFhJ,EAAA,EACrF,MAAAiJ,EAAAvB,EAAAqB,cAAA5L,IAAAsK,IAAA,IAA4ExH,EAAA,EAC5E,IAAAgJ,EAAApB,IAAAe,GAAA,CACA,MAAA9B,EAAAgC,EAAA,GAAsCpB,EAAAwB,yBACtCnF,IAAA+C,IACwB9J,OAAA8C,EAAA,EAAA9C,CAAG,eAC3B0K,EAAAyB,kBACAC,QAAAC,yEAA6G3B,EAAA4B,4DAG7G5B,EAAArF,WAAArF,OAAAwF,OAAA,GAA4DkF,EAAArF,WAAA,CAA0B8B,CAAAyE,GAAA9B,KAEtFmC,EAAArB,IAAAgB,EAAAE,GACApB,EAAAsB,qBAAAL,IAAAC,GAEAlB,EAAAqB,cAAAnB,IAAAH,EAAAwB,OAKOvJ,GAAAmH,EAAA,EAA0BY,QACjC8B,IACA,MAAAlB,GAAAZ,EAAAa,MAAA,KACAZ,EAAAN,EAAAjK,IAAAkL,GACAX,IACAA,EAAAO,WAAAP,EAAAO,YAAA,IAAiEhI,EAAA,EACjEyH,EAAAO,WAAAJ,IAAAJ,IACAC,EAAAO,WAAAL,IAAAH,EAAA8B,MAKO5J,GAAAkH,EAAA,EAA8BY,SACrC,MAAAY,GAAAZ,EAAAa,MAAA,KACA,WACA,MAAAZ,EAAAN,EAAAjK,IAAAkL,GACA,OAAAX,GACAA,EAAA8B,kBACA9B,EAAA8B,gBAAA,IAAiDnJ,EAAA,EACjDqH,EAAA8B,gBAAAC,KAAA/B,EAAAgC,SACAhC,EAAA8B,gBAAAjG,GAAA,aAAAmE,EAAAnI,cAEAmI,EAAA8B,gBAAA9B,EAAA8B,iBAAA,IAA2EnJ,EAAA,EAC3EqH,EAAA8B,iBAEA,QAGO3C,EAAA,EAAwBY,SAC/B,MAAAY,GAAAZ,EAAAa,MAAA,KACA,IAAAqB,GAAA,EACA,OACAxF,QACA,MAAAuD,EAAAN,EAAAjK,IAAAkL,IACAsB,GAAAjC,IACAA,EAAAkC,UAAAlC,EAAAkC,UAAA,EACAD,GAAA,IAGAxF,SACA,MAAAuD,EAAAN,EAAAjK,IAAAkL,GACAsB,GAAAjC,IACAA,EAAAkC,UAAAlC,EAAAkC,UAAA,EACAD,GAAA,OAKA,SAAAE,GAAApC,EAAApF,GACA,MAAAiB,EAAA,GACAwG,EAAA9M,OAAA2H,KAAAtC,GACA,QAAA/F,EAAA,EAAmBA,EAAAwN,EAAArJ,OAA0BnE,IAAA,CAC7C,MAAAsM,EAAAkB,EAAAxN,GACA,mBAAA+F,EAAAuG,IACAtF,EAAAsF,GAAA,YAAAmB,GACA,MAAArC,EAAAN,EAAAjK,IAAAsK,GACA,OAAAC,EACAA,EAAAwB,mBAAAN,MAAAmB,GAEA1H,EAAAuG,MAAAmB,IAEAzG,EAAAsF,GAAAoB,OAAA,MACA,MAAAtC,EAAAN,EAAAjK,IAAAsK,GACA,OAAAC,EACAA,EAAAwB,mBAAAN,GAEAvG,EAAAuG,MAIAtF,EAAAsF,GAAAvG,EAAAuG,GAGA,OAAAtF,EAEO,SAAA1D,MACP,IAiBAqK,EAEAC,EAEAC,EArBAC,EAAA,CACAC,MAAA,EACAC,OAAA,EACAC,gBAAAxG,EACAF,QAAiBhE,EAAA,EAAM4I,SAAAC,KACvBgB,SAAA,IAAsBvJ,EAAA,GAEtBqK,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,IAAwB7K,EAAA,EACxB8K,EAAA,IAA8B5K,EAAA,EAC9B6K,EAAA,IAAiC/K,EAAA,EACjCgL,EAAA,IAAoC9K,EAAA,EACpC+K,EAAA,IAA+BjL,EAAA,EAC/BkL,EAAA,IAAgClL,EAAA,EAEhCmL,EAAA,GAEAC,EAAA,GAEAC,EAAA,IAAkCnL,EAAA,EAClC,SAAAoL,EAAAxG,EAAAyG,EAAAC,EAAA1H,GACA,IAAAiD,EAAAwE,IAAAC,EACA,mBAAAD,IACAxE,EAAAwE,MAEA,IAAAxE,GACAoE,EAAAM,KAAA,KACA3H,EAAAgB,OAIA,SAAA4G,GAAA5H,EAAA6H,EAAAC,EAAAJ,GACA,GAAAA,EAAA,CACA,MAAAK,EAAAhB,EAAAzN,IAAAoO,GACAK,GAAA/H,EAAAgI,oBAAAH,EAAAE,GAEA,IAAAjF,EAAAgF,EACA,UAAAD,IACA/E,EAAA,SAAAmF,GACAH,EAAAlP,KAAA2H,KAAA0H,GACAA,EAAAC,OAAA,iBAAAD,EAAAC,OAAAxO,QAGAsG,EAAAmI,iBAAAN,EAAA/E,GACAiE,EAAAhD,IAAA+D,EAAAhF,GAEA,SAAAsF,GAAApI,EAAAqI,EAAA7J,EAAA8J,GAAA,GACAnP,OAAA2H,KAAAuH,GAAAtH,QAAAC,IACA,MAAAuH,EAAA,OAAAvH,EAAAwH,OAAA,MAAAF,EACAT,EAAAS,EAAAtH,IAAAwH,OAAA,GACA,GAAAD,IAAA/J,EAAAwC,GAAA,CACA,MAAAyH,EAAA1B,EAAAzN,IAAA+O,EAAArH,IACAyH,GACAzI,EAAAgI,oBAAAH,EAAAY,MAKA,SAAAC,GAAAzK,EAAA2D,EAAAgC,GACA,IAAazK,OAAAmD,EAAA,EAAAnD,CAAQ8E,EAAAtC,KAAAiD,mBAAA,CACrB,MAAA+J,EAAAvB,EAAA9N,IAAA2E,EAAAtC,MASA,IAAAkK,EACA,GATA8C,IACAA,EAAA/G,SACAA,EAAA+G,EAAA/G,SAGAgC,EAAA+E,EAAA/E,IAIAhC,EAAA,CACA,MAAAgH,EAAAnN,EAAAnC,IAAAsI,GACAgH,IACA/C,EAAA+C,EAAA/C,eAGA,QAAA3F,IAAA0D,EAAA,CACA,MAAAC,EAAAN,EAAAjK,IAAAsK,GACAC,IACAA,EAAA8B,kBACA9B,EAAA8B,gBAAA,IAAyDnJ,EAAA,EACzDqH,EAAA8B,gBAAAC,KAAA/B,EAAAgC,SACAhC,EAAA8B,gBAAAjG,GAAA,aAAAmE,EAAAnI,cAEAmK,EAAAhC,EAAA8B,iBAGA,GAAAE,EAAA,CACA,IAAAgD,EACA,GApqBA,SAAApL,GACA,OAAAS,QAAAT,KAAAqL,OAmqBAC,CAAA9K,EAAAtC,KAAAiD,mBAAA,CACA,MAAAkK,MAA2BA,EAAAtH,gBAAsBvD,EAAAtC,KAAAiD,kBACjDiH,EAAA7B,IAAA8E,IACAjD,EAAAmD,OAAAF,EAAAtH,GAEAqH,EAAAC,OAGAD,EAAA5K,EAAAtC,KAAAiD,kBAEA,IAAAnB,EAAAoI,EAAAvM,IAAAuP,GACA,GAAoB1P,OAAAmD,EAAA,EAAAnD,CAAcsE,GAAA,CAClC,MAAA9B,EAAA8B,EAAAQ,EAAAtC,KAAA6C,WAAAP,EAAAtC,KAAA8C,UACwBtF,OAAAmD,EAAA,EAAAnD,CAAgBwC,EAAAiD,qBACxCX,EAAAuD,aAAA7F,EAAAiD,wBAIAX,EAAAuD,aAAA/D,IAkBA,SAAAwL,GAAAC,EAAAC,EAAAC,GACA,MAAAC,qBAAeA,EAAAC,sBAAAhH,YAAAiH,SAA8DJ,EAC7EK,EAAA,GACAC,EAAA9L,EAAAwL,GACAO,EAAA5L,EAAAqL,GAEAQ,GADA9L,EAAAuL,IAAAlC,EAAA5N,IAAA8P,EAAAxF,KAAA,IACAhH,OAAA,EACAgN,GAAAP,IAAA,IAAAC,KAAAG,GAAAC,IACAC,GAAAT,EAAAtM,OAAA,EACA,IAAAiN,EACAlM,EAAAwL,IAAAD,EAAAtM,QAvBA,SAAAkN,EAAA7L,GACA,KAAA6L,EAAAlN,QAAA,CACA,IAAAjB,EAAAmO,EAAAC,OACA5O,EAAAQ,IAAAP,EAAAO,MACAyL,EAAApD,IAAArI,KACAyL,EAAArD,IAAApI,EAAAsC,GACAtC,EAAA8C,UAAA9C,EAAA8C,SAAA7B,SACAkN,EAAA,IAAAA,KAAAnO,EAAA8C,cAiBAuL,CAAA,IAAAd,GAAAC,GAEA,QAAA1Q,EAAA,EAAuBA,EAAAyQ,EAAAtM,OAAqBnE,IAAA,CAC5C,IAAAwR,EAAAf,EAAAzQ,GACA,IAAAwR,IAAA,IAAAA,EACA,SAEA,iBAAAA,IACAA,EA5rBA,CACAlM,IAAA,GACAS,WAAA,GACAC,cAAAyB,EACAD,QAwrBAgK,IAvrBA9L,KAAAhB,IAyrBA,MAAAwL,EAAAvB,EAAA9N,IAAA2Q,GACAhM,EAAA,CACAtC,KAAAsO,EACAV,QAAA,EACAW,MAAAzR,EACA0R,SAAAhB,EAAAvF,GACAyF,qBAAAO,EACAH,iBACAnH,aAEA,GAAAlH,EAAA6O,KACAA,EAAAnL,6BACAb,EAAA4C,mBAAAoJ,EAAAnL,4BAAA,IAEAmL,EAAAzL,WAAA4L,eAAA,CACAjB,EAAAkB,eAAA,EACA,IAAAC,EAAAtD,EAAA1N,IAAA6P,EAAAgB,UACA,KAAAG,IACAA,EAAAD,eAGAC,EAAAD,eAAA,EACAC,EAAAtD,EAAA1N,IAAAgR,EAAAH,UAIAxB,IACA1K,EAAAsM,SAAA5B,EAAA/E,IAEAzI,EAAA8O,IACAvB,GAAAzK,EAAAkL,EAAAvH,SAAAuH,EAAAvF,IAEAiG,GACA5C,EAAAlD,IAAA8F,EAAA5L,GAEAuL,EAAA7B,KAAA1J,GACA4L,EAAA5L,EAEA,OAAAuL,EAgBA,SAAAgB,GAAAC,GACA,MAAA3L,2BAAeA,GAA6B2L,EAAA9O,KAC5C,GAAAmD,EAAA,CACA,MAAAN,EAAAiM,EAAA9O,KAAA6C,WACA6I,EAAAM,KAAA,KACA,GAAAX,EAAAhD,IAAAyG,EAAAF,UAAA,CACA,MAAA1J,EAAA4J,EAAA5J,mBACA4J,EAAA5J,mBAAA/B,GAAA,GACA4L,GAAAD,EAAA,CACAjM,WAAArF,OAAAwF,OAAA,GAAoDkC,EAAArC,SAMpD,SAAAmM,GAAAF,GACA,IAAAb,EAAA,KACAgB,EAAAH,EACA,MAAAb,GAAA,CACA,MAAAiB,EAAA5D,EAAA3N,IAAAsR,GACA,GAAAC,EAAA,CACA,IAAA7K,EAAA6K,EAAA7K,QACA,IAAArC,EAAAkN,IAAA/M,EAAA+M,MACAA,EAAAC,oBACAD,EAAAC,kBAAAC,GAAAF,EAAAjH,KAEAiH,EAAAC,mBAAA,CACA,MAAAE,EAAAhE,EAAA1N,IAAAuR,EAAAC,mBACAE,IAAAhN,EAAAgN,KACAhL,EAAAgL,EAAAhL,SAIA,GAAAA,KAAAiL,WAAA,CACArB,EAAA5J,EACA,MAEA4K,EAAAC,OAIA,KADAD,KAAA5D,EAAA1N,IAAAsR,EAAAT,YACAtM,EAAA+M,KAAA9M,EAAA8M,GACA,MAGA,OAAAhB,EAEA,SAAAsB,GAAAlL,EAAAyH,EAAAC,GACA,MAAAyD,EAAAnL,EAAAtG,MACA0R,EAAApL,EAAA,iBACAqL,EAAArL,EAAA,gBACAqL,GAAAF,IAAAE,GACArL,EAAAtG,MAAA2R,EACArL,EAAAtG,QAAA2R,IACArL,EAAA,qBAAAE,KAGAkL,GAAAD,IAAAC,GAAA3D,IAAAC,KACA1H,EAAAtG,MAAA+N,EACAzH,EAAA,sBAAAE,GAGA,SAAAoL,GAAAtL,EAAAuL,EAAA,GAA0DC,EAAAC,GAAA,GAC1D,MAAAjN,EAAAgN,EAAA3K,mBACA1H,OAAAwF,OAAA,GAA8B6M,EAAA3K,mBAAA2K,EAAA7P,KAAA6C,YAAAgN,EAAA7P,KAAA6C,WAC9BkN,EAAAvS,OAAA2H,KAAAtC,GACAmN,EAAAD,EAAA9O,QACA,IAAA8O,EAAA5Q,QAAA,YAAAyQ,EAAAtM,SACAe,EAAAwC,gBAAA,SAEAiJ,GAAArD,GAAApI,EAAAuL,EAAA/M,GACA,QAAA/F,EAAA,EAAuBA,EAAAkT,EAAelT,IAAA,CACtC,MAAAuI,EAAA0K,EAAAjT,GACA,IAAAgP,EAAAjJ,EAAAwC,GACA,MAAA0G,EAAA6D,EAAAvK,GACA,eAAAA,EAAA,CACA,MAAA4K,EAAA3J,EAAAyF,GACA,IAAAmE,EAAA5J,EAAAwF,GACA,GAAAmE,IAAAC,EACA,GAAAA,EAAA,CACA,GAAAL,EAAAM,OAAA,CACA,MAAAC,GAAA/L,EAAAkB,aAAA,cAAAuD,MAAA,KACA,QAAAhM,EAAA,EAA2CA,EAAAsT,EAAAnP,OAAuBnE,KAClE,IAAAoT,EAAA/Q,QAAAiR,EAAAtT,MACAoT,KAA4DE,EAAAtT,MAAiBoT,KAI7E7L,EAAAyC,aAAA,QAAAoJ,QAGA7L,EAAAwC,gBAAA,cAIA,QAAA1F,EAAAhC,QAAAkG,GACAwG,EAAAxG,EAAAyG,EAAAC,EAAA1H,QAEA,cAAAgB,EAAA,CACA,MAAAgL,EAAA7S,OAAA2H,KAAA2G,GACAwE,EAAAD,EAAApP,OACA,QAAAsP,EAAA,EAA+BA,EAAAD,EAAgBC,IAAA,CAC/C,MAAAC,EAAAH,EAAAE,GACAE,EAAA3E,EAAA0E,GAEAC,KADA1E,KAAAyE,MAIAnM,EAAAqM,MAAAF,GAAAC,GAAA,UAOA,GAHA3E,GAAA,iBAAAC,IACAD,EAAA,IAEA,UAAAzG,EACA,WAAAhB,EAAA1B,UACA0B,EAAA,gBAAAyH,GAEAyD,GAAAlL,EAAAyH,EAAAC,QAEA,WAAA1G,GAAAyG,IAAAC,EAAA,CACA,MAAAvJ,SAAAsJ,EACA,aAAAtJ,GAAA,IAAA6C,EAAAsL,YAAA,SAAAb,EACA7D,GAAA5H,EAAAgB,EAAAwH,OAAA,GAAAf,EAAAC,GAEA,WAAAvJ,GAAA,cAAA6C,GAAAyK,EACArJ,EAAApC,EAAAgB,EAAAyG,EAAA+D,EAAAlJ,WAEA,eAAAtB,GAAA,cAAAA,EACAhB,EAAAgB,KAAAyG,IACAzH,EAAAgB,GAAAyG,GAIAzH,EAAAgB,GAAAyG,IAMA,SAAA8E,KACA,MAAAC,EAAAnF,EAEA,GADAA,EAAA,GACAmF,EAAA5P,OACA,WACA,IAAAkG,EACA,KAAAA,EAAA0J,EAAAC,SACA3J,KAKA,SAAA4J,KACA,MAAAlG,KAAeA,GAAOD,EACtBoG,EAAAJ,KACA,GAAAI,EACA,GAAAnG,EACAmG,QAEA,CACA,IAAA/I,EACAA,EAAqB5H,EAAA,EAAM4Q,sBAAA,KAC3BrF,EAAAtD,OAAAL,GACA+I,MAEApF,EAAAxD,IAAAH,EAAA+I,IAIA,SAAAjC,GAAAD,EAAApC,GACA,GAAAoC,EAAA9O,KAAAmE,YAAA2K,EAAA9O,KAAAoE,OAAA,EAv5BA,SAAAC,EAAA6M,EAAA/M,EAAAwC,GACA,MAAAwK,EAAA3T,OAAA2H,KAAAhB,GACAiN,EAAAD,EAAAlQ,OACA,QAAAnE,EAAA,EAAmBA,EAAAsU,EAAetU,IAAA,CAClC,MAAAwI,EAAA6L,EAAArU,GACA4J,EAAAvC,EAAAmB,GAEAoB,IADAwK,EAAA5L,IAEAmB,EAAApC,EAAAiB,EAAAoB,EAAAC,IAg5BA0K,CAAAvC,EAAAzK,QAAAqI,EAAAvI,YAAA,GAA8E2K,EAAA9O,KAAAmE,WAAA2K,EAAAnI,WAC9EgJ,GAAAb,EAAAzK,QAAAqI,EAAA7J,WAAAiM,GAAA,GACA,MAAA1K,EAAA0K,EAAA9O,KAAAoE,QAAA,GACAsI,EAAAtI,QACAqI,GAAAqC,EAAAzK,QAAAqI,EAAAtI,QAAA,GAAkF0K,EAAA9O,KAAAoE,QAAA,GAElFsI,EAAAtI,OAAAsI,EAAAtI,QAAA,GACA5G,OAAA2H,KAAAf,GAAAgB,QAAAkM,IACArF,GAAA6C,EAAAzK,QAAAiN,EAAAlN,EAAAkN,GAAA5E,EAAAtI,OAAAkN,WAIA3B,GAAAb,EAAAzK,QAAAqI,EAAA7J,WAAAiM,GAgFA,SAAAyC,KACA,MAAA1G,KAAeA,GAAOD,EACtBC,EACA2G,KAEA/G,IACA7I,GAAA,GACA6I,EAA+BpK,EAAA,EAAM4Q,sBAAA,KACrCO,QAIA,SAAAC,GAAAxJ,GACA,MAAA3F,EAAA+I,EAAA1N,IAAAsK,GACA,GAAA3F,GAAAN,EAAAM,GACA,OAAAA,EAGA,SAAAkP,KACA/G,OAAAlG,EACA,IAAAmN,EAAA,IAAA1G,GACA,MAAA2G,EAAA,GAkBA,IAAA7P,EACA,IAlBAkJ,EAAA,GACA0G,EAAAE,KAAA,CAAAC,EAAAC,KACA,IAAAxK,EAAAwK,EAAAlE,MAAAiE,EAAAjE,MAIA,OAHA,IAAAtG,IACAA,EAAAwK,EAAAvD,MAAAsD,EAAAtD,OAEAjH,IAEA4D,EAAAjK,SACAgK,EAAA,IAAAC,GACAA,EAAA,GACA6G,KACA7G,EAAAjK,SACA+J,EAAA,IAAA0G,GACAA,EAAA,KAIA5P,EAAA4P,EAAAtD,OAAA,CACA,IAAAnG,GAAiBA,GAAKnG,EACtB,MAAAmD,EAAAwM,GAAAxJ,GACA,IAAAhD,IAAA,IAAA0M,EAAAxS,QAAA8I,KAAAoD,EAAAhD,IAAApD,EAAAuJ,UACA,SAEAmD,EAAA3F,KAAA/D,GACA,MAAA+J,EAAA1G,EAAA3N,IAAAsH,GACA6J,EAAA,CACA9O,KAAA,CACAwC,KAAAjB,EACA0B,kBAAAgC,EAAAjF,KAAAiD,kBACAJ,WAAAoC,EAAApC,YAAA,GACAC,SAAAmC,EAAAjF,KAAA8C,UAAA,IAEAmD,SAAAhB,EAAAgB,SACAgC,GAAAhD,EAAAgD,GACApF,WAAAoC,EAAApC,WACA+K,MAAA3I,EAAA2I,MACAW,MAAAtJ,EAAAsJ,MACAK,SAAA3J,EAAA2J,SACAJ,SAAAvJ,EAAAuJ,SACA3I,aAAAZ,EAAAY,cAEAmM,GAAA1G,EAAAlD,IAAA0G,EAAAkD,GACA,MAAA1K,EAAA2K,GAAA,CAA0ChN,UAAA6J,SAC1CxH,KAAAxF,OACAmJ,EAAAe,KAAA1E,EAAAxF,MACAuJ,EAAAjD,IAAAH,EAAA6G,GACAiD,MAGAG,KACAC,KACApB,KACAtG,GACA7I,GAAA,GAGA,SAAAuQ,KACA,OAAAjH,EAAAjK,OAAA,CACA,IAAAmR,EACA,KAAAA,EAAAzG,EAAAyC,OACAgE,EAAA9C,YAAA8C,EAAA9C,WAAA+C,YAAAD,GAEAxH,EAAAE,OAAA,GAGA,SAAAiH,KACA,IAAAjQ,EACA,KAAAA,EAAAmJ,EAAAmD,OACA,GAAAtM,EAtmCAU,KAumCAV,EAAAmE,UAAAkF,EAAAa,KAAAlK,OAEA,CACA,MAAAmD,QAAuBA,EAAA6J,OAAAtG,QAAsB1G,EAC7CwQ,GAAArN,GAAA/D,EAAA4N,GAAA5N,EAAAsH,IAIA,SAAA0J,KAEA,IAAApQ,EACA,IAFAqJ,EAAAoH,UAEAzQ,EAAAqJ,EAAAiD,OACA,cAAAtM,EAAAU,KAAA,CACA,MAAAgQ,cAAuBA,EAAA1D,aAAAzK,QAA6BA,EAAA8L,SAAAzC,uBAAA1N,SAAgD8B,EAGpG,GAFAiN,GAAAD,EAAA,CAAyCjM,WAAA,KACzCgM,GAAAC,IACAqB,EAAA,CACA,IAAAlC,EACAP,EACAO,EAAAe,GAAAF,GAEAtD,IACAyC,EAAAzC,EAAA7N,IAAAmR,IAEA0D,EAAAvE,aAAA5J,EAAA4J,GACAxL,EAAAqM,EAAA9O,OAAA8O,EAAA9O,KAAAiE,UACA6K,EAAA9O,KAAAiE,WAGA,WAAAI,EAAA1B,SAAA0B,EAAAoO,eACAlD,GAAAlL,EAAAoO,eAEA,MAAAC,eAAuBA,EAAAC,wBAAuC3S,EAAA6C,WAC9D+H,EAAAG,YAAA2H,IAAA,IAAAA,GACA9H,EAAAG,WAAA6H,MAAAvO,EAAAqO,EAAAC,GAEA,MAAAE,EAAApH,EAAA9N,IAAAmR,EAAA9O,MACA,GAAA6S,GAAA,MAAA7S,EAAA6C,WAAAxE,IACA,GAAAwU,EAAA5M,SAAA,CACA,MAAAgH,EAAAnN,EAAAnC,IAAAkV,EAAA5M,UACAgH,KAAA6F,YAAA3J,IAAA9E,KAAiFrE,EAAA6C,WAAAxE,YAGjF2J,EAAA6K,EAAA5K,GAAAjI,EAAA6C,WAAAxE,IAAAgG,GAGAvC,EAAAgN,KAAAiE,UAAA,OAEA,cAAAjR,EAAAU,KAAA,CACA,MAAAsM,KAAuBA,QAAAzK,QAAcA,GAAUY,mBAAqBZ,QAAA2O,IAA4BlR,EAChG,GAAAvC,EAAA8E,IAAA9E,EAAAyT,IAAA3O,IAAA2O,EACAA,EAAA1D,YAAA0D,EAAA1D,WAAA2D,aAAA5O,EAAA2O,OAEA,CAEAjE,GAAAD,EADA9J,EAAAX,EAAAY,IAEA4J,GAAAC,SAGA,cAAAhN,EAAAU,KAAA,CACA,MAAAyC,QAAuBA,GAAUnD,GACjC2M,cAAuBA,EAAAyE,uBAAqCjO,EAAAjF,KAAA6C,WAC5D+H,EAAAG,YAAA0D,IAAA,IAAAA,EACA7D,EAAAG,WAAAoI,KAAAlO,EAAAZ,QAAAoK,EAAAyE,GAGAjO,EAAAZ,QAAAiL,WAAA+C,YAAApN,EAAAZ,cAGA,cAAAvC,EAAAU,KAAA,CACA,MAAAyD,SAAuBA,EAAAmN,YAAqBtR,EAC5CmL,EAAAnN,EAAAnC,IAAAsI,GACAgH,IACAA,EAAA6F,YAAAO,UACAD,GAAAnG,EAAAhJ,iBAGA,cAAAnC,EAAAU,KAAA,CACA,GAAAV,EAAAmD,QAAAgB,SAAA,CACA,MAAAgH,EAAAnN,EAAAnC,IAAAmE,EAAAmD,QAAAgB,UACAgH,KAAAqG,WAEAxR,EAAAmD,QAAAgB,cAAA1B,EAGA,IAAA2G,EAAAjK,SACAwK,EAAA,IAAoClL,EAAA,GA2BpC,SAAAgT,GAAAC,EAAAC,IAvhCA,SAAAC,EAAAD,EAAAE,GACA,MAAAC,EAAAF,EAAAD,GACA,GAAAvR,EAAA0R,OAAA5T,KAAAoC,IACA,OAEA,MAAA/D,IAAWA,GAAMuV,EAAA5T,KAAA6C,WACjB,IAAAgR,EAAA,UACA,GAAAF,EAAA,CACA,MAAe3T,MAAAiD,kBAAQA,IAAsB0Q,EAC7CE,EAAA5Q,EAAA5F,MAAA,UAEA,GAAAgB,QACA,QAAAvB,EAAA,EAAuBA,EAAA4W,EAAAzS,OAAqBnE,IAC5C,GAAAA,IAAA2W,EAAA,CACA,MAAAnR,EAAAoR,EAAA5W,GACA,GAAA2I,EAAAnD,EAAAsR,GAAA,CACA,IAAAE,EAEAA,EADA9R,EAAAM,GACAA,EAAAtC,KAAAiD,kBAAA5F,MAAA,UAGAiF,EAAAtC,KAAAoC,IAEAwH,QAAAC,kBAA8CgK,mLAA4LC,iCAC1O,QAigCAC,CAAAP,EAAAC,EADAhC,GAAA+B,EAAAC,GAAA7E,WAGA,SAAAoF,GAAAN,GACA,MAAAvO,EAAA,GACA,QAAArI,EAAA,EAAuBA,EAAA4W,EAAAzS,OAAqBnE,IAAA,CAC5C,MAAAwF,EAAAoR,EAAA5W,GACA,SAAAwF,EAAAtC,KAAA6C,WAAAxE,IAIA,SAHA8G,EAAA6G,KAAA1J,EAAAtC,KAAA6C,WAAAxE,KAMA,OAAA8G,EAEA,SAAAmN,GAAArN,EAAA6J,EAAAtG,EAAA,IACA,IAAAyL,WAAaA,EAAA,GAAAC,WAAA,EAAAC,WAAA,GAA8C3L,EAC3D,MAAA4L,EAAAnP,EAAAhE,OACAoT,EAAAvF,EAAA7N,OACA0M,EAAAyG,EAAA,GAAAA,EAAA,GAAAA,EAAAC,EACA,IAAAC,EAAA,GACAC,GAAA,EACA,OAAAL,GAAA,IAAAC,GAAAC,EAAA,CACA,MAAAI,EAAAR,GAAA/O,GACA,GAAAuP,EAAA,CACA,MAAAC,EAAAT,GAAAlF,GACA,GAAA2F,EACA,QAAA3X,EAAA,EAAmCA,EAAA0X,EAAAvT,OAAwBnE,IAAA,CAC3D,QAAA2X,EAAAtV,QAAAqV,EAAA1X,IAAA,CACAwX,EAAA,GACAC,GAAA,EACA,MAEAA,GAAA,EACAD,EAAAtI,KAAA,CAA2C/G,UAAAnI,GAAAgS,UAAAvK,MAK3C,GAAAgQ,GAAA,IAAAH,IAAAxJ,EAAAE,MACA,QAAAhO,EAAA,EAA2BA,EAAAgS,EAAA7N,OAAiBnE,IAC5CwX,EAAAtI,KAAA,CAAmC/G,aAAAV,EAAAuK,OAAAhS,SAGnC,CACA,GAAAqX,EAAAE,EAAA,CACA,IAAAK,EAAAR,EAAAE,EAAAnP,EAAAiP,QAAA3P,EACA,MAAAsL,EAAAf,EAAAqF,GACAtE,EAAAlC,sBA1EA,SAAAmB,EAAAmF,GACA,MAAAnJ,MAAeA,GAAQF,EACvB,GAAAE,GAAAmJ,EAAAhT,OACA,GAAAiB,EAAA4M,GAAA,CACA,IAAqB9O,MAAAoC,IAAQA,IAAQ0M,EACrC,QAAAhS,EAAA,EAA+BA,EAAAmX,EAAAhT,OAAuBnE,IAAA,CACtD,MAAA6X,EAAAV,EAAAnX,GACA6F,EAAAgS,EAAAhS,SAAA,GACA,GAAAP,EAAAwS,gBAAAjS,EAAAiS,cAAA,CACA,MAAAC,EAAAlJ,EAAAxM,QAAAwV,IACA,IAAAE,GACAlJ,EAAAmJ,OAAAD,EAAA,GAEAZ,EAAAa,OAAAhY,EAAA,GACAgS,EAAAzK,QAAAsQ,EACA,aAKA7F,EAAAmF,aAuDAc,CAAAlF,EAAAoE,GACAS,GAAAjP,EAAAiP,EAAA7E,IACAqE,IACAC,IACAjS,EAAAwS,IAAAxS,EAAA2N,KACAA,EAAAkD,SAAA2B,EAAA3B,UAEAuB,EAAAtI,KAAA,CAAuC/G,QAAAyP,EAAA5F,KAAAe,KAEvC6E,IAAA,IAAAvO,EAAAlB,EAAA4K,EAAAqE,EAAA,IAKA,IAAA/N,EAAA2I,EAAA4F,EAAAP,EAAA,IACoB3W,OAAA8C,EAAA,EAAA9C,CAAG,eAAA+V,GAAAtO,EAAAiP,GACvBI,EAAAtI,KAAA,CAAuC/G,QAAAyP,EAAA5F,UAAAvK,IACvC2P,MAGoB1W,OAAA8C,EAAA,EAAA9C,CAAG,eAAA+V,GAAAzE,EAAAqF,GACH3W,OAAA8C,EAAA,EAAA9C,CAAG,eAAA+V,GAAAtO,EAAAiP,GACvBI,EAAAtI,KAAA,CAAuC/G,QAAAyP,EAAA5F,UAAAvK,IACvC+P,EAAAtI,KAAA,CAAuC/G,aAAAV,EAAAuK,KAAAe,IACvCqE,IACAC,MAfoB3W,OAAA8C,EAAA,EAAA9C,CAAG,eAAAyH,EAAAhE,QAAAsS,GAAAzE,EAAAqF,GACvBG,EAAAtI,KAAA,CAAuC/G,aAAAV,EAAAuK,KAAAe,IACvCsE,KAmBA,GAHAA,EAAAE,GACApJ,EAAAe,KAAA,CAAoC/G,UAAA6J,OAAAtG,KAAA,CAAuByL,aAAAC,WAAAC,cAE3DC,EAAAF,GAAAC,GAAAE,EACA,QAAAvX,EAAAoX,EAAsCpX,EAAAsX,EAAmBtX,IACrCU,OAAA8C,EAAA,EAAA9C,CAAG,eAAA+V,GAAAtO,EAAAnI,GACvBwX,EAAAtI,KAAA,CAAuC/G,UAAAnI,GAAAgS,UAAAvK,IAIvC,QAAAzH,EAAA,EAAuBA,EAAAwX,EAAArT,OAAyBnE,IAAA,CAChD,MAAAwK,EAAA0N,GAAAV,EAAAxX,IACA,QAAAwK,EAAA,CACA,GAAAsD,EAAAE,OAAAmJ,EAAAhT,OAAA,CACAkT,EAAAE,GACApJ,EAAAmD,MAEAnD,EAAAe,KAAA,CAAwC8C,OAAA7J,UAAAuD,SACxC0C,EAAAD,EACAA,EAAA,GACA,MAEA,SAEA,MAAAgK,OAAmBA,EAAAnT,OAAAlC,OAAoB0H,EACvC2N,GAAAhK,EAAAe,KAAAiJ,GACAnT,GAAAmJ,EAAAe,KAAAlK,GACAlC,GAAAuL,EAAAa,KAAApM,IAGA,SAAAoV,IAAA/P,QAA0BA,EAAA6J,SAC1B,GAAA7J,IAAA6J,EAAA,CACA,IAAA7J,GAAA6J,EACA,OAAA5M,EAAA4M,GAuRA,UAAAA,KAAyBA,IACzB,MAAA0D,EA32BA,SAAA0C,GACA,IAAA1C,EACA2C,EAAA9J,EAAA1N,IAAAuX,EAAA1G,UACA,MAAAgE,GAAA2C,IACA3C,GACAtQ,EAAAiT,KACAhT,EAAAgT,IACAA,EAAA9Q,UACAmO,EAAA2C,EAAA9Q,SAEA8Q,EAAA9J,EAAA1N,IAAAwX,EAAA3G,UAEA,OAAAgE,EA+1BA4C,CAAAtG,GACAuG,EAAAlT,EAAA2M,GACAwG,EAAAjT,EAAAyM,GACA,IA8CAhM,EA9CAmR,EAAA,GACAnF,EAAA7G,MAAqBH,MACrBuD,EAAAjD,IAAA0G,EAAA7G,GAAA6G,GACAA,EAAAzK,QA6BAuG,EAAAE,QACAgE,EAAAqB,QAAA,EACA5Q,EAAAuP,EAAAzK,SACAyK,EAAAzK,QAAAG,OAAAsK,EAAA9O,KAAAsE,OACAqH,EAAA,CAAAmD,EAAAzK,WAAAsH,GACAmD,EAAAzK,QAAmChE,EAAA,EAAM4I,SAAAsM,eAAAzG,EAAA9O,KAAAsE,MACzCwK,EAAAqB,QAAA,IAIA8D,EAAAlN,EAAA+H,EAAAzK,QAAAmP,YACA7H,EAAA,IAAAA,KAAAsI,MAvCAnF,EAAA9O,KAAAqE,QACAyK,EAAAzK,QAAAyK,EAAA9O,KAAAqE,SAGA,QAAAyK,EAAA9O,KAAAoC,MACA0M,EAAAnI,UAAAvF,GAEAkU,EACAxG,EAAAzK,QAAmChE,EAAA,EAAM4I,SAAAC,KAEzC4F,EAAA9O,KAAAoC,MAAAiT,EACAvG,EAAAnI,UACAmI,EAAAzK,QAAuChE,EAAA,EAAM4I,SAAAuM,gBAAA1G,EAAAnI,UAAAmI,EAAA9O,KAAAoC,KAG7C0M,EAAAzK,QAAuChE,EAAA,EAAM4I,SAAAwM,cAAA3G,EAAA9O,KAAAoC,KAG7C,MAAA0M,EAAA9O,KAAAsE,OACAwK,EAAAzK,QAAmChE,EAAA,EAAM4I,SAAAsM,eAAAzG,EAAA9O,KAAAsE,QAGzCkH,GAAAG,EAAA1K,QACAuR,IAAA7G,EAAA,GAAA2D,YACA9D,EAAApD,IAAA0G,EAAAnD,EAAA,MAmBAmD,EAAAzK,SAAAgR,IACAvG,EAAA9O,KAAA8C,UAAAgM,EAAA9O,KAAA8C,SAAA7B,SACA6B,EAAAwK,GAAAwB,EAAA9O,KAAA8C,SAAAgM,EAAA,MACAvD,EAAAnD,IAAA0G,EAAA7G,GAAAnF,IAGA,MAAAlD,EAAAyV,GAAAC,OACA/Q,EACA,CACAuK,OACA0D,gBACAhQ,KAAA,UAEA,GAAAM,EACA,OACAhB,KAAA,CACAmD,QAAA,GACA6J,KAAAhM,EACA0F,KAAA,CAA2ByL,eAE3BrU,MACAqV,OAAAI,EAAA,CAAqC7S,KAAA,SAAAyF,GAAA6G,EAAA7G,GAAAmL,UAAA,QAA+C7O,GAGpF,OAAgB3E,OAjWhB8V,CAAA,CAAuC5G,SAiEvC,UAAAA,KAA4BA,IAC5B,IAUAvB,EACAoI,GAXa3V,MAAAiD,kBAAQA,IAAsB6L,GAC3C5E,SAAaA,GAAWU,EACxBgL,EAAA9G,EAAAjJ,cAAA5C,EACA,IAAazF,OAAAmD,EAAA,EAAAnD,CAAQoY,GAAA,CAErB,GADA7I,GAAA+B,IACAA,EAAAjJ,aACA,SAEA+P,EAAA9G,EAAAjJ,aAIAiJ,EAAAjM,WAAArF,OAAAwF,OAAA,GAA0C8L,EAAA9O,KAAA6C,YAC1CiM,EAAA7G,GAAA6G,EAAA7G,OAAgCH,MAChCuD,EAAAjD,IAAA0G,EAAA7G,GAAA6G,GACA,MAAA7G,GAAeA,EAAA2F,QAAAW,SAAmBO,EAClC,GAAatR,OAAAmD,EAAA,EAAAnD,CAAuBoY,GA6CpC,CACA,IAAA3P,EAAA,IAAA2P,EACA3P,EAAAiE,SAAAD,KAAAC,EACA,MAAA+C,EAAAnN,EAAAnC,IAAAsI,GACA0P,EAAA,MACA1I,EAAA4I,OAAA,GACA5I,EAAApL,WAAAwJ,EAAAhD,IAAAJ,KACA+C,EAAAgB,KAAA,CAA6C/D,KAAA2F,QAAAW,UAC7CgD,QAGAtE,EAAA0I,aACA1I,EAAApL,WAAA,EACAoE,EAAA6P,kBAAAhH,EAAA9O,KAAA6C,YACAoD,EAAA8P,gBAAAjH,EAAA9O,KAAA8C,UACAgM,EAAA7I,WACAsH,EAAAtH,EAAA+P,aACA/I,EAAApL,WAAA,MA9DoC,CACpC,IAAAqG,EAAAN,EAAAjK,IAAAsK,GACA,GAAAC,EAkCAyN,EAAAzN,EAAAnI,iBAPA,GA1BA4V,EAAA,MACA,MAAAzN,EAAAN,EAAAjK,IAAAsK,GACAC,IACAA,EAAA2N,OAAA,GACA3N,EAAArG,WAAAwJ,EAAAhD,IAAAJ,KACA+C,EAAAgB,KAAA,CAAqD/D,KAAA2F,QAAAW,UACrDgD,SAIArJ,EAAA,CACA4B,WAAA8L,EAAAvY,MAAA,UACA0L,UAAA6B,EAAAvG,QACAwR,OAAA,EACA9V,YAAA4V,EACA9S,WAAAwH,GAAApC,EAAA6G,EAAA9O,KAAA6C,YACA6G,mBAAAlM,OAAAwF,OAAA,GAAwD8L,EAAA9O,KAAA6C,YACxDC,SAAAgM,EAAA9O,KAAA8C,SACAsH,UAAA,EACAvI,WAAA,EACA4F,WAAA,GACAiB,cAAA,GACAwB,SAAAU,EAAAV,SACAP,kBAAA,GAEA/B,EAAAQ,IAAA0G,EAAA7G,GAAAC,GACA0N,EAAAxO,aAAA5J,OAAA2H,KAAAyQ,EAAAxO,aAAAnG,OAAA,CACA,MAAAmG,YAA2BA,EAAA6O,OAlE3B,SAAAC,EAAA9O,EAAAa,EAAAS,EAAA,IACA,MAAAvD,EAAA3H,OAAA2H,KAAAiC,GACA,MAAA+O,EAAA,GACA,MAAAC,KAA4BnO,KAAMF,MAClC,QAAAjL,EAAA,EAAuBA,EAAAqI,EAAAlE,OAAiBnE,IAAA,CACxC,MAAA2K,EAAAL,EAAAjC,EAAArI,MACAuZ,EAAAC,GAAAF,EAAAnO,GACA,GAAAR,EAAAL,YAAA,CACA,MAAuBA,YAAAmP,GAAkCL,EAAAzO,EAAAL,YAAAa,EAAAS,GACzD2N,EAAA5O,WAAA8O,EACAJ,EAAAhR,EAAArI,IAAA2K,EAAAN,SAAAkP,QAGAF,EAAAhR,EAAArI,IAAA2K,EAAAN,SAAAkP,GAGA3N,EAAAsD,KAAAoK,GACA,OAAgBhP,YAAA+O,EAAAF,IAAAvN,GAiD8BwN,CAAAN,EAAAxO,YAAAa,GAC9CC,EAAAT,WAAAL,EACAc,EAAAQ,cAAAuN,EASA,GAHA1I,EAAAqI,EAAAU,GAAArO,IAAAC,EAAAT,aACAS,EAAArG,WAAA,EACAqG,EAAAyB,kBAAA,EACAzB,EAAAkC,UAAA,EACA,SAsBA,IAAAtH,EACAyK,IACAA,EAAAnK,MAAAC,QAAAkK,KAAA,CAAAA,GACAzK,EAAAwK,GAAAC,EAAAuB,EAAA,MACAvD,EAAAnD,IAAAH,EAAAnF,IAEA4H,GAAAkL,EAAA5T,iBACA0I,EAAAiL,GAEA,OACA7T,KAAA,CACAgN,KAAAhM,EACA0F,KAAA,CAAuByL,WAAAnF,EAAAmF,aAEvBgB,OAAA,CAAqBzS,KAAA,SAAAyD,SAAA6I,EAAA7I,SAAAgC,KAAAmL,UAAA,IA7JrBoD,CAAA,CAA0C1H,SAG1C,GAAA7J,GAAA6J,EAAA,CACA,GAAA5M,EAAA+C,IAAA/C,EAAA4M,GACA,OA2VA,UAAA7J,QAAyBA,EAAA6J,SAKzB,IAAAhM,EAJAgM,EAAAzK,QAAAY,EAAAZ,QACAyK,EAAAnI,UAAA1B,EAAA0B,UACAmI,EAAA7G,GAAAhD,EAAAgD,GACA6G,EAAAK,kBAAAlK,EAAAkK,kBAEA,IAAAsH,EAAAlL,EAAA5N,IAAAmR,EAAA7G,IACA,MAAA6G,EAAA9O,KAAAsE,MAAAwK,EAAA9O,KAAAsE,OAAAW,EAAAjF,KAAAsE,KACAwK,EAAAzK,QAA2BhE,EAAA,EAAM4I,SAAAsM,eAAAzG,EAAA9O,KAAAsE,MAEjCwK,EAAA9O,KAAA8C,WACAA,EAAAwK,GAAAwB,EAAA9O,KAAA8C,SAAAgM,EAAA7J,GACAsG,EAAAnD,IAAA0G,EAAA7G,GAAAnF,IAIA,OAFAwI,EAAAhD,OAAArD,GACAoG,EAAAjD,IAAA0G,EAAA7G,GAAA6G,GACA,CACAhN,KAAA,CACAmD,QAAAwR,EACA3H,KAAAhM,EACA0F,KAAA,IAEA5I,IAAA,CAAkB4C,KAAA,SAAAsM,OAAA7J,YAjXlByR,CAAA,CAAuCzR,UAAA6J,SAEvC,GAAA9M,EAAAiD,IAAAjD,EAAA8M,GACA,OAAAmD,GAAA,CAA0ChN,UAAA6J,cAG1C,GAAA7J,IAAA6J,EAAA,CACA,GAAA5M,EAAA+C,GACA,OA4WA,UAAAA,QAAyBA,IACzB,MAAAoQ,EAAAlT,EAAA8C,GACAqQ,EAAAjT,EAAA4C,GACAnC,EAAAyI,EAAA5N,IAAAsH,EAAAgD,IAIA,GAHAsD,EAAAjD,OAAArD,EAAAgD,IACAoD,EAAA/C,OAAArD,EAAAgD,IACAqD,EAAAhD,OAAArD,GACAA,EAAAjF,KAAA6C,WAAAxE,IAAA,CACA,MAAA6J,EAAAN,EAAAjK,IAAAsH,EAAA2J,UACAuG,EAAA1D,GAAAxM,EAAA2J,UACA,GAAA1G,EACAA,EAAAC,SAAAD,EAAAC,QAAAG,OAAArD,EAAAjF,KAAA6C,WAAAxE,UAEA,GAAA8W,KAAAlP,SAAA,CACA,MAAAgH,EAAAnN,EAAAnC,IAAAwX,EAAAlP,UACAgH,KAAA6F,YAAA6D,OAAA1R,EAAAjF,KAAA6C,WAAAxE,MAGA,GAAA4G,EAAAyJ,eAAA2G,GAAAC,EACA,OACAxT,KAAA,CAAuBmD,QAAAnC,EAAA0F,KAAA,IACvB5I,IAAAyV,GAAAC,OAAA/Q,EAAA,CAAwD/B,KAAA,SAAAyC,YAGxDnC,GACA4I,EAAAM,KAAA,KACA,IACA1J,EADAoR,EAAA5Q,GAAA,GAEA8T,EAAA,GACA,KAAAtU,EAAAoR,EAAAtF,OAAA,CACA,GAAApM,EAAAM,GAEA,IADAA,EAAAmP,GAAAnP,EAAA2F,KAAA3F,GACA2D,SAAA,CACA,MAAAgH,EAAAnN,EAAAnC,IAAA2E,EAAA2D,UACAgH,KAAAqG,WACAhR,EAAA2D,cAAA1B,MAEA,CACA,MAAAiE,EAAAZ,EAAAjK,IAAA2E,EAAA2F,IACAO,IACAA,EAAAwB,iBAAAxB,EAAAwB,gBAAA9J,UACAqI,EAAAC,GACAZ,EAAAU,OAAAhG,EAAA2F,KAIA,IAAA4O,EAAAtL,EAAA5N,IAAA2E,EAAA2F,IACA4O,GACAnD,EAAA1H,QAAA6K,GAEAxU,EAAAC,GACAsU,EAAA5K,KAAA1J,EAAA2F,KAEA,IAAA2O,EAAAzX,QAAAmD,EAAAkM,YACAxM,EAAAM,IAAAH,EAAAG,GACAsU,EAAA5K,KAAA1J,EAAA2F,IAEA3F,EAAA+B,SAAA/B,EAAA+B,QAAAiL,YACAhN,EAAA+B,QAAAiL,WAAA+C,YAAA/P,EAAA+B,UAGAkH,EAAAjD,OAAAhG,EAAA2F,IACAoD,EAAA/C,OAAAhG,EAAA2F,OAIA,OACArI,IAAA,CAAkB4C,KAAA,SAAAyC,YA/alB6R,CAAA,CAAuC7R,YAEvC,GAAAjD,EAAAiD,GACA,OA+NA,UAAAA,QAA4BA,IAC5BA,EAAAwM,GAAAxM,EAAAgD,KAAAhD,EACAoG,EAAA/C,OAAArD,EAAAgD,IACA,MAAAO,EAAAZ,EAAAjK,IAAAsH,EAAAgD,IACA,IAAAwO,EAAAlL,EAAA5N,IAAAsH,EAAAgD,IACAsD,EAAAjD,OAAArD,EAAAgD,IACAqD,EAAAhD,OAAArD,GACA,IAAA8R,EAAA,CACAjV,KAAA,CACAmD,QAAAwR,EACAjO,KAAA,KAGAA,GACAA,EAAAwB,iBAAAxB,EAAAwB,gBAAA9J,UACAqI,EAAAC,GACAZ,EAAAU,OAAArD,EAAAgD,KAGA8O,EAAA9B,OAAA,CAAoCzS,KAAA,SAAAyC,UAAAgB,SAAAhB,EAAAgB,UAEpC,OAAA8Q,EApPAC,CAAA,CAA0C/R,aAI1C,SAEA,SAAAqR,GAAArO,EAAAY,EAAApB,GACA,OACAQ,KACApF,WAAA,KACA,MAAAqF,EAAAN,EAAAjK,IAAAkL,GACA,OAAAX,GACAA,EAAAyB,kBAAA,EACAnM,OAAAwF,OAAA,GAA2CkF,EAAArF,aAE3C,IAEAC,SAAA,KACA,MAAAoF,EAAAN,EAAAjK,IAAAkL,GACA,OAAAX,EACAA,EAAApF,SAEA,IAEA2E,cAwHA,SAAAwK,IAAAhN,QAA4BA,EAAA6J,SAC5B7J,EAAAwM,GAAAxM,EAAAgD,KAAAhD,EACA,MAAAgB,SAAeA,EAAA5B,UAAAqK,gBAAAzG,MAAuChD,EACtD,IAAajF,MAAAiD,kBAAQA,IAAsB6L,EAC3C,MAAA8G,EAAA9G,EAAAjJ,cAAA5C,EACA,IAAazF,OAAAmD,EAAA,EAAAnD,CAAQoY,GACrB,SAEA,IAAArI,EAwDAzK,EAvDAiU,EAAA,GACAE,GAAA,EACAR,EAAAlL,EAAA5N,IAAAsH,EAAAgD,IAQA,GAPA6G,EAAAJ,gBACAI,EAAA7G,KACA6G,EAAAjM,WAAArF,OAAAwF,OAAA,GAA0C8L,EAAA9O,KAAA6C,YAC1CyI,EAAAhD,OAAArD,GACAZ,KAAAiL,aACAR,EAAAzK,WAEa7G,OAAAmD,EAAA,EAAAnD,CAAuBoY,GA8BpC,CACA,MAAA3I,EAAAnN,EAAAnC,IAAAsI,GACA6I,EAAA7I,WACAgH,EAAApL,WAAA,EACAoE,EAAA6P,kBAAAhH,EAAA9O,KAAA6C,YACAoD,EAAA8P,gBAAAjH,EAAA9O,KAAA8C,UACAmK,EAAA4I,QACAoB,GAAA,EACA1L,EAAAjD,OAAAL,GACAsF,EAAAtH,EAAA+P,cAEA/I,EAAApL,WAAA,MAzCoC,CACpC,MAAAqG,EAAAN,EAAAjK,IAAAsK,GACA,GAAAC,EAAA,CACAA,EAAAwB,mBAAAlM,OAAAwF,OAAA,GAAgE8L,EAAAjM,YAChEqF,EAAArF,WAAAwH,GAAApC,EAAAC,EAAAwB,oBACAxB,EAAApF,SAAAgM,EAAA9O,KAAA8C,SACAoF,EAAArG,WAAA,EACA,MAAAqV,EAnmCA,SAAA1O,EAAAvD,EAAA6J,GACA,IAAAoI,EAAA,GAYA,OAXA1O,EAAAe,cAAAf,EAAAe,eAAA,IAAmD9I,EAAA,EACnD+H,EAAAe,cAAAZ,MACAH,EAAAe,cAAAnE,QAAA+R,IACAA,EAAA/R,QAAA,CAAAkE,EAAAF,KACA,MAAA9B,EAAAgC,EAAA9L,OAAAwF,OAAA,GAAoDiC,GAAAzH,OAAAwF,OAAA,GAA4B8L,IAChFxH,IACA4P,EAAA9N,GAAA9B,OAKA4P,EAslCAE,CAAAlP,EAAAjD,EAAApC,WAAAqF,EAAAwB,oBACAxB,EAAArF,WAAArF,OAAAwF,OAAA,GAAwDkF,EAAArF,WAAAqU,IACxDjS,EAAAjF,KAAA8C,SAAA7B,OAAA,GAAA6N,EAAA9O,KAAA8C,SAAA7B,OAAA,KACAiH,EAAA2N,OAAA,GAEA3N,EAAA2N,OA73CO,SAAA5Q,EAAA6J,EAAA/O,EAAAsX,GACP,MAAA/M,EAAA,IAAA9M,OAAA2H,KAAAF,MAAAzH,OAAA2H,KAAA2J,IACA,QAAAhS,EAAA,EAAmBA,EAAAwN,EAAArJ,OAA0BnE,IAC7C,KAAAua,EAAAlY,QAAAmL,EAAAxN,KAAA,IAIA,GADuBU,OAAAoD,EAAA,EAAApD,CAAIyH,EAAAqF,EAAAxN,IAAAgS,EAAAxE,EAAAxN,KAC3Bwa,QAAA,CACAvX,IACA,MAEAsX,EAAArL,KAAA1B,EAAAxN,KAm3CAya,CAAAtS,EAAApC,WAAAiM,EAAAjM,WAAA,KACAqF,EAAA2N,OAAA,GACqB3N,EAAAsB,qBAAA,IAAAtB,EAAAsB,qBAAAgO,UAAA,IAErBtP,EAAA2N,QACAtK,EAAAjD,OAAAL,GACAgP,GAAA,EACA1J,EAAAqI,EAAAU,GAAArO,IAAAC,EAAAT,aACAS,EAAA2N,OAAA,EACA3N,EAAAkC,UAAA,IACAmD,EAAA,OAGArF,EAAArG,WAAA,EACAqG,EAAAyB,kBAAA,GA+BA,OAfA0B,EAAAjD,IAAA0G,EAAA7G,GAAA6G,GACAiI,EAAA9B,OAAA,CAAgCzS,KAAA,SAAAyD,WAAAgC,KAAAmL,UAAA,GAEhC7F,IAEAzK,EAAAwK,GADAC,EAAAnK,MAAAC,QAAAkK,KAAA,CAAAA,GACAuB,EAAA7J,GACAsG,EAAAnD,IAAAH,EAAAnF,IAEAmU,IACAF,EAAAjV,KAAA,CACAmD,QAAAwR,EACA3H,KAAAhM,EACA0F,KAAA,KAGAuO,EAyBA,SAAA3H,GAAAnH,GACA,MAAAnF,EAAAyI,EAAA5N,IAAAsK,IAAA,GACA,QAAAnL,EAAA,EAAuBA,EAAAgG,EAAA7B,OAAqBnE,IAAA,CAC5C,MAAAmF,EAAAa,EAAAhG,GACA,GAAAmF,EAAAoC,QACA,OAAApC,EAAAgG,GAEA,MAAAwP,EAAArI,GAAAnN,EAAAgG,IACA,GAAAwP,EACA,OAAAA,GAgLA,OACAC,MAhzBA,SAAAC,EAAA,IACA,IAAAtT,EAAAsT,EAAAtT,QACAA,IACgB7G,OAAA8C,EAAA,EAAA9C,CAAG,sBAAA6G,GACnBuF,QAAAC,KAAA,kFAEAxF,EAAsBhE,EAAA,EAAM4I,SAAAC,MAE5B0B,EAAApN,OAAAwF,OAAA,GAAwC4H,EAAA+M,EAAA,CAAgCtT,YACxE,MAAAuT,EA3mBA,SAAAxX,GACA,MAAAkH,EAAAlH,IACA4B,EAAAxC,EAAA8H,GACAH,EAAA,IACAG,EAGA,OADAH,EAAAnF,iBACAqF,EAAAF,GAomBA0Q,CAAAzX,EAAAyX,CAAA,GAAmD,IAEnDhI,EAAA,CACA5H,GAFA0C,KAA2B7C,MAG3B9H,KAAA4X,EACArJ,MAAA,EACAX,MAAA,EACAgB,SAAA,KACAJ,SAAA,KACAsJ,UAAA,KACAjV,WAAA,IAEAwI,EAAAjD,IAAA,MACAH,GAAA,KACA2F,MAAA,EACAW,MAAA,EACAK,SAAA,GACAvK,UACArE,KAAAL,EAAA,QACA6O,SAAA,OAEAvD,EAAAe,KAAA,CACA/G,QAAA,GACA6J,KAAA,CAAAe,GACArH,KAAA,CAAmByL,WAAAlN,EAAA1C,EAAAmP,eAEnBzB,KACAG,KACAC,KACA3G,OAAAjH,EACAwM,KACAtG,GACA7I,GAAA,IAwwBAmW,QA/0BA,WACA9M,EAAAe,KAAA,CACA/G,QAAA,CAAAoG,EAAA1N,IAAAgN,IACAmE,KAAA,GACAtG,KAAA,KAEAiC,GACYpK,EAAA,EAAM2X,qBAAAvN,GAElBsH,KACAG,KACAtG,EAAAxG,QAAA,CAAA+B,EAAAc,KACY5H,EAAA,EAAM2X,qBAAA/P,GAClBd,MAEA,MAAA6J,EAAAJ,KACAI,OACAhG,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAO,EAAA,GACAC,EAAA,GACAP,EAAA,IAAwB7K,EAAA,EACxB8K,EAAAzC,QACA2C,EAAA3C,QACA0C,EAAA,IAAiC/K,EAAA,EACjCkL,EAAA,IAAgClL,EAAA,EAChCiL,OAAAjH,GAozBAoR,WAtwBA,WACAjL,SAwwBepL,EAAA,sCC90Df,IAAA2Y,EAAAvb,EAAA,GAAAA,EAAA,GAQO,IAAAwb,EAAUD,EAAA,EAAMC,IAmER5Y,EAAA,qCC3Ef5C,EAAAU,EAAAkC,EAAA,sBAAA6Y,IAAAzb,EAAAU,EAAAkC,EAAA,sBAAA8Y,IAAA,IAAAC,EAAA3b,EAAA,GAAA4b,EAAA5b,EAAA,GAGA,MAAA2K,EAAgB7J,OAAA8a,EAAA,EAAA9a,CAAM,CAAGuC,YAAAuY,EAAA,EAAapY,QAAAoY,EAAA,IAC/B,SAAAH,IAoEP,OAnEA9Q,EAAA,EAA6BI,YAAc1H,cAAAG,eAC3C,MAAAqY,EAAA,IAA6BF,EAAA,EAC7BnY,EAAA,KACAqY,EAAA3P,UAEA,MAAA4P,EAAA,CACA7a,IAAAU,IACA,MAAAoa,EAAAF,EAAA5a,IAAAU,GACA,GAAAoa,GAAA,YAAAA,EAAAC,OAGA,OAAAD,EAAA1a,OAGAqK,IAAA,CAAA/J,EAAAN,EAAA4X,GAAA,KACA,MAAA1Q,EAAAuT,EAAA7a,IAAAU,GACA,yBAAAN,IACAA,IAAAkH,KACA,mBAAAlH,EAAA4a,MACAJ,EAAAnQ,IAAA/J,EAAA,CACAqa,OAAA,UACA3a,eAEAA,EAAA4a,KAAArR,IACA,MAAAmR,EAAAF,EAAA5a,IAAAU,GACAoa,KAAA1a,YACAwa,EAAAnQ,IAAA/J,EAAA,CACAqa,OAAA,WACA3a,MAAAuJ,IAEAqO,GAAA5V,SAMAwY,EAAAnQ,IAAA/J,EAAA,CACAqa,OAAA,WACA3a,UAEA4X,GAAA5V,IACAhC,IAEAsK,IAAAhK,GACAka,EAAAlQ,IAAAhK,GAEAiK,OAAA,CAAAjK,EAAAsX,GAAA,KACA4C,EAAAjQ,OAAAjK,GACAsX,GAAA5V,KAEA6I,MAAA,CAAA+M,GAAA,KACA4C,EAAA3P,QACA+M,GAAA5V,KAEA6Y,SAAA,CAAAva,EAAAN,EAAA4X,GAAA,KACA,IAAA8C,EAAAF,EAAA5a,IAAAU,GAKA,GAJAoa,GACAD,EAAApQ,IAAA/J,EAAAN,EAAA4X,IAEA8C,EAAAF,EAAA5a,IAAAU,KACA,YAAAoa,EAAAC,OAGA,OAAAD,EAAA1a,QAEA,OAAAya,IAIO,MAAAJ,EAAAD,IACQ7Y,EAAA,qCC3Ef5C,EAAAU,EAAAkC,EAAA,sBAAAuZ,IAAAnc,EAAAU,EAAAkC,EAAA,sBAAAwZ,IAAApc,EAAAU,EAAAkC,EAAA,sBAAAyZ,IAAA,IAAAC,EAAAtc,EAAA,GACA,SAAAuc,EAAAlb,GACA,0BAAAP,OAAAkB,UAAAwa,SAAAjc,KAAAc,IAAAqF,MAAAC,QAAAtF,GAcO,SAAA8a,EAAAM,EAAAC,GACP,OACA9B,QAAA6B,IAAAC,EACArb,MAAAqb,GAGO,SAAAN,EAAAK,EAAAC,EAAAxL,EAAA,GACP,IAAA0J,GAAA,EACA,MAAA+B,EAAAF,GAAAF,EAAAE,GACAG,EAAAF,GAAAH,EAAAG,GACA,IAAAC,IAAAC,EACA,OACAhC,SAAA,EACAvZ,MAAAqb,GAGA,MAAAG,EAAA/b,OAAA2H,KAAAgU,GACAK,EAAAhc,OAAA2H,KAAAiU,GAYA,OACA9B,QAXAA,EADAiC,EAAAtY,SAAAuY,EAAAvY,QAIAuY,EAAAC,KAAApb,GACAuP,EAAA,EACAmL,EAAAK,EAAA/a,GAAA8a,EAAA9a,GAAAuP,EAAA,GAAA0J,QAEA8B,EAAA/a,KAAA8a,EAAA9a,IAKAN,MAAAqb,GAGO,SAAAL,EAAAI,EAAAC,EAAAxL,EAAA,GACP,IAAAtG,EAeA,OAZAA,EAFA,mBAAA8R,EACAA,EAAAM,QAAkCV,EAAA,EAClCH,EAAAM,EAAAC,GA5CO,SAAAD,EAAAC,GACP,OACA9B,SAAA,EACAvZ,MAAAqb,GA4CAO,CAAAR,EAAAC,GAGAH,EAAAG,GACAN,EAAAK,EAAAC,EAAAxL,GAGAiL,EAAAM,EAAAC,yBC/DAvc,EAAAD,QAAA,CAAkBgd,QAAA,oCAAAC,KAAA,qCAAAC,OAAA,yECDlBpd,EAAAU,EAAAkC,EAAA,sBAAAya,IAAArd,EAAAU,EAAAkC,EAAA,sBAAA0a,IAAAtd,EAAAU,EAAAkC,EAAA,sBAAA2a,IAAAvd,EAAA,OAAAwd,EAAAxd,EAAA,GAKO,IAAAqd,EACAI,EACAC,EACAC,EACAC,EACAN,EACAO,EACAN,EACAO,EA6KPT,EAAA3W,MAAA2W,KACAI,EAAA/W,MAAA+W,GACAC,EAAa5c,OAAA0c,EAAA,EAAA1c,CAAU4F,MAAA1E,UAAA0b,YACvBC,EAAO7c,OAAA0c,EAAA,EAAA1c,CAAU4F,MAAA1E,UAAA2b,MACjBC,EAAO9c,OAAA0c,EAAA,EAAA1c,CAAU4F,MAAA1E,UAAA4b,MACjBL,EAAOzc,OAAA0c,EAAA,EAAA1c,CAAU4F,MAAA1E,UAAAub,MACjBO,EAAUhd,OAAA0c,EAAA,EAAA1c,CAAU4F,MAAA1E,UAAA8b,SACpBR,EAAYxc,OAAA0c,EAAA,EAAA1c,CAAU4F,MAAA1E,UAAAsb,WACtBO,EAAW/c,OAAA0c,EAAA,EAAA1c,CAAU4F,MAAA1E,UAAA6b,+BCjMrB1d,EAAAD,QAAA,CAAkBgd,QAAA,oCAAAC,KAAA,qCAAAY,QAAA,wCAAAX,OAAA,uCAAAY,SAAA,2ECDlB,IAAArC,EAAA3b,EAAA,GAAAie,EAAAje,EAAA,GAAAke,EAAAle,EAAA,GAyEe4C,EAAA,EAtER,cAA8Bqb,EAAA,EACrChW,cACAkW,QACAjW,KAAAkW,UAAA,IAA6BF,EAAA,EAC7BhW,KAAAmW,wBAAA,IAA2C1C,EAAA,EAC3CzT,KAAAoW,0BAAA,IAA6C3C,EAAA,EAC7CzT,KAAAqW,IAAArW,KAAAkW,WAQAlW,KAAAqW,IAAA,CAAkB/a,QAPlB,KACA0E,KAAAsW,eACAtW,KAAAmW,wBAAAzS,OAAA1D,KAAAsW,cACAtW,KAAAoW,0BAAA1S,OAAA1D,KAAAsW,cACAtW,KAAAsW,kBAAA3W,MAKA0F,SAAAiR,GACAtW,KAAAsW,eACAtW,KAAAmW,wBAAAzS,OAAA1D,KAAAsW,cACAtW,KAAAoW,0BAAA1S,OAAA1D,KAAAsW,eAEAtW,KAAAsW,eAEAjR,WACA,OAAArF,KAAAsW,aAEAvW,OAAAwI,EAAA8H,GACArQ,KAAAkW,UAAAzN,OAAAF,EAAA8H,GAEAtQ,eAAAwI,EAAAgO,GACAvW,KAAAkW,UAAAM,eAAAjO,EAAAgO,GAEAxW,IAAAwI,GACA,OAAAvI,KAAAkW,UAAAzS,IAAA8E,IAAA5K,QAAAqC,KAAAsW,cAAAtW,KAAAsW,aAAA7S,IAAA8E,IAEAxI,YAAAwI,GACA,OAAAvI,KAAAkW,UAAAO,YAAAlO,IAAA5K,QAAAqC,KAAAsW,cAAAtW,KAAAsW,aAAAG,YAAAlO,IAEAxI,IAAAwI,EAAAmO,GAAA,GACA,OAAA1W,KAAA2W,KAAApO,EAAAmO,EAAA,MAAA1W,KAAAmW,yBAEApW,YAAAwI,EAAAmO,GAAA,GACA,OAAA1W,KAAA2W,KAAApO,EAAAmO,EAAA,cAAA1W,KAAAoW,2BAEArW,KAAAwI,EAAAmO,EAAAE,EAAAC,GACA,MAAAC,EAAAJ,EAAA,CAAA1W,KAAAsW,aAAAtW,KAAAkW,WAAA,CAAAlW,KAAAkW,UAAAlW,KAAAsW,cACA,QAAApe,EAAA,EAAuBA,EAAA4e,EAAAza,OAAuBnE,IAAA,CAC9C,MAAAoN,EAAAwR,EAAA5e,GACA,IAAAoN,EACA,SAEA,MAAApI,EAAAoI,EAAAsR,GAAArO,GACAwO,EAAAF,EAAA9d,IAAAuM,IAAA,GACA,GAAApI,EACA,OAAAA,EAEA,QAAA6Z,EAAAxc,QAAAgO,GAAA,CACA,MAAAyO,EAAA1R,EAAAnG,GAAAoJ,EAAAmE,IACA,WAAAA,EAAAuK,QACAjX,KAAA4W,GAAArO,EAAAmO,KAAAhK,EAAAxP,MACA8C,KAAAkX,KAAA,CAAmCtZ,KAAA,iBAGnCoC,KAAAqW,IAAAW,GACAH,EAAArT,IAAA8B,EAAA,IAAAyR,EAAAxO,KAGA,+CCtEAzQ,EAAAU,EAAAkC,EAAA,sBAAAyc,IAAA,IAAAC,EAAAtf,EAAA,GAAAuf,EAAAvf,EAAA,IAAAwf,EAAAxf,EAAA,GAOA,MAAM2K,EAAU7J,OAAAwe,EAAA,EAAAxe,CAAO,CAAE2e,UAAAF,EAAA,IAGzB,SAASG,EAAmBre,GAC3B,SAAUA,EAAMse,OAAO,GAAGzH,gBAAgB7W,EAAMkJ,MAAM,KAOvD,SAASqV,EAAmBP,GAC3B,OAAOA,GAASA,EAAMpd,eAAe,WAK/B,MAAMod,EAAQ1U,EAAQ,UAAWI,YAAY0U,UAAEA,GAAWtZ,WAAEA,IAelE,OAAArF,OAAAwF,OAAA,CACCuZ,QAAS,CACRC,EACAC,EACAC,KAEA,MAAMX,EApBR,WACC,MAAMA,MAAEA,GAAUlZ,IAClB,GAAIkZ,EACH,OAAOA,EAGR,MAAMY,EAAeR,EAAUxe,MAC/B,OAAIH,OAAA0e,EAAA,EAAA1e,CAAkCmf,GAC9B,CAAEZ,MAAOY,EAAaZ,MAAOa,QAASD,EAAaC,SAChDD,EACHA,EAAaZ,WADd,EAWQc,GACRC,EAAUN,EAtCM,SAuChBO,EAAaN,EAvCG,SAwChBO,EAAaxf,OAAO2H,KAAKqX,GAAShX,OACvC,CAACwX,EAAY3e,IAzCQ,UA0ChBA,EACI2e,GAEJN,IAAWM,KAAcN,IAASN,EAAmB/d,QACxD2e,KAAcN,IAASN,EAAmB/d,MAAU,KAEhDoe,EAAIpe,KACR2e,EAAW3e,GAAO,KAEZ2e,GAER,CAAEpD,QAAamD,IAEVE,EAAed,EAAU7Y,QAAQ0Z,GACjCE,EAAef,EAAU7Y,QAAQmZ,GACvC,IAAIU,EAAYhB,EAAU7Y,QAAQkZ,GAClC,GAAIE,EAAQ,CACX,MAAMU,EAAc5f,OAAO2H,KAAI3H,OAAAwF,OAAA,GAAMia,EAAiBC,IAAgB1X,OACrE,CAAC6X,EAAWhf,KACX,GAA4B,IAAxBA,EAAIc,QAAQud,IAAiBre,IAAQqe,EAAQ,CAChD,MAAMY,EAxDb,SAA4Bvf,GAC3B,SAAUA,EAAMse,OAAO,GAAGnY,gBAAgBnG,EAAMkJ,MAAM,KAuD/BsW,CAAmBlf,EAAIkW,QAAQmI,EAAQ,MAEtDQ,EAAa7e,IACd4e,EAAa5e,IACb4e,EAAa5e,GAAKmf,SAElBH,EAAUC,MAAeH,EAAUG,MAAaL,EAC/C5e,GACCmf,UAECN,EAAa7e,KAChBgf,EAAUC,GAAYJ,EAAa7e,IAGrC,OAAOgf,GAER,IAID,OAFAF,EAAS3f,OAAAwF,OAAA,GAAQma,EAAcC,GAE3Bd,EAAmBP,GACf,CACNA,MAAO,CACNA,MAAKve,OAAAwF,OAAA,GACD+Y,EAAMA,MAAMA,MAAK,CACpBpX,CAACmY,GAAUK,IAEZM,SAAU1B,EAAMA,MAAM0B,UAEvBb,QAASb,EAAMa,SAIjBpf,OAAAwF,OAAA,GACI+Y,EAAK,CACRpX,CAACmY,GAAUK,IAIb,MAAMO,EAAmBlgB,OAAO2H,KAAKgY,GAAW3X,OAC/C,CAACuW,EAAO1d,KACP,GAvGoB,UAuGhBA,EACH,OAAO0d,EAER,MAAM4B,EAAuBT,EAAa7e,IAAQ6e,EAAa7e,GAAKmf,OAMpE,OALIN,EAAa7e,GAChB0d,EAAM1d,GAAOsf,EACHV,EAAa5e,IAAQ4e,EAAa5e,GAAKmf,SACjDzB,EAAM1d,MAAU0d,EAAM1d,MAAQ4e,EAAa5e,GAAKmf,UAE1CzB,GAERve,OAAAwF,OAAA,GAAKma,IAGN,OAAIb,EAAmBP,GACf,CACNA,MAAO,CACNA,MAAKve,OAAAwF,OAAA,GACD+Y,EAAMA,MAAMA,MAAK,CACpBpX,CAACmY,GAAUY,IAEZD,SAAU1B,EAAMA,MAAM0B,UAEvBb,QAASb,EAAMa,SAIjBpf,OAAAwF,OAAA,GACI+Y,EAAK,CACRpX,CAACmY,GAAUY,MAGVvB,KAIU7c,EAAA,qCCnJf5C,EAAAU,EAAAkC,EAAA,sBAAAyc,IAAA,IAAA6B,EAAAlhB,EAAA,GAAAmhB,EAAAnhB,EAAA,IAAAohB,EAAAphB,EAAA,IAAA8D,EAAA9D,EAAA,IAAAqhB,EAAArhB,EAAA,IAAAshB,EAAAthB,EAAA,GAAAoE,EAA0B,SAAAjC,EAAAkC,GAC1B,IAAA/C,EAAA,GACA,QAAAY,KAAAC,EAAArB,OAAAkB,UAAAC,eAAA1B,KAAA4B,EAAAD,IAAAmC,EAAA5B,QAAAP,GAAA,IACAZ,EAAAY,GAAAC,EAAAD,IACA,SAAAC,GAAA,mBAAArB,OAAAwD,sBACA,KAAAlE,EAAA,MAAA8B,EAAApB,OAAAwD,sBAAAnC,GAA4D/B,EAAA8B,EAAAqC,OAAcnE,IAAAiE,EAAA5B,QAAAP,EAAA9B,IAAA,IAC1EkB,EAAAY,EAAA9B,IAAA+B,EAAAD,EAAA9B,KACA,OAAAkB,GAQO,MACAigB,EAAA,mBASP,MACOlC,EADSve,OAAAogB,EAAA,EAAApgB,CAAM,CAAGuC,YAAA6d,EAAA,EAAaxF,OAAAyF,EAAA,EAAQ5d,aAAA2d,EAAA,EAAczC,SAAA2C,EAAA,EAAU3d,YAAAyd,EAAA,IAAa/a,YAC5EwE,CAAA,EAAwBI,YAAc1H,cAAAqY,SAAAnY,eAAAkb,WAAAhb,eAA2D0C,iBACxG,IAAAqb,EAAA,IAAwB1d,EAAA,EA4BxB,SAAAqc,IACA,MAAAd,MAAeA,GAAQlZ,IACvB,GAAAkZ,EACA,OAAAA,EAEA,MAAAoC,EAAAhD,EAAAxd,IAAAsgB,GACA,GAAAE,EAAA,CACA,MAAAxB,EAAAwB,EAAAxgB,MACA,GAAgBH,OAAAwgB,EAAA,EAAAxgB,CAAiCmf,GACjD,OAAwBZ,MAAAY,EAAAZ,MAAAa,QAAAD,EAAAC,SAExB,GAAAD,EACA,OAAAA,EAAAZ,OAKA,GA5CA9b,EAAA,QAAA4C,EAAA,CAAAoC,EAAA6J,KACA,MAAAwI,QAAeA,GAAa9Z,OAAAugB,EAAA,EAAAvgB,CAAIyH,EAAA8W,MAAAjN,EAAAiN,MAAA,GAChCzE,IACAc,EAAAxP,QACA7I,OAGAE,EAAA,WAAAgF,EAAA6J,KACA,IAAAxH,GAAA,EACA,GAAArC,EAAA3B,UAAAwL,EAAAxL,UAAA2B,EAAA3B,SAAAwL,EAAAxL,QACAgE,GAAA,OAEA,GAAArC,EAAA3B,SAAAwL,EAAAxL,QAAA,CACA,MAAA6B,EAAA,IAAA+Y,EAAA1G,UACA,QAAA1a,EAAA,EAA2BA,EAAAqI,EAAAlE,OAAiBnE,IAAA,CAC5C,IAAAuB,EAAA8G,EAAArI,GAEA,GADAwK,EAAyB9J,OAAAugB,EAAA,EAAAvgB,CAAIyH,EAAA3B,QAAAjF,GAAAyQ,EAAAxL,QAAAjF,GAAA,GAAAiZ,QAE7B,OAIAhQ,IACA8Q,EAAAxP,QACA7I,QAmBAob,EAAAxd,IAAAsgB,GACA,CACA,MAAA/T,EAAA/J,IACA+J,GAzDA,SAAA6R,EAAAqC,GACA,MAAAD,EAAA,IAA8BH,EAAA,EAAajC,GAC3CqC,EAAAhD,eAAA6C,EAAAle,IACAoe,EAAAE,eAAAte,GACA,IAAAoe,IAsDAG,MAAA/Z,EAAA2F,EAAAD,MAkBA,OAfAkR,EAAAoD,UAAAN,EAAA,KACA7F,EAAAxP,QACA7I,MAaA,CACA4E,QAAA8X,GACA,MAAA+B,EAAApG,EAAAza,IAAA8e,GACA,GAAA+B,EACA,OAAAA,EAEA,MAAA/a,EApFO,QAoFPpF,EAAAoe,EAAAhZ,GAAAH,EAAAxC,EAAA2b,EAAA,CAAAhZ,EAAA,KACAya,EAAA/U,IAAA9K,GACA,IAAA0d,EAAAzY,GACiBA,QAAAmb,GAA0B5b,IAC3C6b,EAAA7B,IASA,GARA6B,GAAgClhB,OAAAwgB,EAAA,EAAAxgB,CAAkBkhB,KAClDA,EAA+BlhB,OAAAwgB,EAAA,EAAAxgB,CAAmBkhB,EAAA3C,OAClD2C,EAAA3C,YACA2C,EAAA3C,OAEA2C,KAAArgB,KACA0d,EAAAve,OAAAwF,OAAA,GAAwC+Y,EAAA2C,EAAArgB,KAExCogB,KAAApgB,GAAA,CACA,MAAAsgB,EAAAnhB,OAAA2H,KAAAsZ,EAAApgB,IACA,QAAAvB,EAAA,EAA+BA,EAAA6hB,EAAA1d,OAAsBnE,IAAA,CACrD,MAAAwgB,EAAAqB,EAAA7hB,GACAif,EAAAuB,KACAvB,EAAAuB,MAA6CvB,EAAAuB,MAAmBmB,EAAApgB,GAAAif,GAAAsB,KAAA,SAKhE,OADAxG,EAAAhQ,IAAAqU,EAAAV,GAAA,GACAA,GAEApX,UACA,MAAAoX,EAAAc,IACA,GAAAd,GAAyBve,OAAAwgB,EAAA,EAAAxgB,CAAkBue,GAC3C,OAAAA,EAAAa,QAAA7e,MAAA8b,MAGAzR,IAhDA,SAAA2T,EAAAa,GACA,MAAA8B,EAAAvD,EAAAxd,IAAAsgB,GACAS,IACgBlhB,OAAAwgB,EAAA,EAAAxgB,CAAmBue,GACnC2C,EAAAtW,IAAA2T,EAAAa,GAGA8B,EAAAtW,IAAA2T,KA0CApX,MACA,MAAA+Z,EAAAvD,EAAAxd,IAAAsgB,GACA,GAAAS,EACA,OAAAA,EAAA/gB,UAKe2B,EAAA,qCC3If5C,EAAAU,EAAAkC,EAAA,sBAAAuf,IAAA,IAAAC,EAAApiB,EAAA,GACO,MAAAmiB,UAAuBC,EAAA,EAC9Bna,YAAA0R,GACAwE,QACAjW,KAAAma,SAAA1I,EAEA1R,eAAA5E,GACA6E,KAAAoa,aAAAjf,EAEA4E,MACA,OAAAC,KAAAma,SAEApa,IAAA0R,GACAzR,KAAAma,SAAA1I,EACAzR,KAAAoa,cACApa,KAAAoa,gBAIe1f,EAAA,qCCnBf,IAAAse,EAAAlhB,EAAA,GACA,MACOye,EADiB3d,OAAAogB,EAAA,EAAApgB,CAAM,CAAG2C,YAAAyd,EAAA,EAAa7d,YAAA6d,EAAA,EAAa1d,QAAA0d,EAAA,GACpDqB,CAAA,EAAmCxX,YAActH,cAAAJ,cAAAG,eACxD,MAAAgf,EAAA,GACAhf,EAAA,KACA,IAAA0b,EACA,KAAAA,EAAAsD,EAAA9Q,OACAwN,EAAA1b,YAGA,MAAAgK,EAAA/J,IACA,OACAwE,UAAAwI,EAAAhG,EAAApH,GACA,GAAAmK,EAAA,CACA,MAAApI,EAAAoI,EAAAiV,YAAAhS,GACA,GAAArL,EAAA,CACA,MAAA8Z,EAAA9Z,EAAA/B,YAAAgE,GAAA,kBACAoD,MAGA,OADA+X,EAAAlT,KAAA4P,GACA,KACA,MAAAnI,EAAAyL,EAAA/f,QAAAyc,IACA,IAAAnI,IACAyL,EAAApK,OAAArB,EAAA,GACAmI,EAAA1b,eAMAyE,IAAAwI,GACA,GAAAjD,EAAA,CACA,MAAApI,EAAAoI,EAAAiV,YAAAhS,GACA,GAAArL,EACA,OAAAA,EAAAqZ,WAGA,gBAIe7b,EAAA,oCCzCf5C,EAAAU,EAAAkC,EAAA,sBAAA8f,IAAA,IAAAnH,EAAAvb,EAAA,GAAAA,EAAA,IAAAA,EAAA,GASO,IAAA0iB,EAAUnH,EAAA,EAAMmH,IAwFR9f,EAAA,qCCjGf5C,EAAAU,EAAAkC,EAAA,sBAAA+f,IAAA,IAAAC,EAAA5iB,EAAA,GAIA,SAAA6iB,IACA,OAAWD,EAAA,EAAOE,SAAA,GAKlB,SAAAC,IACA,UAAAC,MAAA,iCAEO,MAAAL,EAIP1a,cACAC,KAAAsa,QAAA,GASAva,IAAAiX,GACA,MAAesD,QAAAS,GAAoB/a,KAEnC,OADA+a,EAAA3T,KAAA4P,GACA,CACAjX,UACAgb,EAAA7K,OAAA6K,EAAAxgB,QAAAyc,IACAA,EAAA1b,YASAyE,UACA,WAAmB2a,EAAA,EAAOE,IAC1B5a,KAAAsa,QAAA9Z,QAAAwW,IACAA,KAAA1b,SAAA0b,EAAA1b,YAEA0E,KAAA1E,QAAAqf,EACA3a,KAAAqW,IAAAwE,EACAD,GAAA,2BChDA3iB,EAAAD,QAAA,CAAkBgd,QAAA,qBAAAgG,eAAA,gCAAAC,UAAA,2BAAAC,OAAA,2CCDlB,IAAAC,EAGAA,EAAA,WACA,OAAAnb,KADA,GAIA,IAEAmb,KAAAC,SAAA,cAAAA,KAAA,EAAAC,MAAA,QACC,MAAAlf,GAED,iBAAA/B,SAAA+gB,EAAA/gB,QAOAnC,EAAAD,QAAAmjB,yECnBArjB,EAAAU,EAAAkC,EAAA,sBAAA0D,IAAAtG,EAAA,GACO,IAAAsG,EAQAkd,EAMAC,EAKAnf,EAMAof,EAKAjb,EAEAkb,EACAC,EACA9I,EAoDPxU,EAAAxF,OAAAwF,OACAkd,EAAA1iB,OAAA0iB,yBACAC,EAAA3iB,OAAA2iB,oBACAnf,EAAAxD,OAAAwD,sBACAof,EAAA5iB,OAAA4iB,GACAjb,EAAA3H,OAAA2H,KACAkb,EAAA7iB,OAAA6iB,0BACAC,EAAA9iB,OAAA8iB,QACA9I,EAAAha,OAAAga,4BC9FA,IAAA+I,EAAoB7jB,EAAQ,KAE5B8jB,EAA4B9jB,EAAQ,IAA4C+jB,QAEhFC,EAAAH,EAAAE,QACAC,GAAAF,EAAAE,qCCNAhkB,EAAAkB,EAAA0B,GAAA5C,EAAAU,EAAAkC,EAAA,sCAAAqhB,IAAA,IAAA3E,EAAAtf,EAAA,GAAAkkB,EAAAlkB,EAAA,IAAAmkB,EAAAnkB,EAAA,IAAAokB,EAAApkB,EAAA,KAAAqkB,EAAArkB,EAAA,IAAAskB,EAAAtkB,EAAA,KA6BA,MAAM2K,EAAU7J,OAAAwe,EAAA,EAAAxe,CAAO,CAAEyjB,WAAAL,EAAA,EAAY7E,MAAA8E,EAAA,IACnChe,aACAC,WAEW6d,MAAoBtZ,EAAQ,UAASxE,WACjDA,EAAUC,SACVA,EACA2E,YAAYwZ,WAAEA,EAAUlF,MAAEA,KAE1B,MAAMmF,oBACLA,EAAsB,KAAIC,oBAC1BA,EAAsB,IAAGC,KACzBA,EAAO,WACJve,MACG4X,QAAEA,EAAOX,OAAEA,EAAMY,SAAEA,IAAc5X,IAClCQ,EAAUyY,EAAMzY,QAAQ0d,IACtBC,WAAYI,GAAsBJ,EAAWtjB,IAAI,OAAQ,CAChE2jB,MAAOJ,EACPK,OAAQJ,EACRK,MAAO,KACF,CAAEP,WAAY,SACdQ,EACiB,UAAtBJ,GAAwD,WAAtBA,GAA2C,aAATD,EAC/DM,EACiB,UAAtBL,GAAwD,WAAtBA,GAA2C,YAATD,EAErE,OACC5jB,OAAAwe,EAAA,EADM,CACN,OAAK3d,IAAI,OAAOiF,QAAS,CAACyY,EAAMa,UAAWkE,EAAA,KAAexd,EAAQuW,OACjErc,OAAAwe,EAAA,EAAAxe,CAAA,OACCa,IAAI,UACJiF,QAAS,CAACA,EAAQmX,QAASgH,GAAyBV,EAAA,iBAEnDtG,GAEFjd,OAAAwe,EAAA,EAAAxe,CAAA,OAAKa,IAAI,SAASiF,QAAS,CAACwd,EAAA,OAAiBxd,EAAQwW,SACnDA,GAEFtc,OAAAwe,EAAA,EAAAxe,CAAA,OACCa,IAAI,WACJiF,QAAS,CAACA,EAAQoX,SAAUgH,GAA0BX,EAAA,iBAErDrG,uOArCyB,MA2Cfpb,EAAA,2CC5Ef5C,EAAAkB,EAAA0B,GAAA5C,EAAAU,EAAAkC,EAAA,2CAAAqiB,IAAAjlB,EAAAU,EAAAkC,EAAA,uCAAAsiB,IAAAllB,EAAAU,EAAAkC,EAAA,2BAAAlB,IAAA1B,EAAAU,EAAAkC,EAAA,6BAAAuiB,IAAA,IAAA7I,EAAAtc,EAAA,GAAA4b,EAAA5b,EAAA,GAAAolB,EAAAplB,EAAA,IAAAqlB,EAAArlB,EAAA,GAAAslB,EAAAtlB,EAAA,GAKA,MAAAulB,EAAA,UACO,IAAAN,EAYP,SAAAjiB,EAAAM,EAAA6C,EAAAC,GACA,MAAAof,EAAyB1kB,OAAA8a,EAAA,EAAA9a,CAAKwC,EAAA6C,EAAAC,GAC9B,SAAAR,KAAAiI,GACA,MAAAlG,QAAeA,GAAUrE,EASzB,OARAuK,EAAAtJ,QAAAoD,GACA8d,WAAA,KACA9d,EAAA+d,cAAA,IAAAC,YAAA,UACAC,SAAA,EACAC,OAAAhY,OAIA2X,EAGA,OADA1kB,OAAA2H,KAAA+c,GAAA9c,QAAA/G,GAAAiE,EAAAjE,GAAA6jB,EAAA7jB,IACAiE,EAEA,SAAA1C,EAAA4iB,EAAA1f,GACA,MAAA2f,EAA2BjlB,OAAA8a,EAAA,EAAA9a,CAAOglB,EAAA1f,GAClC,SAAAR,KAAAiI,GACA,MAAAlG,QAAeA,GAAUoe,EASzB,OARAlY,EAAAtJ,QAAAoD,GACA8d,WAAA,KACA9d,EAAA+d,cAAA,IAAAC,YAAA,UACAC,SAAA,EACAC,OAAAhY,OAIAkY,EAGA,OADAjlB,OAAA2H,KAAAsd,GAAArd,QAAA/G,GAAAiE,EAAAjE,GAAAokB,EAAApkB,IACAiE,GA3CA,SAAAqf,GACAA,EAAA,YACAA,EAAA,YACAA,EAAA,YAHA,CAICA,MAAA,KAyCD,MAAAta,EAAgB7J,OAAA8a,EAAA,EAAA9a,CAAU,CAAGyC,aAAAqY,EAAA,EAAcvY,YAAAuY,EAAA,IAAazV,aACjD,SAAA+e,EAAAvd,GACP,MAAA/B,EAAA+E,EAAA,UAAAxE,WAAyDA,EAAA4E,YAAA1H,YAA0BA,EAAAE,kBACnFA,EAAA,GAAAF,GACA,MAAA+D,EAAAtG,OAAA2H,KAAAtC,KAAA2C,OAAA,CAAA1B,EAAAzF,KACA,MAAAN,EAAA8E,IAAAxE,GAKA,OAJA,IAAAA,EAAAc,QAAA,YAAA8iB,EAAA9iB,QAAAd,KACAA,OAA2BA,KAE3ByF,EAAAzF,GAAAN,EACA+F,GACS,IACT,OAAAlE,EAAA,CAAoBI,KAAAqE,EAAAP,QAAAE,SAAA,UAGpB,OADA1B,EAAA+B,UACA/B,EAUO,SAAAlE,EAAAskB,EAAAC,GACP,MAAAxe,WAAWA,EAAA,GAAAtB,aAAA,GAAA+f,kBAAA,SAA+D5J,EAAA,IAAY0J,EACtFG,EAAA,GASA,OARA1e,EAAAiB,QAAAgE,IACA,MAAA0Z,EAAA1Z,EAAAlF,cACA2e,EAAAC,GAAA1Z,IAEAvG,EAAAuC,QAAAgE,IACA,MAAA0Z,EAAA1Z,EAAAlF,cACA2e,EAAAC,GAAA1Z,IAEA,cAAA2Z,YACApe,cACAkW,SAAAmI,WACApe,KAAAqe,YAAA,GACAre,KAAAse,UAAA,GACAte,KAAAue,iBAAA,GACAve,KAAAwe,eAAA,GACAxe,KAAAye,cAAA,EACAze,KAAA0e,WAAAZ,EAAAa,UAEA5e,oBACAC,KAAAye,cAGAze,KAAA4e,iBAEA7e,iBACA,eAAAsE,SAAAwa,WACA,SAEA,IAAAC,EAAA9e,KACA,KAAA8e,GAAA,CACA,GAAAA,EAAAxU,YACA,SAEAwU,IAAApU,WAEA,SAEA3K,iBACAC,KAAAye,cAAA,EACAze,KAAA+e,iBACA/e,KAAAgf,iBAGAzB,WAAA,KACAvd,KAAA4e,kBACiB,KAGjB7e,iBACA,MAAAkf,EAAA,IACAhhB,WAAmBA,EAAA,GAAAuB,SAAA,IAA+Bse,EAClD9d,KAAAqe,YAAAzlB,OAAAwF,OAAA,GAA+C4B,KAAAkf,0BAAAjhB,GAAA+B,KAAAmf,wBAAA5f,IAC/C,IAAAA,KAAAtB,GAAAuC,QAAAgE,IACA,MAAA4a,GAAA,IAAA/B,EAAA9iB,QAAAiK,GACArL,EAAA6G,KAAAwe,eAAAha,KAAA4a,EAAApf,KAAAwE,QAAA7E,EACA,IAAA0f,EAAA7a,EAAAmL,QAAA,YACAyP,IACAC,OAAgD7a,UAEhD7E,IAAAxG,IACA6G,KAAAqe,YAAA7Z,GAAArL,GAEAkmB,IAAA7a,IACAya,EAAAI,GAAA,CACAtmB,IAAA,IAAAiH,KAAAsf,aAAA9a,GACAhB,IAAArK,GAAA6G,KAAAuf,aAAA/a,EAAArL,KAGAimB,IACAH,EAAAza,GAAA,CACAzL,IAAA,IAAAiH,KAAAsf,aAAA9a,GACAhB,IAAArK,GAAA6G,KAAAuf,aAAA/a,EAAArL,OAIAqG,EAAAgB,QAAAgE,IACA,MAAA8C,EAAA9C,EAAAmL,QAAA,UAAArQ,cACA+f,EAAA7a,EAAAmL,QAAA,cACAsP,EAAAI,GAAA,CACAtmB,IAAA,IAAAiH,KAAAwf,kBAAAhb,GACAhB,IAAArK,GAAA6G,KAAAyf,kBAAAjb,EAAArL,IAEA6G,KAAAue,iBAAA/Z,QAAA7E,EACAK,KAAAqe,YAAA7Z,GAAA,KAAAmB,KACA,MAAAuC,EAAAlI,KAAAwf,kBAAAhb,GACA,mBAAA0D,GACAA,KAAAvC,GAEA3F,KAAAwd,cAAA,IAAAC,YAAAnW,EAAA,CACAoW,SAAA,EACAC,OAAAhY,SAIA/M,OAAA8mB,iBAAA1f,KAAAif,GACA,MAAA/gB,EAA6BtF,OAAAskB,EAAA,EAAAtkB,CAAIoH,KAAA4O,YAAA+Q,OAAAC,IAAyChnB,OAAA8a,EAAA,EAAA9a,CAAUgnB,MAAAhgB,KAAA+P,QAAA,kBACpF3P,KAAA0e,aACAxgB,EAAA2W,KAAAxX,IAlKA,SAAAH,GACA,OAJA,SAAAA,GACA,OAAAA,GAAA,IAAAA,EAAAC,SAGA0iB,CAAA3iB,MAAAa,QAAAxD,QAAA,SAiKAulB,CAAAziB,IACA2C,KAAA0e,WAAA3B,EAAAgD,KAGA/f,KAAA0e,WAAA3B,EAAAiD,MAGYpnB,OAAAskB,EAAA,EAAAtkB,CAAIsF,GAAAsC,QAAAof,IAChB5f,KAAA0e,aAAA3B,EAAAgD,MACAH,EAAAhY,iBAAA,qBAAA5H,KAAAigB,WACAL,EAAAhY,iBAAA,wBAAA5H,KAAAigB,WACAjgB,KAAAse,UAAAlX,KAAA4V,EAAA4C,KAGA5f,KAAAse,UAAAlX,KAAApM,EAAA,CAA6CI,KAAAwkB,EAAAxgB,SAAA,WAG7CY,KAAA4H,iBAAA,oBAAAzL,GAAA6D,KAAAkgB,gBAAA/jB,IACA,MAAAgkB,EAAAngB,KAAAqe,YACA+B,EAAA,IAAApgB,KAAA7B,eACAkiB,EAAA5d,EAAA,IAAA3H,EAAAijB,EAAAoC,EAAAC,MACA9a,EAAA0Y,IACAsC,EAlIA,SAAAnJ,EAAAqC,GACA,MAAAD,EAAA,IAA8B6D,EAAA,EAAajG,GAK3C,OAJAqC,EAAAhD,eAAA,mBAAArb,IACAoe,EAAAE,eAAAte,GACA,IAAAoe,IAEAA,EA4HAG,CAAA1Z,KAAAugB,cAAA,CAA6EpJ,MAAAnX,KAAAwgB,YAAAxI,QAAAhY,KAAAugB,eAAuDvgB,KAAAwgB,YAAAlb,GACxH6X,EAAA,EAAMvV,iBAAA,sBAClB,MAAAoQ,EAAAhY,KAAAugB,cACA,cAAAvI,EACAsI,EAAA9c,IAAAxD,KAAAwgB,YAAAxI,GAGAsI,EAAA9c,IAAAxD,KAAAwgB,eAGA,MAAAxnB,EAAsBJ,OAAA8a,EAAA,EAAA9a,CAAQ,IAAAkC,EAAAulB,EAAA,KAC9BrgB,KAAAygB,UAAAznB,EACAA,EAAA8Z,MAAA,CAAqBrT,QAAAO,KAAAkG,OAAA,EAAAZ,aACrB,MAAA2P,EAAAjV,KAAA9B,SAAA,GACA,GAAA+W,EAAA,CACA,MAAAyL,QAAuBA,EAAA,SAAuBvD,EAAA,EAAMwD,iBAAA1L,GACpDjV,KAAA8L,MAAA4U,UAEA1gB,KAAAwd,cAAA,IAAAC,YAAA,qBACAC,SAAA,EACAC,OAAA3d,QAGAD,YACA,GAAgBod,EAAA,GAAUA,EAAA,EAAMyD,QAAWzD,EAAA,EAAMyD,OAAAzJ,MACjD,OAAuBgG,EAAA,EAAMyD,OAAAC,OAAe1D,EAAA,EAAMyD,OAAAzJ,OAGlDpX,cACA,GAAgBod,EAAA,GAAUA,EAAA,EAAMyD,QAAWzD,EAAA,EAAMyD,OAAA5I,QACjD,OAAuBmF,EAAA,EAAMyD,OAAA5I,QAG7BjY,gBAAA5D,GACA,MAAAf,EAAAe,EAAAwhB,OACA,GAAAviB,EAAAsP,aAAA1K,KAAA,CACAA,KAAAse,UAAAzJ,KAAAxX,KAAAoC,UAAArE,KAEAA,EAAAwM,iBAAA,qBAAA5H,KAAAigB,WACAjgB,KAAAse,UAAAlX,KAAA4V,EAAA5hB,IACA4E,KAAAigB,YAIAlgB,UACAC,KAAAygB,YACAzgB,KAAAygB,UAAA1P,aACA/Q,KAAAwd,cAAA,IAAAC,YAAA,kBACAC,SAAA,EACAC,OAAA3d,SAIAD,iBACA,OAAAnH,OAAAwF,OAAA,GAAmC4B,KAAAqe,YAAAre,KAAAue,kBAEnCxe,eACA,GAAAC,KAAAse,UAAAzJ,KAAAxX,KAAAoC,QAAAkB,cAAAtD,EAAAoC,QAAAkB,aAAA,UACA,MAAAmgB,EAAA9gB,KAAAse,UAAA1d,OAAA,CAAAkgB,EAAAzjB,KACA,MAAAoC,QAA2BA,GAAUpC,EACrC0jB,EAAAthB,EAAAkB,cAAAlB,EAAAkB,aAAA,QACA,IAAAogB,EACA,OAAAD,EAEA,IAAAE,EAAA3jB,EAAAyF,UACAhI,EAAAuC,EAAAoC,EAAAQ,eAAArH,OAAAwF,OAAA,GAA4EqB,EAAAQ,kBAAA,GAAgCR,EAAAtB,aAAA,IAAAsB,EAAAtB,gBAAA,IAC5Gd,EACA,MAAA4jB,EAAAH,EAAAC,GACA,OAAAnoB,OAAAwF,OAAA,GAA2C0iB,EAAA,CAAU/gB,CAAAghB,GAAAE,EAAA,IAAAA,EAAAD,GAAA,CAAAA,MACpC,IACjB,OACApoB,OAAA2H,KAAAugB,GAAAlgB,OAAA,CAAA8B,EAAAjJ,KACA,MAAAN,EAAA2nB,EAAArnB,GACA,OAAAb,OAAAwF,OAAA,GAA+CsE,EAAA,CAAW3C,CAAAtG,GAAA,IAAAN,EAAAkD,OAAAlD,EAAA,GAAAA,KACrC,KAGrB,OAAA6G,KAAA0e,aAAA3B,EAAAgD,KACA/f,KAAAse,UAAAqB,OAAAuB,KAAAzhB,QAAAkD,UAAAwe,IAAAD,IACA,MAAAzhB,QAA2BA,GAAUyhB,EACrC,OAAApmB,EAAAomB,EAAAtoB,OAAAwF,OAAA,GAAoDqB,EAAAQ,kBAAA,IAAAR,EAAAtB,mBAIpD6B,KAAAse,UAGAve,yBAAAtH,EAAA2oB,EAAAjoB,GACA,MAAAqL,EAAAyZ,EAAAxlB,GACA,GAAA8G,EAAAhF,QAAAiK,IAAA,EACAxE,KAAAuf,aAAA/a,EAAArL,QAGA,IACA,MAAAkoB,EAAAloB,EAAAmoB,KAAAC,MAAApoB,GAAA,KACA6G,KAAAuf,aAAA/a,EAAA6c,GAEA,MAAAllB,KAKA4D,kBAAAyE,EAAArL,GACA6G,KAAAue,iBAAA/Z,GAAArL,EAEA4G,kBAAAyE,GACA,OAAAxE,KAAAue,iBAAA/Z,GAEAzE,aAAAyE,EAAArL,GACA6G,KAAAqe,YAAA7Z,GAAArL,EACA6G,KAAAigB,UAEAlgB,aAAAyE,GACA,OAAAxE,KAAAqe,YAAA7Z,GAEAzE,0BAAA9B,GACA,OAAAA,EAAA2C,OAAA,CAAA3C,EAAAuG,KACA,MAAA0Z,EAAA1Z,EAAAlF,cACAnG,EAAA6G,KAAAW,aAAAud,GACA,UAAA/kB,EACA,IACA8E,EAAAuG,GAAA8c,KAAAC,MAAApoB,GAEA,MAAAgD,IAIA,OAAA8B,GACa,IAEb8B,wBAAAR,GACA,OAAAA,EAAAqB,OAAA,CAAA3C,EAAAuG,KACA,MAAA0Z,EAAA1Z,EAAAlF,cACAnG,EAAA6G,KAAAW,aAAAud,GAIA,OAHA,OAAA/kB,IACA8E,EAAAuG,GAAArL,GAEA8E,GACa,IAEbujB,gCACA,OAAA5oB,OAAA2H,KAAA0d,GAEAtb,eACA,SAEA5C,IAAAtG,EAAAN,GACA6G,KAAAwe,eAAA/kB,GAAAN,EACA6G,KAAAygB,WACAzgB,KAAAuf,aAAA9lB,EAAAN,KAKO,SAAA8jB,EAAAc,GACP,MAAAD,EAAAC,EAAA0D,0BACA,IAAA3D,EACA,UAAAhD,MAAA,yGAEIqC,EAAA,EAAMuE,eAAAjZ,OAAAqV,EAAA/f,QAAAvE,EAAAskB,EAAAC,IAEKrjB,EAAA,0CCxWf5C,EAAAU,EAAAkC,EAAA,sBAAA+I,IAAA,IAAAhI,EAAA3D,EAAA,GAIO,MAAA6pB,EAAA,GAIAC,EAAA,IAEPC,eAAOA,GAAoBpmB,EAAA,EAAMqmB,oBAAA,GAEjC,uBAA4BrmB,EAAA,UACjBA,EAAA,EAAMqmB,mBAejB,MAAAC,EAAAF,EANA,mBAOAA,EACAA,EAAAG,MAA+BvmB,EAAA,GAC/BomB,EACA,GAiEO,SAAAtd,EAAA0d,EAAA9oB,EAAA+oB,GAAA,GACP,MAAAC,EAAAF,EAAA3iB,cACA,GArBO,SAAA2iB,GACP,MAAAE,EAAAF,EAAA3iB,cACA,OAAA3B,QAAAwkB,KAAAJ,GAAAI,KAAAR,GAAAC,EAAAO,IAmBAC,CAAAD,KAAAD,KAAAC,KAAAJ,GACA,UAAAM,sBAAwCJ,qCAExC,mBAAA9oB,EACAyoB,EAAAO,GAAAhpB,GAGAwoB,EAAAQ,GAAAhpB,SACAyoB,EAAAO,IAQe,SAAA1e,EAAAwe,EAAAK,GAAA,GACf,IAAA5f,EACA,MAAAyf,EAAAF,EAAA3iB,cACA,GAAA6iB,KAAAJ,EACArf,EAAAqf,EAAAI,QAEA,GAAAP,EAAAO,GACAzf,EAAAif,EAAAQ,GAAAP,EAAAO,GAAA9pB,KAAA,aACAupB,EAAAO,QAEA,GAAAA,KAAAR,EACAjf,EAAAif,EAAAQ,QAEA,GAAAG,EACA,UAAAD,yDAA2EJ,MAE3E,OAAAvf,EAKA6B,EAAA,mBAAA5E,GAEA4E,EAAA,iBAEAA,EAAA,mBAEAA,EAAA,aAAsB,oBAAAlK,YAAA,IAAAA,UAAAC,UAAAC,QAAA,UAEtBgK,EAAA,gBACAA,EAAA,YACAA,EAAA,gBACAA,EAAA,qBACAA,EAAA,gBACAA,EAAA,mBAEAA,EAAA,cACAA,EAAA,mBAEAA,EAAA,eACAA,EAAA,oBAEAA,EAAA,iBACAA,EAAA,oBAEAA,EAAA,oBAEAA,EAAA,kBACAA,EAAA,kCAAyD,IAAN9I,EAAA,EAAM8mB,QAAAzoB,UAAA0oB,SAAA,GAEzDje,EAAA,cAEAA,EAAA,iBACAA,EAAA,qBACAA,EAAA,oBAEAA,EAAA,iBAEAA,EAAA,kBAEAA,EAAA,iBACAA,EAAA,kBACAA,EAAA,UACAA,EAAA,mBAEAA,EAAA,2BACAA,EAAA,4BAA4C5E,IAANlE,EAAA,EAAMgnB,gBAAkC9iB,IAANlE,EAAA,EAAMinB,gBAAA,GAC9Ene,EAAA,4BAA2C,IAAN9I,EAAA,EAAMknB,iBAC3Cpe,EAAA,wBAAuC,IAAN9I,EAAA,EAAMmnB,aACvCre,EAAA,qCAAqD5E,IAANlE,EAAA,EAAMonB,sBAAA,GACrDte,EAAA,+BAA+C5E,IAANlE,EAAA,EAAMqnB,gBAAA,GAC/Cve,EAAA,8BAA8C5E,IAANlE,EAAA,EAAMsnB,eAAA,GAC9Cxe,EAAA,wBACAA,EAAA,gBAA2Bye,QAAAlpB,UAAAC,eAAA,aAC3BwK,EAAA,kBACAA,EAAA,WACAA,EAAA,uBAAsC,IAAN9I,EAAA,EAAMjB,iCC/LtC,SAAAN,GAAA,IAAAuI,IAIC,WAAqB,aAStB,IAAAwgB,EAAA,WACA,uBAAAzI,IACA,OAAAA,IAUA,SAAA0I,EAAA9gB,EAAA3I,GACA,IAAAiJ,GAAA,EAYA,OAVAN,EAAAyS,KAAA,SAAAsO,EAAAtU,GACA,OAAAsU,EAAA,KAAA1pB,IACAiJ,EAAAmM,GAEA,KAMAnM,EAGA,kBACA,SAAA0gB,IACApjB,KAAAqjB,YAAA,GAGA,IAAAC,EAAA,CAAkCvf,KAAA,CAAQwf,cAAA,IAiF1C,OA5EAD,EAAAvf,KAAAhL,IAAA,WACA,OAAAiH,KAAAqjB,YAAAhnB,QAOA+mB,EAAAtpB,UAAAf,IAAA,SAAAU,GACA,IAAAoV,EAAAqU,EAAAljB,KAAAqjB,YAAA5pB,GACA0pB,EAAAnjB,KAAAqjB,YAAAxU,GAEA,OAAAsU,KAAA,IAQAC,EAAAtpB,UAAA0J,IAAA,SAAA/J,EAAAN,GACA,IAAA0V,EAAAqU,EAAAljB,KAAAqjB,YAAA5pB,IAEAoV,EACA7O,KAAAqjB,YAAAxU,GAAA,GAAA1V,EAEA6G,KAAAqjB,YAAAjc,KAAA,CAAA3N,EAAAN,KAQAiqB,EAAAtpB,UAAA4J,OAAA,SAAAjK,GACA,IAAAiiB,EAAA1b,KAAAqjB,YACAxU,EAAAqU,EAAAxH,EAAAjiB,IAEAoV,GACA6M,EAAAxL,OAAArB,EAAA,IAQAuU,EAAAtpB,UAAA2J,IAAA,SAAAhK,GACA,SAAAypB,EAAAljB,KAAAqjB,YAAA5pB,IAMA2pB,EAAAtpB,UAAAkK,MAAA,WACAhE,KAAAqjB,YAAAnT,OAAA,IAQAkT,EAAAtpB,UAAA0G,QAAA,SAAA+B,EAAAihB,QAEA,IAAAA,MAAA,MAEA,QAAAtrB,EAAA,EAAAurB,EAHAzjB,KAGAqjB,YAAsDnrB,EAAAurB,EAAApnB,OAAiBnE,GAAA,GACvE,IAAAirB,EAAAM,EAAAvrB,GAEAqK,EAAAlK,KAAAmrB,EAAAL,EAAA,GAAAA,EAAA,MAIAvqB,OAAA8mB,iBAAA0D,EAAAtpB,UAAAwpB,GAEAF,EAtFA,GA5BA,GAyHAM,EAAA,oBAAAtpB,QAAA,oBAAAiK,UAAAjK,OAAAiK,oBAGAsf,OACA,IAAAzpB,KAAA0pB,YACA1pB,EAGA,oBAAAO,WAAAmpB,YACAnpB,KAGA,oBAAAL,eAAAwpB,YACAxpB,OAIAghB,SAAA,cAAAA,GASAyI,EACA,mBAAAxX,sBAIAA,sBAAA3S,KAAAiqB,GAGA,SAAAphB,GAAgC,OAAAgb,WAAA,WAAgC,OAAAhb,EAAAuhB,KAAAC,QAA+B,SAI/FC,EAAA,EAiFAC,EAAA,iEAGAC,EAAA,oBAAAC,iBAKAC,EAAA,WACApkB,KAAAqkB,YAAA,EACArkB,KAAAskB,sBAAA,EACAtkB,KAAAukB,mBAAA,KACAvkB,KAAAwkB,WAAA,GAEAxkB,KAAAykB,iBAAAzkB,KAAAykB,iBAAA/qB,KAAAsG,MACAA,KAAA0kB,QAtFA,SAAAniB,EAAAoiB,GACA,IAAAC,GAAA,EACAC,GAAA,EACAC,EAAA,EAQA,SAAAC,IACAH,IACAA,GAAA,EAEAriB,KAGAsiB,GACAG,IAWA,SAAAC,IACApB,EAAAkB,GAQA,SAAAC,IACA,IAAAE,EAAApB,KAAAC,MAEA,GAAAa,EAAA,CAEA,GAAAM,EAAAJ,EAAAd,EACA,OAOAa,GAAA,OAEAD,GAAA,EACAC,GAAA,EAEAtH,WAAA0H,EAAAN,GAGAG,EAAAI,EAGA,OAAAF,EAuBAG,CAAAnlB,KAAA0kB,QAAAhrB,KAAAsG,MAnBA,KAgDAokB,EAAAtqB,UAAAsrB,YAAA,SAAAC,IACArlB,KAAAwkB,WAAAjqB,QAAA8qB,IACArlB,KAAAwkB,WAAApd,KAAAie,GAIArlB,KAAAqkB,YACArkB,KAAAslB,YAUAlB,EAAAtqB,UAAAyrB,eAAA,SAAAF,GACA,IAAAG,EAAAxlB,KAAAwkB,WACA3V,EAAA2W,EAAAjrB,QAAA8qB,IAGAxW,GACA2W,EAAAtV,OAAArB,EAAA,IAIA2W,EAAAnpB,QAAA2D,KAAAqkB,YACArkB,KAAAylB,eAUArB,EAAAtqB,UAAA4qB,QAAA,WACA1kB,KAAA0lB,oBAKA1lB,KAAA0kB,WAYAN,EAAAtqB,UAAA4rB,iBAAA,WAEA,IAAAC,EAAA3lB,KAAAwkB,WAAA7E,OAAA,SAAA0F,GACA,OAAAA,EAAAO,eAAAP,EAAAQ,cAUA,OAFAF,EAAAnlB,QAAA,SAAA6kB,GAAiD,OAAAA,EAAAS,oBAEjDH,EAAAtpB,OAAA,GASA+nB,EAAAtqB,UAAAwrB,SAAA,WAGA5B,IAAA1jB,KAAAqkB,aAOAhgB,SAAAuD,iBAAA,gBAAA5H,KAAAykB,kBAEArqB,OAAAwN,iBAAA,SAAA5H,KAAA0kB,SAEAR,GACAlkB,KAAAukB,mBAAA,IAAAJ,iBAAAnkB,KAAA0kB,SAEA1kB,KAAAukB,mBAAAwB,QAAA1hB,SAAA,CACA9E,YAAA,EACAymB,WAAA,EACAC,eAAA,EACAC,SAAA,MAGA7hB,SAAAuD,iBAAA,qBAAA5H,KAAA0kB,SAEA1kB,KAAAskB,sBAAA,GAGAtkB,KAAAqkB,YAAA,IASAD,EAAAtqB,UAAA2rB,YAAA,WAGA/B,GAAA1jB,KAAAqkB,aAIAhgB,SAAAoD,oBAAA,gBAAAzH,KAAAykB,kBACArqB,OAAAqN,oBAAA,SAAAzH,KAAA0kB,SAEA1kB,KAAAukB,oBACAvkB,KAAAukB,mBAAA4B,aAGAnmB,KAAAskB,sBACAjgB,SAAAoD,oBAAA,qBAAAzH,KAAA0kB,SAGA1kB,KAAAukB,mBAAA,KACAvkB,KAAAskB,sBAAA,EACAtkB,KAAAqkB,YAAA,IAUAD,EAAAtqB,UAAA2qB,iBAAA,SAAA2B,GACA,IAAA5hB,EAAA4hB,EAAA5hB,kBAA4C,IAAAA,MAAA,IAG5Cyf,EAAApP,KAAA,SAAApb,GACA,SAAA+K,EAAAjK,QAAAd,MAIAuG,KAAA0kB,WASAN,EAAAiC,YAAA,WAKA,OAJArmB,KAAAsmB,YACAtmB,KAAAsmB,UAAA,IAAAlC,GAGApkB,KAAAsmB,WAGAlC,EAAAkC,UAAA,KASA,IAAAC,EAAA,SAAA5e,EAAAzI,GACA,QAAAhH,EAAA,EAAAurB,EAAA7qB,OAAA2H,KAAArB,GAA8ChH,EAAAurB,EAAApnB,OAAiBnE,GAAA,GAC/D,IAAAuB,EAAAgqB,EAAAvrB,GAEAU,OAAAC,eAAA8O,EAAAlO,EAAA,CACAN,MAAA+F,EAAAzF,GACAX,YAAA,EACA0tB,UAAA,EACAjD,cAAA,IAIA,OAAA5b,GASA8e,EAAA,SAAA9e,GAQA,OAJAA,KAAA+e,eAAA/e,EAAA+e,cAAAC,aAIAhD,GAIAiD,EAAAC,EAAA,SAQA,SAAAC,EAAA3tB,GACA,OAAA4tB,WAAA5tB,IAAA,EAUA,SAAA6tB,EAAAroB,GAEA,IADA,IAAAsoB,EAAA,GAAAC,EAAA9I,UAAA/hB,OAAA,EACA6qB,KAAA,GAAAD,EAAAC,GAAA9I,UAAA8I,EAAA,GAEA,OAAAD,EAAArmB,OAAA,SAAAmD,EAAAojB,GAGA,OAAApjB,EAAA+iB,EAFAnoB,EAAA,UAAAwoB,EAAA,YAGK,GA2CL,SAAAC,EAAAzf,GAGA,IAAA0f,EAAA1f,EAAA0f,YACAC,EAAA3f,EAAA2f,aAUA,IAAAD,IAAAC,EACA,OAAAV,EAGA,IAAAjoB,EAAA8nB,EAAA9e,GAAAgZ,iBAAAhZ,GACA4f,EArDA,SAAA5oB,GAIA,IAHA,IACA4oB,EAAA,GAEArvB,EAAA,EAAAurB,EAHA,gCAGqCvrB,EAAAurB,EAAApnB,OAAiBnE,GAAA,GACtD,IAAAivB,EAAA1D,EAAAvrB,GAEAiB,EAAAwF,EAAA,WAAAwoB,GAEAI,EAAAJ,GAAAL,EAAA3tB,GAGA,OAAAouB,EAyCAC,CAAA7oB,GACA8oB,EAAAF,EAAAG,KAAAH,EAAAI,MACAC,EAAAL,EAAAM,IAAAN,EAAAO,OAMAC,EAAAjB,EAAAnoB,EAAAopB,OACAC,EAAAlB,EAAAnoB,EAAAqpB,QAwBA,GApBA,eAAArpB,EAAAspB,YAOArE,KAAAsE,MAAAH,EAAAN,KAAAJ,IACAU,GAAAf,EAAAroB,EAAA,gBAAA8oB,GAGA7D,KAAAsE,MAAAF,EAAAJ,KAAAN,IACAU,GAAAhB,EAAAroB,EAAA,gBAAAipB,KA0DA,SAAAjgB,GACA,OAAAA,IAAA8e,EAAA9e,GAAAtD,SAAA8jB,gBAnDAC,CAAAzgB,GAAA,CAKA,IAAA0gB,EAAAzE,KAAAsE,MAAAH,EAAAN,GAAAJ,EACAiB,EAAA1E,KAAAsE,MAAAF,EAAAJ,GAAAN,EAOA,IAAA1D,KAAA2E,IAAAF,KACAN,GAAAM,GAGA,IAAAzE,KAAA2E,IAAAD,KACAN,GAAAM,GAIA,OAAAzB,EAAAU,EAAAG,KAAAH,EAAAM,IAAAE,EAAAC,GASA,IAAAQ,EAGA,oBAAAC,mBACA,SAAA9gB,GAAkC,OAAAA,aAAA8e,EAAA9e,GAAA8gB,oBAMlC,SAAA9gB,GAA8B,OAAAA,aAAA8e,EAAA9e,GAAA+gB,YAAA,mBAAA/gB,EAAAghB,SAmB9B,SAAAC,EAAAjhB,GACA,OAAA+b,EAIA8E,EAAA7gB,GAjIA,SAAAA,GACA,IAAAkhB,EAAAlhB,EAAAghB,UAEA,OAAA9B,EAAA,IAAAgC,EAAAd,MAAAc,EAAAb,QA+HAc,CAAAnhB,GAGAyf,EAAAzf,GAPAif,EAiDA,SAAAC,EAAAkC,EAAAC,EAAAjB,EAAAC,GACA,OAAYe,IAAAC,IAAAjB,QAAAC,UAOZ,IAAAiB,EAAA,SAAAthB,GACA3H,KAAAkpB,eAAA,EACAlpB,KAAAmpB,gBAAA,EACAnpB,KAAAopB,aAAAvC,EAAA,SAEA7mB,KAAA2H,UAuBAshB,EAAAnvB,UAAAuvB,SAAA,WACA,IAAAC,EAAAV,EAAA5oB,KAAA2H,QAIA,OAFA3H,KAAAopB,aAAAE,EAEAA,EAAAvB,QAAA/nB,KAAAkpB,gBAAAI,EAAAtB,SAAAhoB,KAAAmpB,iBASAF,EAAAnvB,UAAAyvB,cAAA,WACA,IAAAD,EAAAtpB,KAAAopB,aAKA,OAHAppB,KAAAkpB,eAAAI,EAAAvB,MACA/nB,KAAAmpB,gBAAAG,EAAAtB,OAEAsB,GAGA,IAAAE,EAAA,SAAA7hB,EAAA8hB,GACA,IA5FArD,EACA2C,EACAC,EACAjB,EACAC,EAGA0B,EACAJ,EAoFAK,GA3FAZ,GADA3C,EA4FAqD,GA3FAV,EACAC,EAAA5C,EAAA4C,EACAjB,EAAA3B,EAAA2B,MACAC,EAAA5B,EAAA4B,OAGA0B,EAAA,oBAAAE,gCAAAhxB,OACA0wB,EAAA1wB,OAAAY,OAAAkwB,EAAA5vB,WAGAysB,EAAA+C,EAAA,CACAP,IAAAC,IAAAjB,QAAAC,SACAH,IAAAmB,EACArB,MAAAoB,EAAAhB,EACAD,OAAAE,EAAAgB,EACAtB,KAAAqB,IAGAO,GAiFA/C,EAAAvmB,KAAA,CAA8B2H,SAAAgiB,iBAG9BE,EAAA,SAAAtnB,EAAAunB,EAAAC,GAIA,GAHA/pB,KAAAgqB,oBAAA,GACAhqB,KAAAiqB,cAAA,IAAAhH,EAEA,mBAAA1gB,EACA,UAAA8f,UAAA,2DAGAriB,KAAAkqB,UAAA3nB,EACAvC,KAAAmqB,YAAAL,EACA9pB,KAAAoqB,aAAAL,GA+BAF,EAAA/vB,UAAAisB,QAAA,SAAApe,GACA,IAAAyW,UAAA/hB,OACA,UAAAgmB,UAAA,4CAIA,uBAAAW,4BAAApqB,OAAA,CAIA,KAAA+O,aAAA8e,EAAA9e,GAAAqb,SACA,UAAAX,UAAA,yCAGA,IAAAgI,EAAArqB,KAAAiqB,cAGAI,EAAA5mB,IAAAkE,KAIA0iB,EAAA7mB,IAAAmE,EAAA,IAAAshB,EAAAthB,IAEA3H,KAAAmqB,YAAA/E,YAAAplB,MAGAA,KAAAmqB,YAAAzF,aASAmF,EAAA/vB,UAAAwwB,UAAA,SAAA3iB,GACA,IAAAyW,UAAA/hB,OACA,UAAAgmB,UAAA,4CAIA,uBAAAW,4BAAApqB,OAAA,CAIA,KAAA+O,aAAA8e,EAAA9e,GAAAqb,SACA,UAAAX,UAAA,yCAGA,IAAAgI,EAAArqB,KAAAiqB,cAGAI,EAAA5mB,IAAAkE,KAIA0iB,EAAA3mB,OAAAiE,GAEA0iB,EAAAtmB,MACA/D,KAAAmqB,YAAA5E,eAAAvlB,SASA6pB,EAAA/vB,UAAAqsB,WAAA,WACAnmB,KAAAuqB,cACAvqB,KAAAiqB,cAAAjmB,QACAhE,KAAAmqB,YAAA5E,eAAAvlB,OASA6pB,EAAA/vB,UAAA8rB,aAAA,WACA,IAAA4E,EAAAxqB,KAEAA,KAAAuqB,cAEAvqB,KAAAiqB,cAAAzpB,QAAA,SAAAiqB,GACAA,EAAApB,YACAmB,EAAAR,oBAAA5iB,KAAAqjB,MAWAZ,EAAA/vB,UAAAgsB,gBAAA,WAEA,GAAA9lB,KAAA6lB,YAAA,CAIA,IAAArC,EAAAxjB,KAAAoqB,aAGA1O,EAAA1b,KAAAgqB,oBAAA7I,IAAA,SAAAsJ,GACA,WAAAjB,EAAAiB,EAAA9iB,OAAA8iB,EAAAlB,mBAGAvpB,KAAAkqB,UAAA7xB,KAAAmrB,EAAA9H,EAAA8H,GACAxjB,KAAAuqB,gBAQAV,EAAA/vB,UAAAywB,YAAA,WACAvqB,KAAAgqB,oBAAA9Z,OAAA,IAQA2Z,EAAA/vB,UAAA+rB,UAAA,WACA,OAAA7lB,KAAAgqB,oBAAA3tB,OAAA,GAMA,IAAAmpB,EAAA,oBAAAkF,QAAA,IAAAA,QAAA,IAAAzH,EAMAH,EAAA,SAAAvgB,GACA,KAAAvC,gBAAA8iB,GACA,UAAAT,UAAA,sCAEA,IAAAjE,UAAA/hB,OACA,UAAAgmB,UAAA,4CAGA,IAAAyH,EAAA1F,EAAAiC,cACAhB,EAAA,IAAAwE,EAAAtnB,EAAAunB,EAAA9pB,MAEAwlB,EAAAhiB,IAAAxD,KAAAqlB,IAoBA,MAhBA,qCAAA7kB,QAAA,SAAAmqB,GACA7H,EAAAhpB,UAAA6wB,GAAA,WACA,OAAAvE,EAAAZ,EAAAzsB,IAAAiH,OAAA2qB,GAAA3I,MAAAoE,EAAAhI,WACA,IAAAgI,UAMA,IAAAzC,EAAAb,eACAa,EAAAb,eAGAA,GAjgC6D7qB,EAAAD,QAAAyK,uDCD7D3K,EAAAU,EAAAkC,EAAA,sBAAAkwB,IAAA9yB,EAAAU,EAAAkC,EAAA,sBAAAmwB,IAAA/yB,EAAAU,EAAAkC,EAAA,sBAAAowB,IAAAhzB,EAAAU,EAAAkC,EAAA,sBAAAqwB,IAAAjzB,EAAAU,EAAAkC,EAAA,sBAAAiI,IAAA7K,EAAAU,EAAAkC,EAAA,sBAAAswB,IAAA,IAAAtQ,EAAA5iB,EAAA,GAAAmzB,EAAAnzB,EAAA,GAAAozB,EAAApzB,EAAA,GAMO,MAAA8yB,EAAA,qBAOA,SAAAC,EAAA3tB,GACP,OAAAS,QAAAT,KAAA4X,QAAA8V,GAEO,SAAAE,EAAA5tB,GACP,OAAAS,QAAAT,KAAAyF,UAEO,SAAAooB,EAAA3vB,GACP,2BAAAA,MAAA0H,WAKO,SAAAH,EAAAzF,GACP,OAAA2tB,EAAA3tB,IAAA4tB,EAAA5tB,GAWO,MAAA8tB,UAAuBE,EAAA,EAI9BnrB,gBAAAorB,EAAAjuB,GACA8C,KAAAkX,KAAA,CACAtZ,KAAAutB,EACAlU,OAAA,SACA/Z,SAGA6C,OAAAwI,EAAArL,GAIA,QAHAyC,IAAAK,KAAAorB,kBACAprB,KAAAorB,gBAAA,IAAuCH,EAAA,GAEvCjrB,KAAAorB,gBAAA3nB,IAAA8E,GACA,UAAAuS,iDAAuEvS,EAAA+L,eAEvEtU,KAAAorB,gBAAA5nB,IAAA+E,EAAArL,GACAA,aAA4Bwd,EAAA,EAC5Bxd,EAAA6W,KAAAsX,IACArrB,KAAAorB,gBAAA5nB,IAAA+E,EAAA8iB,GACArrB,KAAAsrB,gBAAA/iB,EAAA8iB,GACAA,GACaE,IACb,MAAAA,IAGAV,EAAA3tB,IACA8C,KAAAsrB,gBAAA/iB,EAAArL,GAGA6C,eAAAwI,EAAA8R,GAIA,QAHA1a,IAAAK,KAAAwrB,oBACAxrB,KAAAwrB,kBAAA,IAAyCP,EAAA,GAEzCjrB,KAAAwrB,kBAAA/nB,IAAA8E,GACA,UAAAuS,mDAAyEvS,EAAA+L,eAEzE,MAAAnZ,EAAA,IAAgC+vB,EAAA,EAChCO,EAAA,CACAlV,SAAA8D,EAAA,IAAAlf,EAAA+b,KAAA,CAA8DtZ,KAAA,gBAC9DzC,eAEA6E,KAAAwrB,kBAAAhoB,IAAA+E,EAAAkjB,GACAzrB,KAAAsrB,gBAAA/iB,EAAAkjB,GAEA1rB,IAAAwI,GACA,IAAAvI,KAAAorB,kBAAAprB,KAAAyD,IAAA8E,GACA,YAEA,MAAArL,EAAA8C,KAAAorB,gBAAAryB,IAAAwP,GACA,GAAA5F,EAAAzF,IAAA6tB,EAAA7tB,GACA,OAAAA,EAEA,GAAAA,aAA4Bwd,EAAA,EAC5B,YAEA,MAAAgR,EAAAxuB,IAYA,OAXA8C,KAAAorB,gBAAA5nB,IAAA+E,EAAAmjB,GACAA,EAAA3X,KAAAsX,IArEO,SAAAnuB,GACP,OAAAS,QAAAT,GACAA,EAAAnD,eAAA,eACAmD,EAAAnD,eAAA,aACA4I,EAAAzF,EAAA2e,UAAAkP,EAAA7tB,EAAA2e,WAkEA8P,CAAAN,KACAA,IAAAxP,SAEA7b,KAAAorB,gBAAA5nB,IAAA+E,EAAA8iB,GACArrB,KAAAsrB,gBAAA/iB,EAAA8iB,GACAA,GACSE,IACT,MAAAA,IAEA,KAEAxrB,YAAAwI,GACA,OAAAvI,KAAAwrB,mBAAAxrB,KAAAyW,YAAAlO,GAGAvI,KAAAwrB,kBAAAzyB,IAAAwP,GAFA,KAIAxI,IAAAwI,GACA,OAAA5K,QAAAqC,KAAAorB,iBAAAprB,KAAAorB,gBAAA3nB,IAAA8E,IAEAxI,YAAAwI,GACA,OAAA5K,QAAAqC,KAAAwrB,mBAAAxrB,KAAAwrB,kBAAA/nB,IAAA8E,KAGe7N,EAAA,wECrHV9B,OAAA6K,EAAA,EAAA7K,CAAG,gBACCsB,EAAA,EAAM4oB,iBAEP5oB,EAAA,EAAM4oB,eAAkB8I,EAAA3e,GAAkB6V,GAGnCpoB,EAAA,ECTA,SAAAmxB,EAAAC,GAAA,EAAApyB,GAAA,GACf,OAAQd,OAAA6K,EAAA,EAAA7K,CAAG,QACXkzB,EACA,YAAAnmB,GACA,WAA2BzL,EAAA,EAAM2xB,MAAAlmB,IAIjC,YAAAA,GACA,OAAuBzL,EAAA,EAAM2xB,MAAAlmB,IAI7BjM,EAAkBQ,EAAA,EAAM2xB,GAAAnyB,KAAoBQ,EAAA,GAAUA,EAAA,EAAM2xB,GDJ7C,CAAO,sDEXtB/zB,EAAAU,EAAAkC,EAAA,sBAAAqxB,IAAA,IAAAC,EAAAl0B,EAAA,IAAA4b,EAAA5b,EAAA,GAAAm0B,EAAAn0B,EAAA,IAGA,MACOi0B,EADSnzB,OAAA8a,EAAA,EAAA9a,CAAM,CAAGwC,KAAAsY,EAAA,EAAMpY,QAAAoY,EAAA,EAASF,OAAAyY,EAAA,GACjCxpB,CAAA,EAAyBI,YAAczH,OAAAE,UAAAkY,cAC9C,MAAAjT,EAAA,GACA+Z,EAAA,GAOA,OANAhf,EAAA,KACA,IAAA0b,EACA,KAAAA,EAAAsD,EAAA9Q,OACAwN,SAGA,CACAjX,IAAAtG,GACA,MAAAgG,EAAArE,EAAArC,IAAAU,GACA,IAAAgG,EACA,YAEA,QAAAc,EAAAhG,QAAAd,GAAA,CACA8G,EAAA6G,KAAA3N,GACA,MAAAyyB,EAAA,IAA2CF,EAAA,EAAc,EAAA7I,MACzD3P,EAAAhQ,IAAA/J,EAAA0pB,EAAAwG,eAEAuC,EAAAnG,QAAAtmB,GACA6a,EAAAlT,KAAA,IAAA8kB,EAAA/F,cAEA,OAAA3S,EAAAza,IAAAU,IAAA,SAIeiB,EAAA,oCC/Bf,IAAA2Y,EAAAvb,EAAA,GAAAA,EAAA,GAOO,IAAA4yB,EAAcrX,EAAA,EAAMqX,QAyGZhwB,EAAA,+DCxGR,SAAAgd,EAAAP,GACP,OAAAA,KAAApd,eAAA,WAEO,SAAAoyB,EAAAhV,GACP,OAAAA,KAAApd,eAAA,YAEO,SAAAqyB,EAAAjV,GACP,QAAAA,KAAApd,eAAA,WAfAjC,EAAAU,EAAAkC,EAAA,sBAAAgd,IAAA5f,EAAAU,EAAAkC,EAAA,sBAAAyxB,IAAAr0B,EAAAU,EAAAkC,EAAA,sBAAA0xB,IAAAt0B,EAAAU,EAAAkC,EAAA,sBAAA2xB,IA6EA,SAAAC,EAAAnV,EAAAa,GACA,OAAAN,EAAAP,GACA,iBAAAA,EAAAa,QACA,CACAb,cACAa,QAAA,CAA0Bvf,KAAA0e,EAAAa,QAAA7e,MAAAge,QAAA0B,SAAA1B,EAAAa,WAG1B,CAAgBb,cAAAa,QAAAb,EAAAa,SAEhBmU,EAAAhV,GAlFO,SAAAa,GACP,uBAAAA,EAmFAuU,CADAvU,KAAA,WAKA,CAAoBb,QAAAa,WAKpB,CAAgBb,QAAAa,QAAA,CAAyBvf,KAAAuf,EAAA7e,MAAAge,EAAA0B,SAAAb,KAEzC,CAAYb,SAEL,MAAMkV,UAAsBpS,EAAA,EACnCla,YAAAoX,GACAlB,MAAAkB,EAAAmV,EAAAnV,MAEApX,IAAAoX,EAAAa,GACA/B,MAAAzS,IAAA8oB,EAAAnV,EAAAa,IAEAjY,MACA,OAAAkW,MAAAld,OAGe2B,EAAA,oCChGR,SAAA8xB,EAAAC,GACP,gBAAA9kB,KAAAhC,GACA,OAAA8mB,EAAAzK,MAAAra,EAAAhC,IAnBA7N,EAAAU,EAAAkC,EAAA,sBAAA8xB,oCCAA10B,EAAAU,EAAAkC,EAAA,sBAAAgyB,IAAA,IAAArZ,EAAAvb,EAAA,GAAA4D,EAAA5D,EAAA,GAQO,IAAA60B,EAAkBtZ,EAAA,EAAMkP,QACxB,MAAAmK,EAAA,SAAAvzB,GACP,OAAAA,GAAA,mBAAAA,EAAA4a,MAgMKnb,OAAA8C,EAAA,EAAA9C,CAAG,4BACJya,EAAA,EAAMkP,QAAAzoB,UAAA0oB,QAAA,SAAAoK,GACV,OAAA5sB,KAAA+T,KAAA6Y,GAAA,CAAAzzB,GAAAopB,QAAA3H,QAAAgS,KAAA7Y,KAAA,IAAA5a,IAAAyzB,GACA,CAAAC,GAAAtK,QAAA3H,QAAAgS,KAAA7Y,KAAA,KACA,MAAA8Y,QAIenyB,EAAA,qCClNf,IAAAse,EAAAlhB,EAAA,GAAAg1B,EAAAh1B,EAAA,IAEA,MAAA2K,EAAgB7J,OAAAogB,EAAA,EAAApgB,CAAM,CAAGmzB,OAAAe,EAAA,IAkCzB,MAAAzQ,EAjCO,SAAA0Q,EAAA,CAAmDC,GAAA,EAAAC,GAAA,IAAAC,GAAA,IAAAC,GAAA,MAC1D,MAAAC,EAAAL,EA8BA,OA7BAtqB,EAAA,EAAiCI,YAAckpB,cAC/C,CACAhzB,IAAA,CAAAU,EAAAszB,EAAAK,KACA,MAAAzD,EAAAoC,EAAAhzB,IAAAU,GACA,IAAAkwB,EACA,YAEA,IAAAlN,EAAA,KACA,MAAAlc,EAAA3H,OAAA2H,KAAAwsB,GACA,QAAA70B,EAAA,EAA+BA,EAAAqI,EAAAlE,OAAiBnE,IAAA,CAChD,MAAAmkB,EAAA0Q,EAAAxsB,EAAArI,IACAyxB,EAAA5B,OAAA1L,KACAI,GAAAJ,EAAAI,EAAA1Y,QACA0Y,EAAA,CACAhkB,KAAA8H,EAAArI,GACA6L,KAAAsY,IAIA,OAAAI,EACA,CACAJ,WAAAI,EAAAhkB,KACAkxB,eAGA,SAMA0D,GACe3yB,EAAA,oCCrCf5C,EAAAU,EAAAkC,EAAA,sBAAA4yB,IAAA,IAAA7Z,EAAA3b,EAAA,GAAAy1B,EAAAz1B,EAAA,IAKA,MAAA01B,EAAA,IAAqB/Z,EAAA,EAyBd,MAAA6Z,UAAsBC,EAAA,EAC7BxtB,cACAkW,SAAAmI,WAIApe,KAAAytB,aAAA,IAAgCha,EAAA,EAEhC1T,KAAA2M,GACA1M,KAAAytB,aAAAjtB,QAAA,CAAAktB,EAAA9vB,MA5BO,SAAA+vB,EAAAC,GACP,oBAAAA,GAAA,iBAAAD,IAAA,IAAAA,EAAApzB,QAAA,MACA,IAAAszB,EAQA,OAPAL,EAAA/pB,IAAAkqB,GACAE,EAAAL,EAAAz0B,IAAA40B,IAGAE,EAAA,IAAAC,WAAmCH,EAAAhe,QAAA,gBACnC6d,EAAAhqB,IAAAmqB,EAAAE,IAEAA,EAAAE,KAAAH,GAGA,OAAAD,IAAAC,GAgBAI,CAAApwB,EAAA8O,EAAA9O,OACA,IAAA8vB,GAAAltB,QAAAmqB,IACAA,EAAAtyB,KAAA2H,KAAA0M,OAKA3M,GAAAnC,EAAAqwB,GACA,GAAAzvB,MAAAC,QAAAwvB,GAAA,CACA,MAAA3T,EAAA2T,EAAA9M,IAAA8M,GAAAjuB,KAAAkuB,aAAAtwB,EAAAqwB,IACA,OACAluB,UACAua,EAAA9Z,QAAAwW,KAAA1b,aAIA,OAAA0E,KAAAkuB,aAAAtwB,EAAAqwB,GAEAluB,aAAAnC,EAAAqwB,GACA,MAAAE,EAAAnuB,KAAAytB,aAAA10B,IAAA6E,IAAA,GAGA,OAFAuwB,EAAA/mB,KAAA6mB,GACAjuB,KAAAytB,aAAAjqB,IAAA5F,EAAAuwB,GACA,CACA7yB,QAAA,KACA,MAAA6yB,EAAAnuB,KAAAytB,aAAA10B,IAAA6E,IAAA,GACAuwB,EAAAje,OAAAie,EAAA5zB,QAAA0zB,GAAA","file":"three-column-layout-7.0.1-pre.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 269);\n","const globalObject = (function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof window !== 'undefined' && window.navigator.userAgent.indexOf('jsdom') > -1) {\n        return window;\n    }\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n})();\nexport default globalObject;\n//# sourceMappingURL=global.mjs.map","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nimport global from '../shim/global';\nimport has from '../core/has';\nimport WeakMap from '../shim/WeakMap';\nimport Set from '../shim/Set';\nimport Map from '../shim/Map';\nimport { flat } from '../shim/array';\nimport { Registry, isWidget, isWidgetBaseConstructor, isWidgetFunction, isWNodeFactory } from './Registry';\nimport { auto } from './diff';\nimport RegistryHandler from './RegistryHandler';\nconst EMPTY_ARRAY = [];\nconst nodeOperations = ['focus', 'blur', 'scrollIntoView', 'click'];\nconst NAMESPACE_W3 = 'http://www.w3.org/';\nconst NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\nconst NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\nconst WNODE = '__WNODE_TYPE';\nconst VNODE = '__VNODE_TYPE';\nconst DOMVNODE = '__DOMVNODE_TYPE';\n// @ts-ignore\nconst scope = typeof __DOJO_SCOPE === 'string' ? __DOJO_SCOPE : 'dojo_scope';\nif (!global[scope]) {\n    global[scope] = {};\n}\nexport function setRendering(value) {\n    global[scope].rendering = value;\n}\nexport function incrementBlockCount() {\n    const blocksPending = global[scope].blocksPending || 0;\n    global[scope].blocksPending = blocksPending + 1;\n}\nexport function decrementBlockCount() {\n    const blocksPending = global[scope].blocksPending || 0;\n    global[scope].blocksPending = blocksPending - 1;\n}\nexport function isTextNode(item) {\n    return item && item.nodeType === 3;\n}\nfunction isLazyDefine(item) {\n    return Boolean(item && item.label);\n}\nfunction isWNodeWrapper(child) {\n    return child && isWNode(child.node);\n}\nfunction isVNodeWrapper(child) {\n    return !!child && isVNode(child.node);\n}\nfunction isVirtualWrapper(child) {\n    return isVNodeWrapper(child) && child.node.tag === 'virtual';\n}\nfunction isBodyWrapper(wrapper) {\n    return isVNodeWrapper(wrapper) && wrapper.node.tag === 'body';\n}\nfunction isAttachApplication(value) {\n    return !!value.type;\n}\nexport function isWNode(child) {\n    return Boolean(child && child !== true && typeof child !== 'string' && child.type === WNODE);\n}\nexport function isVNode(child) {\n    return Boolean(child && child !== true && typeof child !== 'string' && (child.type === VNODE || child.type === DOMVNODE));\n}\nexport function isDomVNode(child) {\n    return Boolean(child && child !== true && typeof child !== 'string' && child.type === DOMVNODE);\n}\nexport function isElementNode(value) {\n    return !!value.tagName;\n}\nfunction toTextVNode(data) {\n    return {\n        tag: '',\n        properties: {},\n        children: undefined,\n        text: `${data}`,\n        type: VNODE\n    };\n}\nfunction updateAttributes(domNode, previousAttributes, attributes, namespace) {\n    const attrNames = Object.keys(attributes);\n    const attrCount = attrNames.length;\n    for (let i = 0; i < attrCount; i++) {\n        const attrName = attrNames[i];\n        const attrValue = attributes[attrName];\n        const previousAttrValue = previousAttributes[attrName];\n        if (attrValue !== previousAttrValue) {\n            updateAttribute(domNode, attrName, attrValue, namespace);\n        }\n    }\n}\nexport function w(widgetConstructorOrNode, properties, children) {\n    if (properties.__children__) {\n        delete properties.__children__;\n    }\n    if (isWNodeFactory(widgetConstructorOrNode)) {\n        return widgetConstructorOrNode(properties, children);\n    }\n    if (isWNode(widgetConstructorOrNode)) {\n        properties = Object.assign({}, widgetConstructorOrNode.properties, properties);\n        children = children ? children : widgetConstructorOrNode.children;\n        widgetConstructorOrNode = widgetConstructorOrNode.widgetConstructor;\n    }\n    return {\n        children: children || [],\n        widgetConstructor: widgetConstructorOrNode,\n        properties,\n        type: WNODE\n    };\n}\nexport function v(tag, propertiesOrChildren = {}, children = undefined) {\n    let properties = propertiesOrChildren;\n    let deferredPropertiesCallback;\n    if (typeof tag.tag === 'function') {\n        return tag.tag(properties, children);\n    }\n    if (Array.isArray(propertiesOrChildren)) {\n        children = propertiesOrChildren;\n        properties = {};\n    }\n    if (typeof properties === 'function') {\n        deferredPropertiesCallback = properties;\n        properties = {};\n    }\n    if (isVNode(tag)) {\n        let { classes = [], styles = {} } = properties, newProperties = __rest(properties, [\"classes\", \"styles\"]);\n        let _a = tag.properties, { classes: nodeClasses = [], styles: nodeStyles = {} } = _a, nodeProperties = __rest(_a, [\"classes\", \"styles\"]);\n        nodeClasses = Array.isArray(nodeClasses) ? nodeClasses : [nodeClasses];\n        classes = Array.isArray(classes) ? classes : [classes];\n        styles = Object.assign({}, nodeStyles, styles);\n        properties = Object.assign({}, nodeProperties, newProperties, { classes: [...nodeClasses, ...classes], styles });\n        children = children ? children : tag.children;\n        tag = tag.tag;\n    }\n    return {\n        tag,\n        deferredPropertiesCallback,\n        children,\n        properties,\n        type: VNODE\n    };\n}\n/**\n * Create a VNode for an existing DOM Node.\n */\nexport function dom({ node, attrs = {}, props = {}, on = {}, diffType = 'none', onAttach }, children) {\n    return {\n        tag: isElementNode(node) ? node.tagName.toLowerCase() : '',\n        properties: props,\n        attributes: attrs,\n        events: on,\n        children,\n        type: DOMVNODE,\n        domNode: node,\n        text: isElementNode(node) ? undefined : node.data,\n        diffType,\n        onAttach\n    };\n}\nexport const REGISTRY_ITEM = '__registry_item';\nexport class FromRegistry {\n    constructor() {\n        /* tslint:disable-next-line:variable-name */\n        this.__properties__ = {};\n    }\n}\nFromRegistry.type = REGISTRY_ITEM;\nexport function fromRegistry(tag) {\n    var _a;\n    return _a = class extends FromRegistry {\n            constructor() {\n                super(...arguments);\n                this.properties = {};\n                this.name = tag;\n            }\n        },\n        _a.type = REGISTRY_ITEM,\n        _a;\n}\nexport function tsx(tag, properties = {}, ...children) {\n    children = flat(children, Infinity);\n    properties = properties === null ? {} : properties;\n    if (typeof tag === 'string') {\n        return v(tag, properties, children);\n    }\n    else if (tag.type === 'registry' && properties.__autoRegistryItem) {\n        const name = properties.__autoRegistryItem;\n        delete properties.__autoRegistryItem;\n        return w(name, properties, children);\n    }\n    else if (tag.type === REGISTRY_ITEM) {\n        const registryItem = new tag();\n        return w(registryItem.name, properties, children);\n    }\n    else {\n        return w(tag, properties, children);\n    }\n}\nexport function propertiesDiff(current, next, invalidator, ignoreProperties) {\n    const propertyNames = [...Object.keys(current), ...Object.keys(next)];\n    for (let i = 0; i < propertyNames.length; i++) {\n        if (ignoreProperties.indexOf(propertyNames[i]) > -1) {\n            continue;\n        }\n        const result = auto(current[propertyNames[i]], next[propertyNames[i]]);\n        if (result.changed) {\n            invalidator();\n            break;\n        }\n        ignoreProperties.push(propertyNames[i]);\n    }\n}\nfunction buildPreviousProperties(domNode, current) {\n    const { node: { diffType, properties, attributes } } = current;\n    if (!diffType || diffType === 'vdom') {\n        return {\n            properties: current.deferredProperties\n                ? Object.assign({}, current.deferredProperties, current.node.properties) : current.node.properties,\n            attributes: current.node.attributes,\n            events: current.node.events\n        };\n    }\n    else if (diffType === 'none') {\n        return {\n            properties: {},\n            attributes: current.node.attributes ? {} : undefined,\n            events: current.node.events\n        };\n    }\n    let newProperties = {\n        properties: {}\n    };\n    if (attributes) {\n        newProperties.attributes = {};\n        newProperties.events = current.node.events;\n        Object.keys(properties).forEach((propName) => {\n            newProperties.properties[propName] = domNode[propName];\n        });\n        Object.keys(attributes).forEach((attrName) => {\n            newProperties.attributes[attrName] = domNode.getAttribute(attrName);\n        });\n        return newProperties;\n    }\n    newProperties.properties = Object.keys(properties).reduce((props, property) => {\n        props[property] = domNode.getAttribute(property) || domNode[property];\n        return props;\n    }, {});\n    return newProperties;\n}\nfunction checkDistinguishable(wrappers, index, parentWNodeWrapper) {\n    const wrapperToCheck = wrappers[index];\n    if (isVNodeWrapper(wrapperToCheck) && !wrapperToCheck.node.tag) {\n        return;\n    }\n    const { key } = wrapperToCheck.node.properties;\n    let parentName = 'unknown';\n    if (parentWNodeWrapper) {\n        const { node: { widgetConstructor } } = parentWNodeWrapper;\n        parentName = widgetConstructor.name || 'unknown';\n    }\n    if (key === undefined || key === null) {\n        for (let i = 0; i < wrappers.length; i++) {\n            if (i !== index) {\n                const wrapper = wrappers[i];\n                if (same(wrapper, wrapperToCheck)) {\n                    let nodeIdentifier;\n                    if (isWNodeWrapper(wrapper)) {\n                        nodeIdentifier = wrapper.node.widgetConstructor.name || 'unknown';\n                    }\n                    else {\n                        nodeIdentifier = wrapper.node.tag;\n                    }\n                    console.warn(`A widget (${parentName}) has had a child added or removed, but they were not able to uniquely identified. It is recommended to provide a unique 'key' property when using the same widget or element (${nodeIdentifier}) multiple times as siblings`);\n                    break;\n                }\n            }\n        }\n    }\n}\nfunction same(dnode1, dnode2) {\n    if (isVNodeWrapper(dnode1) && isVNodeWrapper(dnode2)) {\n        if (isDomVNode(dnode1.node) && isDomVNode(dnode2.node)) {\n            if (dnode1.node.domNode !== dnode2.node.domNode) {\n                return false;\n            }\n        }\n        if (dnode1.node.tag !== dnode2.node.tag) {\n            return false;\n        }\n        if (dnode1.node.properties.key !== dnode2.node.properties.key) {\n            return false;\n        }\n        return true;\n    }\n    else if (isWNodeWrapper(dnode1) && isWNodeWrapper(dnode2)) {\n        const widgetConstructor1 = dnode1.registryItem || dnode1.node.widgetConstructor;\n        const widgetConstructor2 = dnode2.registryItem || dnode2.node.widgetConstructor;\n        const { node: { properties: props1 } } = dnode1;\n        const { node: { properties: props2 } } = dnode2;\n        if (dnode1.instance === undefined && typeof widgetConstructor2 === 'string') {\n            return false;\n        }\n        if (widgetConstructor1 !== widgetConstructor2) {\n            return false;\n        }\n        if (props1.key !== props2.key) {\n            return false;\n        }\n        if (!(widgetConstructor1.keys || []).every((key) => props1[key] === props2[key])) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction findIndexOfChild(children, sameAs, start) {\n    for (let i = start; i < children.length; i++) {\n        if (same(children[i], sameAs)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction createClassPropValue(classes = []) {\n    let classNames = '';\n    if (Array.isArray(classes)) {\n        for (let i = 0; i < classes.length; i++) {\n            let className = classes[i];\n            if (className && className !== true) {\n                classNames = classNames ? `${classNames} ${className}` : className;\n            }\n        }\n        return classNames;\n    }\n    if (classes && classes !== true) {\n        classNames = classes;\n    }\n    return classNames;\n}\nfunction updateAttribute(domNode, attrName, attrValue, namespace) {\n    if (namespace === NAMESPACE_SVG && attrName === 'href' && attrValue) {\n        domNode.setAttributeNS(NAMESPACE_XLINK, attrName, attrValue);\n    }\n    else if ((attrName === 'role' && attrValue === '') || attrValue === undefined) {\n        domNode.removeAttribute(attrName);\n    }\n    else {\n        domNode.setAttribute(attrName, attrValue);\n    }\n}\nfunction arrayFrom(arr) {\n    return Array.prototype.slice.call(arr);\n}\nfunction createFactory(callback, middlewares, key) {\n    const factory = (properties, children) => {\n        if (properties) {\n            const result = w(callback, properties, children);\n            callback.isWidget = true;\n            callback.middlewares = middlewares;\n            return result;\n        }\n        return {\n            middlewares,\n            callback\n        };\n    };\n    const keys = Object.keys(middlewares).reduce((keys, middlewareName) => {\n        const middleware = middlewares[middlewareName];\n        if (middleware.keys) {\n            keys = [...keys, ...middleware.keys];\n        }\n        return keys;\n    }, key ? [key] : []);\n    callback.keys = keys;\n    factory.keys = keys;\n    factory.isFactory = true;\n    return factory;\n}\nexport function create(middlewares = {}) {\n    function properties() {\n        function returns(callback) {\n            return createFactory(callback, middlewares);\n        }\n        function key(key) {\n            function returns(callback) {\n                return createFactory(callback, middlewares, key);\n            }\n            return returns;\n        }\n        function children() {\n            function returns(callback) {\n                return createFactory(callback, middlewares);\n            }\n            function key(key) {\n                function returns(callback) {\n                    return createFactory(callback, middlewares, key);\n                }\n                return returns;\n            }\n            returns.key = key;\n            return returns;\n        }\n        returns.children = children;\n        returns.key = key;\n        return returns;\n    }\n    function children() {\n        function properties() {\n            function returns(callback) {\n                return createFactory(callback, middlewares);\n            }\n            function key(key) {\n                function returns(callback) {\n                    return createFactory(callback, middlewares, key);\n                }\n                return returns;\n            }\n            returns.key = key;\n            return returns;\n        }\n        function returns(callback) {\n            return createFactory(callback, middlewares);\n        }\n        returns.properties = properties;\n        return returns;\n    }\n    function returns(callback) {\n        return createFactory(callback, middlewares);\n    }\n    returns.children = children;\n    returns.properties = properties;\n    return returns;\n}\nconst factory = create();\nfunction wrapNodes(renderer) {\n    const result = renderer();\n    const isWNodeWrapper = isWNode(result);\n    const callback = () => {\n        return result;\n    };\n    callback.isWNodeWrapper = isWNodeWrapper;\n    return factory(callback);\n}\nexport const widgetInstanceMap = new WeakMap();\nconst widgetMetaMap = new Map();\nconst requestedDomNodes = new Set();\nlet wrapperId = 0;\nlet metaId = 0;\nfunction addNodeToMap(id, key, node) {\n    const widgetMeta = widgetMetaMap.get(id);\n    if (widgetMeta) {\n        widgetMeta.nodeMap = widgetMeta.nodeMap || new Map();\n        widgetMeta.nodeMap.set(key, node);\n        if (requestedDomNodes.has(`${id}-${key}`)) {\n            widgetMeta.invalidator();\n            requestedDomNodes.delete(`${id}-${key}`);\n        }\n    }\n}\nfunction destroyHandles(meta) {\n    const { destroyMap, middlewareIds } = meta;\n    if (!destroyMap) {\n        return;\n    }\n    for (let i = 0; i < middlewareIds.length; i++) {\n        const id = middlewareIds[i];\n        const destroy = destroyMap.get(id);\n        destroy && destroy();\n        destroyMap.delete(id);\n        if (destroyMap.size === 0) {\n            break;\n        }\n    }\n    destroyMap.clear();\n}\nfunction runDiffs(meta, current, next) {\n    let customProperties = {};\n    meta.customDiffMap = meta.customDiffMap || new Map();\n    if (meta.customDiffMap.size) {\n        meta.customDiffMap.forEach((diffMap) => {\n            diffMap.forEach((diff, propertyName) => {\n                const result = diff(Object.assign({}, current), Object.assign({}, next));\n                if (result) {\n                    customProperties[propertyName] = result;\n                }\n            });\n        });\n    }\n    return customProperties;\n}\nexport const invalidator = factory(({ id }) => {\n    const [widgetId] = id.split('-');\n    return () => {\n        const widgetMeta = widgetMetaMap.get(widgetId);\n        if (widgetMeta) {\n            return widgetMeta.invalidator();\n        }\n    };\n});\nexport const node = factory(({ id }) => {\n    return {\n        get(key) {\n            const [widgetId] = id.split('-');\n            const widgetMeta = widgetMetaMap.get(widgetId);\n            if (widgetMeta) {\n                widgetMeta.nodeMap = widgetMeta.nodeMap || new Map();\n                const mountNode = widgetMeta.mountNode;\n                const node = widgetMeta.nodeMap.get(key);\n                if (node &&\n                    (mountNode.contains(node) ||\n                        (global.document.body !== mountNode && global.document.body.contains(node)))) {\n                    return node;\n                }\n                requestedDomNodes.add(`${widgetId}-${key}`);\n            }\n            return null;\n        }\n    };\n});\nexport const diffProperty = factory(({ id }) => {\n    function callback(propertyName, propertiesOrDiff, diff) {\n        const [widgetId] = id.split('-');\n        const widgetMeta = widgetMetaMap.get(widgetId);\n        if (!diff) {\n            diff = propertiesOrDiff;\n        }\n        if (widgetMeta) {\n            widgetMeta.customDiffMap = widgetMeta.customDiffMap || new Map();\n            widgetMeta.customDiffProperties = widgetMeta.customDiffProperties || new Set();\n            const propertyDiffMap = widgetMeta.customDiffMap.get(id) || new Map();\n            if (!propertyDiffMap.has(propertyName)) {\n                const result = diff({}, widgetMeta.originalProperties);\n                if (result !== undefined) {\n                    if (has('dojo-debug')) {\n                        if (widgetMeta.propertiesCalled) {\n                            console.warn(`Calling \"propertyDiff\" middleware after accessing properties in \"${widgetMeta.widgetName}\", can result in referencing stale properties.`);\n                        }\n                    }\n                    widgetMeta.properties = Object.assign({}, widgetMeta.properties, { [propertyName]: result });\n                }\n                propertyDiffMap.set(propertyName, diff);\n                widgetMeta.customDiffProperties.add(propertyName);\n            }\n            widgetMeta.customDiffMap.set(id, propertyDiffMap);\n        }\n    }\n    return callback;\n});\nexport const destroy = factory(({ id }) => {\n    return (destroyFunction) => {\n        const [widgetId] = id.split('-');\n        const widgetMeta = widgetMetaMap.get(widgetId);\n        if (widgetMeta) {\n            widgetMeta.destroyMap = widgetMeta.destroyMap || new Map();\n            if (!widgetMeta.destroyMap.has(id)) {\n                widgetMeta.destroyMap.set(id, destroyFunction);\n            }\n        }\n    };\n});\nexport const getRegistry = factory(({ id }) => {\n    const [widgetId] = id.split('-');\n    return () => {\n        const widgetMeta = widgetMetaMap.get(widgetId);\n        if (widgetMeta) {\n            if (!widgetMeta.registryHandler) {\n                widgetMeta.registryHandler = new RegistryHandler();\n                widgetMeta.registryHandler.base = widgetMeta.registry;\n                widgetMeta.registryHandler.on('invalidate', widgetMeta.invalidator);\n            }\n            widgetMeta.registryHandler = widgetMeta.registryHandler || new RegistryHandler();\n            return widgetMeta.registryHandler;\n        }\n        return null;\n    };\n});\nexport const defer = factory(({ id }) => {\n    const [widgetId] = id.split('-');\n    let isDeferred = false;\n    return {\n        pause() {\n            const widgetMeta = widgetMetaMap.get(widgetId);\n            if (!isDeferred && widgetMeta) {\n                widgetMeta.deferRefs = widgetMeta.deferRefs + 1;\n                isDeferred = true;\n            }\n        },\n        resume() {\n            const widgetMeta = widgetMetaMap.get(widgetId);\n            if (isDeferred && widgetMeta) {\n                widgetMeta.deferRefs = widgetMeta.deferRefs - 1;\n                isDeferred = false;\n            }\n        }\n    };\n});\nfunction wrapFunctionProperties(id, properties) {\n    const props = {};\n    const propertyNames = Object.keys(properties);\n    for (let i = 0; i < propertyNames.length; i++) {\n        const propertyName = propertyNames[i];\n        if (typeof properties[propertyName] === 'function') {\n            props[propertyName] = function WrappedProperty(...args) {\n                const widgetMeta = widgetMetaMap.get(id);\n                if (widgetMeta) {\n                    return widgetMeta.originalProperties[propertyName](...args);\n                }\n                return properties[propertyName](...args);\n            };\n            props[propertyName].unwrap = () => {\n                const widgetMeta = widgetMetaMap.get(id);\n                if (widgetMeta) {\n                    return widgetMeta.originalProperties[propertyName];\n                }\n                return properties[propertyName];\n            };\n        }\n        else {\n            props[propertyName] = properties[propertyName];\n        }\n    }\n    return props;\n}\nexport function renderer(renderer) {\n    let _mountOptions = {\n        sync: false,\n        merge: true,\n        transition: undefined,\n        domNode: global.document.body,\n        registry: new Registry()\n    };\n    let _invalidationQueue = [];\n    let _processQueue = [];\n    let _deferredProcessQueue = [];\n    let _applicationQueue = [];\n    let _eventMap = new WeakMap();\n    let _idToWrapperMap = new Map();\n    let _wrapperSiblingMap = new WeakMap();\n    let _idToChildrenWrappers = new Map();\n    let _insertBeforeMap = new WeakMap();\n    let _nodeToWrapperMap = new WeakMap();\n    let _renderScheduled;\n    let _deferredRenderCallbacks = [];\n    let parentInvalidate;\n    let _allMergedNodes = [];\n    let _appWrapperId;\n    let _deferredProcessIds = new Map();\n    function nodeOperation(propName, propValue, previousValue, domNode) {\n        let result = propValue && !previousValue;\n        if (typeof propValue === 'function') {\n            result = propValue();\n        }\n        if (result === true) {\n            _deferredRenderCallbacks.push(() => {\n                domNode[propName]();\n            });\n        }\n    }\n    function updateEvent(domNode, eventName, currentValue, previousValue) {\n        if (previousValue) {\n            const previousEvent = _eventMap.get(previousValue);\n            previousEvent && domNode.removeEventListener(eventName, previousEvent);\n        }\n        let callback = currentValue;\n        if (eventName === 'input') {\n            callback = function (evt) {\n                currentValue.call(this, evt);\n                evt.target['oninput-value'] = evt.target.value;\n            };\n        }\n        domNode.addEventListener(eventName, callback);\n        _eventMap.set(currentValue, callback);\n    }\n    function removeOrphanedEvents(domNode, previousProperties, properties, onlyEvents = false) {\n        Object.keys(previousProperties).forEach((propName) => {\n            const isEvent = propName.substr(0, 2) === 'on' || onlyEvents;\n            const eventName = onlyEvents ? propName : propName.substr(2);\n            if (isEvent && !properties[propName]) {\n                const eventCallback = _eventMap.get(previousProperties[propName]);\n                if (eventCallback) {\n                    domNode.removeEventListener(eventName, eventCallback);\n                }\n            }\n        });\n    }\n    function resolveRegistryItem(wrapper, instance, id) {\n        if (!isWidget(wrapper.node.widgetConstructor)) {\n            const owningNode = _nodeToWrapperMap.get(wrapper.node);\n            if (owningNode) {\n                if (owningNode.instance) {\n                    instance = owningNode.instance;\n                }\n                else {\n                    id = owningNode.id;\n                }\n            }\n            let registry;\n            if (instance) {\n                const instanceData = widgetInstanceMap.get(instance);\n                if (instanceData) {\n                    registry = instanceData.registry;\n                }\n            }\n            else if (id !== undefined) {\n                const widgetMeta = widgetMetaMap.get(id);\n                if (widgetMeta) {\n                    if (!widgetMeta.registryHandler) {\n                        widgetMeta.registryHandler = new RegistryHandler();\n                        widgetMeta.registryHandler.base = widgetMeta.registry;\n                        widgetMeta.registryHandler.on('invalidate', widgetMeta.invalidator);\n                    }\n                    registry = widgetMeta.registryHandler;\n                }\n            }\n            if (registry) {\n                let registryLabel;\n                if (isLazyDefine(wrapper.node.widgetConstructor)) {\n                    const { label, registryItem } = wrapper.node.widgetConstructor;\n                    if (!registry.has(label)) {\n                        registry.define(label, registryItem);\n                    }\n                    registryLabel = label;\n                }\n                else {\n                    registryLabel = wrapper.node.widgetConstructor;\n                }\n                let item = registry.get(registryLabel);\n                if (isWNodeFactory(item)) {\n                    const node = item(wrapper.node.properties, wrapper.node.children);\n                    if (isWidgetFunction(node.widgetConstructor)) {\n                        wrapper.registryItem = node.widgetConstructor;\n                    }\n                }\n                else {\n                    wrapper.registryItem = item;\n                }\n            }\n        }\n    }\n    function mapNodeToInstance(nodes, wrapper) {\n        while (nodes.length) {\n            let node = nodes.pop();\n            if (isWNode(node) || isVNode(node)) {\n                if (!_nodeToWrapperMap.has(node)) {\n                    _nodeToWrapperMap.set(node, wrapper);\n                    if (node.children && node.children.length) {\n                        nodes = [...nodes, ...node.children];\n                    }\n                }\n            }\n        }\n    }\n    function renderedToWrapper(rendered, parent, currentParent) {\n        const { requiresInsertBefore, hasPreviousSiblings, namespace, depth } = parent;\n        const wrappedRendered = [];\n        const hasParentWNode = isWNodeWrapper(parent);\n        const hasVirtualParentNode = isVirtualWrapper(parent);\n        const currentParentChildren = (isVNodeWrapper(currentParent) && _idToChildrenWrappers.get(currentParent.id)) || [];\n        const hasCurrentParentChildren = currentParentChildren.length > 0;\n        const insertBefore = ((requiresInsertBefore || hasPreviousSiblings !== false) && (hasParentWNode || hasVirtualParentNode)) ||\n            (hasCurrentParentChildren && rendered.length > 1);\n        let previousItem;\n        if (isWNodeWrapper(parent) && rendered.length) {\n            mapNodeToInstance([...rendered], parent);\n        }\n        for (let i = 0; i < rendered.length; i++) {\n            let renderedItem = rendered[i];\n            if (!renderedItem || renderedItem === true) {\n                continue;\n            }\n            if (typeof renderedItem === 'string') {\n                renderedItem = toTextVNode(renderedItem);\n            }\n            const owningNode = _nodeToWrapperMap.get(renderedItem);\n            const wrapper = {\n                node: renderedItem,\n                depth: depth + 1,\n                order: i,\n                parentId: parent.id,\n                requiresInsertBefore: insertBefore,\n                hasParentWNode,\n                namespace: namespace\n            };\n            if (isVNode(renderedItem)) {\n                if (renderedItem.deferredPropertiesCallback) {\n                    wrapper.deferredProperties = renderedItem.deferredPropertiesCallback(false);\n                }\n                if (renderedItem.properties.exitAnimation) {\n                    parent.hasAnimations = true;\n                    let nextParent = _idToWrapperMap.get(parent.parentId);\n                    while (nextParent) {\n                        if (nextParent.hasAnimations) {\n                            break;\n                        }\n                        nextParent.hasAnimations = true;\n                        nextParent = _idToWrapperMap.get(nextParent.parentId);\n                    }\n                }\n            }\n            if (owningNode) {\n                wrapper.owningId = owningNode.id;\n            }\n            if (isWNode(renderedItem)) {\n                resolveRegistryItem(wrapper, parent.instance, parent.id);\n            }\n            if (previousItem) {\n                _wrapperSiblingMap.set(previousItem, wrapper);\n            }\n            wrappedRendered.push(wrapper);\n            previousItem = wrapper;\n        }\n        return wrappedRendered;\n    }\n    function findParentDomNode(currentNode) {\n        let parentDomNode;\n        let parentWrapper = _idToWrapperMap.get(currentNode.parentId);\n        while (!parentDomNode && parentWrapper) {\n            if (!parentDomNode &&\n                isVNodeWrapper(parentWrapper) &&\n                !isVirtualWrapper(parentWrapper) &&\n                parentWrapper.domNode) {\n                parentDomNode = parentWrapper.domNode;\n            }\n            parentWrapper = _idToWrapperMap.get(parentWrapper.parentId);\n        }\n        return parentDomNode;\n    }\n    function runDeferredProperties(next) {\n        const { deferredPropertiesCallback } = next.node;\n        if (deferredPropertiesCallback) {\n            const properties = next.node.properties;\n            _deferredRenderCallbacks.push(() => {\n                if (_idToWrapperMap.has(next.owningId)) {\n                    const deferredProperties = next.deferredProperties;\n                    next.deferredProperties = deferredPropertiesCallback(true);\n                    processProperties(next, {\n                        properties: Object.assign({}, deferredProperties, properties)\n                    });\n                }\n            });\n        }\n    }\n    function findInsertBefore(next) {\n        let insertBefore = null;\n        let searchNode = next;\n        while (!insertBefore) {\n            const nextSibling = _wrapperSiblingMap.get(searchNode);\n            if (nextSibling) {\n                let domNode = nextSibling.domNode;\n                if (isWNodeWrapper(nextSibling) || isVirtualWrapper(nextSibling)) {\n                    if (!nextSibling.childDomWrapperId) {\n                        nextSibling.childDomWrapperId = findDomNodeOnParentWrapper(nextSibling.id);\n                    }\n                    if (nextSibling.childDomWrapperId) {\n                        const childWrapper = _idToWrapperMap.get(nextSibling.childDomWrapperId);\n                        if (childWrapper && !isBodyWrapper(childWrapper)) {\n                            domNode = childWrapper.domNode;\n                        }\n                    }\n                }\n                if (domNode && domNode.parentNode) {\n                    insertBefore = domNode;\n                    break;\n                }\n                searchNode = nextSibling;\n                continue;\n            }\n            searchNode = searchNode && _idToWrapperMap.get(searchNode.parentId);\n            if (!searchNode || (isVNodeWrapper(searchNode) && !isVirtualWrapper(searchNode))) {\n                break;\n            }\n        }\n        return insertBefore;\n    }\n    function setValue(domNode, propValue, previousValue) {\n        const domValue = domNode.value;\n        const onInputValue = domNode['oninput-value'];\n        const onSelectValue = domNode['select-value'];\n        if (onSelectValue && domValue !== onSelectValue) {\n            domNode.value = onSelectValue;\n            if (domNode.value === onSelectValue) {\n                domNode['select-value'] = undefined;\n            }\n        }\n        else if ((onInputValue && domValue === onInputValue) || propValue !== previousValue) {\n            domNode.value = propValue;\n            domNode['oninput-value'] = undefined;\n        }\n    }\n    function setProperties(domNode, currentProperties = {}, nextWrapper, includesEventsAndAttributes = true) {\n        const properties = nextWrapper.deferredProperties\n            ? Object.assign({}, nextWrapper.deferredProperties, nextWrapper.node.properties) : nextWrapper.node.properties;\n        const propNames = Object.keys(properties);\n        const propCount = propNames.length;\n        if (propNames.indexOf('classes') === -1 && currentProperties.classes) {\n            domNode.removeAttribute('class');\n        }\n        includesEventsAndAttributes && removeOrphanedEvents(domNode, currentProperties, properties);\n        for (let i = 0; i < propCount; i++) {\n            const propName = propNames[i];\n            let propValue = properties[propName];\n            const previousValue = currentProperties[propName];\n            if (propName === 'classes') {\n                const previousClassString = createClassPropValue(previousValue);\n                let currentClassString = createClassPropValue(propValue);\n                if (previousClassString !== currentClassString) {\n                    if (currentClassString) {\n                        if (nextWrapper.merged) {\n                            const domClasses = (domNode.getAttribute('class') || '').split(' ');\n                            for (let i = 0; i < domClasses.length; i++) {\n                                if (currentClassString.indexOf(domClasses[i]) === -1) {\n                                    currentClassString = `${domClasses[i]} ${currentClassString}`;\n                                }\n                            }\n                        }\n                        domNode.setAttribute('class', currentClassString);\n                    }\n                    else {\n                        domNode.removeAttribute('class');\n                    }\n                }\n            }\n            else if (nodeOperations.indexOf(propName) !== -1) {\n                nodeOperation(propName, propValue, previousValue, domNode);\n            }\n            else if (propName === 'styles') {\n                const styleNames = Object.keys(propValue);\n                const styleCount = styleNames.length;\n                for (let j = 0; j < styleCount; j++) {\n                    const styleName = styleNames[j];\n                    const newStyleValue = propValue[styleName];\n                    const oldStyleValue = previousValue && previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    domNode.style[styleName] = newStyleValue || '';\n                }\n            }\n            else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode.tagName === 'SELECT') {\n                        domNode['select-value'] = propValue;\n                    }\n                    setValue(domNode, propValue, previousValue);\n                }\n                else if (propName !== 'key' && propValue !== previousValue) {\n                    const type = typeof propValue;\n                    if (type === 'function' && propName.lastIndexOf('on', 0) === 0 && includesEventsAndAttributes) {\n                        updateEvent(domNode, propName.substr(2), propValue, previousValue);\n                    }\n                    else if (type === 'string' && propName !== 'innerHTML' && includesEventsAndAttributes) {\n                        updateAttribute(domNode, propName, propValue, nextWrapper.namespace);\n                    }\n                    else if (propName === 'scrollLeft' || propName === 'scrollTop') {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    else {\n                        domNode[propName] = propValue;\n                    }\n                }\n            }\n        }\n    }\n    function _createDeferredRenderCallback() {\n        const callbacks = _deferredRenderCallbacks;\n        _deferredRenderCallbacks = [];\n        if (callbacks.length) {\n            return () => {\n                let callback;\n                while ((callback = callbacks.shift())) {\n                    callback();\n                }\n            };\n        }\n    }\n    function _scheduleDeferredRenderCallbacks() {\n        const { sync } = _mountOptions;\n        const run = _createDeferredRenderCallback();\n        if (run) {\n            if (sync) {\n                run();\n            }\n            else {\n                let id;\n                id = global.requestAnimationFrame(() => {\n                    _deferredProcessIds.delete(id);\n                    run();\n                });\n                _deferredProcessIds.set(id, run);\n            }\n        }\n    }\n    function processProperties(next, previousProperties) {\n        if (next.node.attributes && next.node.events) {\n            updateAttributes(next.domNode, previousProperties.attributes || {}, next.node.attributes, next.namespace);\n            setProperties(next.domNode, previousProperties.properties, next, false);\n            const events = next.node.events || {};\n            if (previousProperties.events) {\n                removeOrphanedEvents(next.domNode, previousProperties.events || {}, next.node.events, true);\n            }\n            previousProperties.events = previousProperties.events || {};\n            Object.keys(events).forEach((event) => {\n                updateEvent(next.domNode, event, events[event], previousProperties.events[event]);\n            });\n        }\n        else {\n            setProperties(next.domNode, previousProperties.properties, next);\n        }\n    }\n    function unmount() {\n        _processQueue.push({\n            current: [_idToWrapperMap.get(_appWrapperId)],\n            next: [],\n            meta: {}\n        });\n        if (_renderScheduled) {\n            global.cancelAnimationFrame(_renderScheduled);\n        }\n        _runProcessQueue();\n        _runDomInstructionQueue();\n        _deferredProcessIds.forEach((callback, id) => {\n            global.cancelAnimationFrame(id);\n            callback();\n        });\n        const run = _createDeferredRenderCallback();\n        run && run();\n        _invalidationQueue = [];\n        _processQueue = [];\n        _deferredProcessQueue = [];\n        _applicationQueue = [];\n        _deferredRenderCallbacks = [];\n        _allMergedNodes = [];\n        _eventMap = new WeakMap();\n        _idToWrapperMap.clear();\n        _idToChildrenWrappers.clear();\n        _wrapperSiblingMap = new WeakMap();\n        _nodeToWrapperMap = new WeakMap();\n        _insertBeforeMap = undefined;\n    }\n    function mount(mountOptions = {}) {\n        let domNode = mountOptions.domNode;\n        if (!domNode) {\n            if (has('dojo-debug') && domNode === null) {\n                console.warn('Unable to find node to mount the application, defaulting to the document body.');\n            }\n            domNode = global.document.body;\n        }\n        _mountOptions = Object.assign({}, _mountOptions, mountOptions, { domNode });\n        const renderResult = wrapNodes(renderer)({}, []);\n        _appWrapperId = `${wrapperId++}`;\n        const nextWrapper = {\n            id: _appWrapperId,\n            node: renderResult,\n            order: 0,\n            depth: 1,\n            owningId: '-1',\n            parentId: '-1',\n            siblingId: '-1',\n            properties: {}\n        };\n        _idToWrapperMap.set('-1', {\n            id: `-1`,\n            depth: 0,\n            order: 0,\n            owningId: '',\n            domNode,\n            node: v('fake'),\n            parentId: '-1'\n        });\n        _processQueue.push({\n            current: [],\n            next: [nextWrapper],\n            meta: { mergeNodes: arrayFrom(domNode.childNodes) }\n        });\n        _runProcessQueue();\n        _runDomInstructionQueue();\n        _cleanUpMergedNodes();\n        _insertBeforeMap = undefined;\n        _scheduleDeferredRenderCallbacks();\n        if (!_renderScheduled) {\n            setRendering(false);\n        }\n    }\n    function invalidate() {\n        parentInvalidate && parentInvalidate();\n    }\n    function _schedule() {\n        const { sync } = _mountOptions;\n        if (sync) {\n            _runInvalidationQueue();\n        }\n        else if (!_renderScheduled) {\n            setRendering(true);\n            _renderScheduled = global.requestAnimationFrame(() => {\n                _runInvalidationQueue();\n            });\n        }\n    }\n    function getWNodeWrapper(id) {\n        const wrapper = _idToWrapperMap.get(id);\n        if (wrapper && isWNodeWrapper(wrapper)) {\n            return wrapper;\n        }\n    }\n    function _runInvalidationQueue() {\n        _renderScheduled = undefined;\n        let invalidationQueue = [..._invalidationQueue];\n        const previouslyRendered = [];\n        _invalidationQueue = [];\n        invalidationQueue.sort((a, b) => {\n            let result = b.depth - a.depth;\n            if (result === 0) {\n                result = b.order - a.order;\n            }\n            return result;\n        });\n        if (_deferredProcessQueue.length) {\n            _processQueue = [..._deferredProcessQueue];\n            _deferredProcessQueue = [];\n            _runProcessQueue();\n            if (_deferredProcessQueue.length) {\n                _invalidationQueue = [...invalidationQueue];\n                invalidationQueue = [];\n            }\n        }\n        let item;\n        while ((item = invalidationQueue.pop())) {\n            let { id } = item;\n            const current = getWNodeWrapper(id);\n            if (!current || previouslyRendered.indexOf(id) !== -1 || !_idToWrapperMap.has(current.parentId)) {\n                continue;\n            }\n            previouslyRendered.push(id);\n            const sibling = _wrapperSiblingMap.get(current);\n            const next = {\n                node: {\n                    type: WNODE,\n                    widgetConstructor: current.node.widgetConstructor,\n                    properties: current.properties || {},\n                    children: current.node.children || []\n                },\n                instance: current.instance,\n                id: current.id,\n                properties: current.properties,\n                depth: current.depth,\n                order: current.order,\n                owningId: current.owningId,\n                parentId: current.parentId,\n                registryItem: current.registryItem\n            };\n            sibling && _wrapperSiblingMap.set(next, sibling);\n            const result = _updateWidget({ current, next });\n            if (result && result.item) {\n                _processQueue.push(result.item);\n                _idToWrapperMap.set(id, next);\n                _runProcessQueue();\n            }\n        }\n        _runDomInstructionQueue();\n        _cleanUpMergedNodes();\n        _scheduleDeferredRenderCallbacks();\n        if (!_renderScheduled) {\n            setRendering(false);\n        }\n    }\n    function _cleanUpMergedNodes() {\n        if (_deferredProcessQueue.length === 0) {\n            let mergedNode;\n            while ((mergedNode = _allMergedNodes.pop())) {\n                mergedNode.parentNode && mergedNode.parentNode.removeChild(mergedNode);\n            }\n            _mountOptions.merge = false;\n        }\n    }\n    function _runProcessQueue() {\n        let item;\n        while ((item = _processQueue.pop())) {\n            if (isAttachApplication(item)) {\n                item.instance && _applicationQueue.push(item);\n            }\n            else {\n                const { current, next, meta } = item;\n                _process(current || EMPTY_ARRAY, next || EMPTY_ARRAY, meta);\n            }\n        }\n    }\n    function _runDomInstructionQueue() {\n        _applicationQueue.reverse();\n        let item;\n        while ((item = _applicationQueue.pop())) {\n            if (item.type === 'create') {\n                const { parentDomNode, next, next: { domNode, merged, requiresInsertBefore, node } } = item;\n                processProperties(next, { properties: {} });\n                runDeferredProperties(next);\n                if (!merged) {\n                    let insertBefore;\n                    if (requiresInsertBefore) {\n                        insertBefore = findInsertBefore(next);\n                    }\n                    else if (_insertBeforeMap) {\n                        insertBefore = _insertBeforeMap.get(next);\n                    }\n                    parentDomNode.insertBefore(domNode, insertBefore);\n                    if (isDomVNode(next.node) && next.node.onAttach) {\n                        next.node.onAttach();\n                    }\n                }\n                if (domNode.tagName === 'OPTION' && domNode.parentElement) {\n                    setValue(domNode.parentElement);\n                }\n                const { enterAnimation, enterAnimationActive } = node.properties;\n                if (_mountOptions.transition && enterAnimation && enterAnimation !== true) {\n                    _mountOptions.transition.enter(domNode, enterAnimation, enterAnimationActive);\n                }\n                const owningWrapper = _nodeToWrapperMap.get(next.node);\n                if (owningWrapper && node.properties.key != null) {\n                    if (owningWrapper.instance) {\n                        const instanceData = widgetInstanceMap.get(owningWrapper.instance);\n                        instanceData && instanceData.nodeHandler.add(domNode, `${node.properties.key}`);\n                    }\n                    else {\n                        addNodeToMap(owningWrapper.id, node.properties.key, domNode);\n                    }\n                }\n                item.next.inserted = true;\n            }\n            else if (item.type === 'update') {\n                const { next, next: { domNode }, current, current: { domNode: currentDomNode } } = item;\n                if (isTextNode(domNode) && isTextNode(currentDomNode) && domNode !== currentDomNode) {\n                    currentDomNode.parentNode && currentDomNode.parentNode.replaceChild(domNode, currentDomNode);\n                }\n                else {\n                    const previousProperties = buildPreviousProperties(domNode, current);\n                    processProperties(next, previousProperties);\n                    runDeferredProperties(next);\n                }\n            }\n            else if (item.type === 'delete') {\n                const { current } = item;\n                const { exitAnimation, exitAnimationActive } = current.node.properties;\n                if (_mountOptions.transition && exitAnimation && exitAnimation !== true) {\n                    _mountOptions.transition.exit(current.domNode, exitAnimation, exitAnimationActive);\n                }\n                else {\n                    current.domNode.parentNode.removeChild(current.domNode);\n                }\n            }\n            else if (item.type === 'attach') {\n                const { instance, attached } = item;\n                const instanceData = widgetInstanceMap.get(instance);\n                if (instanceData) {\n                    instanceData.nodeHandler.addRoot();\n                    attached && instanceData.onAttach();\n                }\n            }\n            else if (item.type === 'detach') {\n                if (item.current.instance) {\n                    const instanceData = widgetInstanceMap.get(item.current.instance);\n                    instanceData && instanceData.onDetach();\n                }\n                item.current.instance = undefined;\n            }\n        }\n        if (_deferredProcessQueue.length === 0) {\n            _nodeToWrapperMap = new WeakMap();\n        }\n    }\n    function _processMergeNodes(next, mergeNodes) {\n        const { merge } = _mountOptions;\n        if (merge && mergeNodes.length) {\n            if (isVNodeWrapper(next)) {\n                let { node: { tag } } = next;\n                for (let i = 0; i < mergeNodes.length; i++) {\n                    const domElement = mergeNodes[i];\n                    const tagName = domElement.tagName || '';\n                    if (tag.toUpperCase() === tagName.toUpperCase()) {\n                        const mergeNodeIndex = _allMergedNodes.indexOf(domElement);\n                        if (mergeNodeIndex !== -1) {\n                            _allMergedNodes.splice(mergeNodeIndex, 1);\n                        }\n                        mergeNodes.splice(i, 1);\n                        next.domNode = domElement;\n                        break;\n                    }\n                }\n            }\n            else {\n                next.mergeNodes = mergeNodes;\n            }\n        }\n    }\n    function distinguishableCheck(childNodes, index) {\n        const parentWNodeWrapper = getWNodeWrapper(childNodes[index].owningId);\n        checkDistinguishable(childNodes, index, parentWNodeWrapper);\n    }\n    function createKeyMap(wrappers) {\n        const keys = [];\n        for (let i = 0; i < wrappers.length; i++) {\n            const wrapper = wrappers[i];\n            if (wrapper.node.properties.key != null) {\n                keys.push(wrapper.node.properties.key);\n            }\n            else {\n                return false;\n            }\n        }\n        return keys;\n    }\n    function _process(current, next, meta = {}) {\n        let { mergeNodes = [], oldIndex = 0, newIndex = 0 } = meta;\n        const currentLength = current.length;\n        const nextLength = next.length;\n        const hasPreviousSiblings = currentLength > 1 || (currentLength > 0 && currentLength < nextLength);\n        let instructions = [];\n        let replace = false;\n        if (oldIndex === 0 && newIndex === 0 && currentLength) {\n            const currentKeys = createKeyMap(current);\n            if (currentKeys) {\n                const nextKeys = createKeyMap(next);\n                if (nextKeys) {\n                    for (let i = 0; i < currentKeys.length; i++) {\n                        if (nextKeys.indexOf(currentKeys[i]) !== -1) {\n                            instructions = [];\n                            replace = false;\n                            break;\n                        }\n                        replace = true;\n                        instructions.push({ current: current[i], next: undefined });\n                    }\n                }\n            }\n        }\n        if (replace || (currentLength === 0 && !_mountOptions.merge)) {\n            for (let i = 0; i < next.length; i++) {\n                instructions.push({ current: undefined, next: next[i] });\n            }\n        }\n        else {\n            if (newIndex < nextLength) {\n                let currentWrapper = oldIndex < currentLength ? current[oldIndex] : undefined;\n                const nextWrapper = next[newIndex];\n                nextWrapper.hasPreviousSiblings = hasPreviousSiblings;\n                _processMergeNodes(nextWrapper, mergeNodes);\n                if (currentWrapper && same(currentWrapper, nextWrapper)) {\n                    oldIndex++;\n                    newIndex++;\n                    if (isVNodeWrapper(currentWrapper) && isVNodeWrapper(nextWrapper)) {\n                        nextWrapper.inserted = currentWrapper.inserted;\n                    }\n                    instructions.push({ current: currentWrapper, next: nextWrapper });\n                }\n                else if (!currentWrapper || findIndexOfChild(current, nextWrapper, oldIndex + 1) === -1) {\n                    has('dojo-debug') && current.length && distinguishableCheck(next, newIndex);\n                    instructions.push({ current: undefined, next: nextWrapper });\n                    newIndex++;\n                }\n                else if (findIndexOfChild(next, currentWrapper, newIndex + 1) === -1) {\n                    has('dojo-debug') && distinguishableCheck(current, oldIndex);\n                    instructions.push({ current: currentWrapper, next: undefined });\n                    oldIndex++;\n                }\n                else {\n                    has('dojo-debug') && distinguishableCheck(next, newIndex);\n                    has('dojo-debug') && distinguishableCheck(current, oldIndex);\n                    instructions.push({ current: currentWrapper, next: undefined });\n                    instructions.push({ current: undefined, next: nextWrapper });\n                    oldIndex++;\n                    newIndex++;\n                }\n            }\n            if (newIndex < nextLength) {\n                _processQueue.push({ current, next, meta: { mergeNodes, oldIndex, newIndex } });\n            }\n            if (currentLength > oldIndex && newIndex >= nextLength) {\n                for (let i = oldIndex; i < currentLength; i++) {\n                    has('dojo-debug') && distinguishableCheck(current, i);\n                    instructions.push({ current: current[i], next: undefined });\n                }\n            }\n        }\n        for (let i = 0; i < instructions.length; i++) {\n            const result = _processOne(instructions[i]);\n            if (result === false) {\n                if (_mountOptions.merge && mergeNodes.length) {\n                    if (newIndex < nextLength) {\n                        _processQueue.pop();\n                    }\n                    _processQueue.push({ next, current, meta });\n                    _deferredProcessQueue = _processQueue;\n                    _processQueue = [];\n                    break;\n                }\n                continue;\n            }\n            const { widget, item, dom } = result;\n            widget && _processQueue.push(widget);\n            item && _processQueue.push(item);\n            dom && _applicationQueue.push(dom);\n        }\n    }\n    function _processOne({ current, next }) {\n        if (current !== next) {\n            if (!current && next) {\n                if (isVNodeWrapper(next)) {\n                    return _createDom({ next });\n                }\n                else {\n                    return _createWidget({ next });\n                }\n            }\n            else if (current && next) {\n                if (isVNodeWrapper(current) && isVNodeWrapper(next)) {\n                    return _updateDom({ current, next });\n                }\n                else if (isWNodeWrapper(current) && isWNodeWrapper(next)) {\n                    return _updateWidget({ current, next });\n                }\n            }\n            else if (current && !next) {\n                if (isVNodeWrapper(current)) {\n                    return _removeDom({ current });\n                }\n                else if (isWNodeWrapper(current)) {\n                    return _removeWidget({ current });\n                }\n            }\n        }\n        return {};\n    }\n    function createWidgetOptions(id, widgetId, middleware) {\n        return {\n            id,\n            properties: () => {\n                const widgetMeta = widgetMetaMap.get(widgetId);\n                if (widgetMeta) {\n                    widgetMeta.propertiesCalled = true;\n                    return Object.assign({}, widgetMeta.properties);\n                }\n                return {};\n            },\n            children: () => {\n                const widgetMeta = widgetMetaMap.get(widgetId);\n                if (widgetMeta) {\n                    return widgetMeta.children;\n                }\n                return [];\n            },\n            middleware\n        };\n    }\n    function resolveMiddleware(middlewares, id, middlewareIds = []) {\n        const keys = Object.keys(middlewares);\n        const results = {};\n        const uniqueId = `${id}-${metaId++}`;\n        for (let i = 0; i < keys.length; i++) {\n            const middleware = middlewares[keys[i]]();\n            const payload = createWidgetOptions(uniqueId, id);\n            if (middleware.middlewares) {\n                const { middlewares: resolvedMiddleware } = resolveMiddleware(middleware.middlewares, id, middlewareIds);\n                payload.middleware = resolvedMiddleware;\n                results[keys[i]] = middleware.callback(payload);\n            }\n            else {\n                results[keys[i]] = middleware.callback(payload);\n            }\n        }\n        middlewareIds.push(uniqueId);\n        return { middlewares: results, ids: middlewareIds };\n    }\n    function _createWidget({ next }) {\n        let { node: { widgetConstructor } } = next;\n        let { registry } = _mountOptions;\n        let Constructor = next.registryItem || widgetConstructor;\n        if (!isWidget(Constructor)) {\n            resolveRegistryItem(next);\n            if (!next.registryItem) {\n                return false;\n            }\n            Constructor = next.registryItem;\n        }\n        let rendered;\n        let invalidate;\n        next.properties = Object.assign({}, next.node.properties);\n        next.id = next.id || `${wrapperId++}`;\n        _idToWrapperMap.set(next.id, next);\n        const { id, depth, order } = next;\n        if (!isWidgetBaseConstructor(Constructor)) {\n            let widgetMeta = widgetMetaMap.get(id);\n            if (!widgetMeta) {\n                invalidate = () => {\n                    const widgetMeta = widgetMetaMap.get(id);\n                    if (widgetMeta) {\n                        widgetMeta.dirty = true;\n                        if (!widgetMeta.rendering && _idToWrapperMap.has(id)) {\n                            _invalidationQueue.push({ id, depth, order });\n                            _schedule();\n                        }\n                    }\n                };\n                widgetMeta = {\n                    widgetName: Constructor.name || 'unknown',\n                    mountNode: _mountOptions.domNode,\n                    dirty: false,\n                    invalidator: invalidate,\n                    properties: wrapFunctionProperties(id, next.node.properties),\n                    originalProperties: Object.assign({}, next.node.properties),\n                    children: next.node.children,\n                    deferRefs: 0,\n                    rendering: true,\n                    middleware: {},\n                    middlewareIds: [],\n                    registry: _mountOptions.registry,\n                    propertiesCalled: false\n                };\n                widgetMetaMap.set(next.id, widgetMeta);\n                if (Constructor.middlewares && Object.keys(Constructor.middlewares).length) {\n                    const { middlewares, ids } = resolveMiddleware(Constructor.middlewares, id);\n                    widgetMeta.middleware = middlewares;\n                    widgetMeta.middlewareIds = ids;\n                }\n            }\n            else {\n                invalidate = widgetMeta.invalidator;\n            }\n            rendered = Constructor(createWidgetOptions(id, id, widgetMeta.middleware));\n            widgetMeta.rendering = false;\n            widgetMeta.propertiesCalled = false;\n            if (widgetMeta.deferRefs > 0) {\n                return false;\n            }\n        }\n        else {\n            let instance = new Constructor();\n            instance.registry.base = registry;\n            const instanceData = widgetInstanceMap.get(instance);\n            invalidate = () => {\n                instanceData.dirty = true;\n                if (!instanceData.rendering && _idToWrapperMap.has(id)) {\n                    _invalidationQueue.push({ id, depth, order });\n                    _schedule();\n                }\n            };\n            instanceData.invalidate = invalidate;\n            instanceData.rendering = true;\n            instance.__setProperties__(next.node.properties);\n            instance.__setChildren__(next.node.children);\n            next.instance = instance;\n            rendered = instance.__render__();\n            instanceData.rendering = false;\n        }\n        let children;\n        if (rendered) {\n            rendered = Array.isArray(rendered) ? rendered : [rendered];\n            children = renderedToWrapper(rendered, next, null);\n            _idToChildrenWrappers.set(id, children);\n        }\n        if (!parentInvalidate && !Constructor.isWNodeWrapper) {\n            parentInvalidate = invalidate;\n        }\n        return {\n            item: {\n                next: children,\n                meta: { mergeNodes: next.mergeNodes }\n            },\n            widget: { type: 'attach', instance: next.instance, id, attached: true }\n        };\n    }\n    function _updateWidget({ current, next }) {\n        current = getWNodeWrapper(current.id) || current;\n        const { instance, domNode, hasAnimations, id } = current;\n        let { node: { widgetConstructor } } = next;\n        const Constructor = next.registryItem || widgetConstructor;\n        if (!isWidget(Constructor)) {\n            return {};\n        }\n        let rendered;\n        let processResult = {};\n        let didRender = false;\n        let currentChildren = _idToChildrenWrappers.get(current.id);\n        next.hasAnimations = hasAnimations;\n        next.id = id;\n        next.properties = Object.assign({}, next.node.properties);\n        _wrapperSiblingMap.delete(current);\n        if (domNode && domNode.parentNode) {\n            next.domNode = domNode;\n        }\n        if (!isWidgetBaseConstructor(Constructor)) {\n            const widgetMeta = widgetMetaMap.get(id);\n            if (widgetMeta) {\n                widgetMeta.originalProperties = Object.assign({}, next.properties);\n                widgetMeta.properties = wrapFunctionProperties(id, widgetMeta.originalProperties);\n                widgetMeta.children = next.node.children;\n                widgetMeta.rendering = true;\n                const customProperties = runDiffs(widgetMeta, current.properties, widgetMeta.originalProperties);\n                widgetMeta.properties = Object.assign({}, widgetMeta.properties, customProperties);\n                if (current.node.children.length > 0 || next.node.children.length > 0) {\n                    widgetMeta.dirty = true;\n                }\n                if (!widgetMeta.dirty) {\n                    propertiesDiff(current.properties, next.properties, () => {\n                        widgetMeta.dirty = true;\n                    }, widgetMeta.customDiffProperties ? [...widgetMeta.customDiffProperties.values()] : []);\n                }\n                if (widgetMeta.dirty) {\n                    _idToChildrenWrappers.delete(id);\n                    didRender = true;\n                    rendered = Constructor(createWidgetOptions(id, id, widgetMeta.middleware));\n                    widgetMeta.dirty = false;\n                    if (widgetMeta.deferRefs > 0) {\n                        rendered = null;\n                    }\n                }\n                widgetMeta.rendering = false;\n                widgetMeta.propertiesCalled = false;\n            }\n        }\n        else {\n            const instanceData = widgetInstanceMap.get(instance);\n            next.instance = instance;\n            instanceData.rendering = true;\n            instance.__setProperties__(next.node.properties);\n            instance.__setChildren__(next.node.children);\n            if (instanceData.dirty) {\n                didRender = true;\n                _idToChildrenWrappers.delete(id);\n                rendered = instance.__render__();\n            }\n            instanceData.rendering = false;\n        }\n        _idToWrapperMap.set(next.id, next);\n        processResult.widget = { type: 'attach', instance, id, attached: false };\n        let children;\n        if (rendered) {\n            rendered = Array.isArray(rendered) ? rendered : [rendered];\n            children = renderedToWrapper(rendered, next, current);\n            _idToChildrenWrappers.set(id, children);\n        }\n        if (didRender) {\n            processResult.item = {\n                current: currentChildren,\n                next: children,\n                meta: {}\n            };\n        }\n        return processResult;\n    }\n    function _removeWidget({ current }) {\n        current = getWNodeWrapper(current.id) || current;\n        _idToWrapperMap.delete(current.id);\n        const meta = widgetMetaMap.get(current.id);\n        let currentChildren = _idToChildrenWrappers.get(current.id);\n        _idToChildrenWrappers.delete(current.id);\n        _wrapperSiblingMap.delete(current);\n        let processResult = {\n            item: {\n                current: currentChildren,\n                meta: {}\n            }\n        };\n        if (meta) {\n            meta.registryHandler && meta.registryHandler.destroy();\n            destroyHandles(meta);\n            widgetMetaMap.delete(current.id);\n        }\n        else {\n            processResult.widget = { type: 'detach', current, instance: current.instance };\n        }\n        return processResult;\n    }\n    function findDomNodeOnParentWrapper(id) {\n        const children = _idToChildrenWrappers.get(id) || [];\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child.domNode) {\n                return child.id;\n            }\n            const childId = findDomNodeOnParentWrapper(child.id);\n            if (childId) {\n                return childId;\n            }\n        }\n    }\n    function _createDom({ next }) {\n        const parentDomNode = findParentDomNode(next);\n        const isVirtual = isVirtualWrapper(next);\n        const isBody = isBodyWrapper(next);\n        let mergeNodes = [];\n        next.id = `${wrapperId++}`;\n        _idToWrapperMap.set(next.id, next);\n        if (!next.domNode) {\n            if (next.node.domNode) {\n                next.domNode = next.node.domNode;\n            }\n            else {\n                if (next.node.tag === 'svg') {\n                    next.namespace = NAMESPACE_SVG;\n                }\n                if (isBody) {\n                    next.domNode = global.document.body;\n                }\n                else if (next.node.tag && !isVirtual) {\n                    if (next.namespace) {\n                        next.domNode = global.document.createElementNS(next.namespace, next.node.tag);\n                    }\n                    else {\n                        next.domNode = global.document.createElement(next.node.tag);\n                    }\n                }\n                else if (next.node.text != null) {\n                    next.domNode = global.document.createTextNode(next.node.text);\n                }\n            }\n            if (_insertBeforeMap && _allMergedNodes.length) {\n                if (parentDomNode === _allMergedNodes[0].parentNode) {\n                    _insertBeforeMap.set(next, _allMergedNodes[0]);\n                }\n            }\n        }\n        else if (_mountOptions.merge) {\n            next.merged = true;\n            if (isTextNode(next.domNode)) {\n                if (next.domNode.data !== next.node.text) {\n                    _allMergedNodes = [next.domNode, ..._allMergedNodes];\n                    next.domNode = global.document.createTextNode(next.node.text);\n                    next.merged = false;\n                }\n            }\n            else {\n                mergeNodes = arrayFrom(next.domNode.childNodes);\n                _allMergedNodes = [..._allMergedNodes, ...mergeNodes];\n            }\n        }\n        let children;\n        if (next.domNode || isVirtual) {\n            if (next.node.children && next.node.children.length) {\n                children = renderedToWrapper(next.node.children, next, null);\n                _idToChildrenWrappers.set(next.id, children);\n            }\n        }\n        const dom = isVirtual || isBody\n            ? undefined\n            : {\n                next: next,\n                parentDomNode: parentDomNode,\n                type: 'create'\n            };\n        if (children) {\n            return {\n                item: {\n                    current: [],\n                    next: children,\n                    meta: { mergeNodes }\n                },\n                dom,\n                widget: isVirtual ? { type: 'attach', id: next.id, attached: false } : undefined\n            };\n        }\n        return { dom };\n    }\n    function _updateDom({ current, next }) {\n        next.domNode = current.domNode;\n        next.namespace = current.namespace;\n        next.id = current.id;\n        next.childDomWrapperId = current.childDomWrapperId;\n        let children;\n        let currentChildren = _idToChildrenWrappers.get(next.id);\n        if (next.node.text != null && next.node.text !== current.node.text) {\n            next.domNode = global.document.createTextNode(next.node.text);\n        }\n        else if (next.node.children) {\n            children = renderedToWrapper(next.node.children, next, current);\n            _idToChildrenWrappers.set(next.id, children);\n        }\n        _wrapperSiblingMap.delete(current);\n        _idToWrapperMap.set(next.id, next);\n        return {\n            item: {\n                current: currentChildren,\n                next: children,\n                meta: {}\n            },\n            dom: { type: 'update', next, current }\n        };\n    }\n    function _removeDom({ current }) {\n        const isVirtual = isVirtualWrapper(current);\n        const isBody = isBodyWrapper(current);\n        const children = _idToChildrenWrappers.get(current.id);\n        _idToChildrenWrappers.delete(current.id);\n        _idToWrapperMap.delete(current.id);\n        _wrapperSiblingMap.delete(current);\n        if (current.node.properties.key) {\n            const widgetMeta = widgetMetaMap.get(current.owningId);\n            const parentWrapper = getWNodeWrapper(current.owningId);\n            if (widgetMeta) {\n                widgetMeta.nodeMap && widgetMeta.nodeMap.delete(current.node.properties.key);\n            }\n            else if (parentWrapper && parentWrapper.instance) {\n                const instanceData = widgetInstanceMap.get(parentWrapper.instance);\n                instanceData && instanceData.nodeHandler.remove(current.node.properties.key);\n            }\n        }\n        if (current.hasAnimations || isVirtual || isBody) {\n            return {\n                item: { current: children, meta: {} },\n                dom: isVirtual || isBody ? undefined : { type: 'delete', current }\n            };\n        }\n        if (children) {\n            _deferredRenderCallbacks.push(() => {\n                let wrappers = children || [];\n                let wrapper;\n                let bodyIds = [];\n                while ((wrapper = wrappers.pop())) {\n                    if (isWNodeWrapper(wrapper)) {\n                        wrapper = getWNodeWrapper(wrapper.id) || wrapper;\n                        if (wrapper.instance) {\n                            const instanceData = widgetInstanceMap.get(wrapper.instance);\n                            instanceData && instanceData.onDetach();\n                            wrapper.instance = undefined;\n                        }\n                        else {\n                            const meta = widgetMetaMap.get(wrapper.id);\n                            if (meta) {\n                                meta.registryHandler && meta.registryHandler.destroy();\n                                destroyHandles(meta);\n                                widgetMetaMap.delete(wrapper.id);\n                            }\n                        }\n                    }\n                    let wrapperChildren = _idToChildrenWrappers.get(wrapper.id);\n                    if (wrapperChildren) {\n                        wrappers.push(...wrapperChildren);\n                    }\n                    if (isBodyWrapper(wrapper)) {\n                        bodyIds.push(wrapper.id);\n                    }\n                    else if (bodyIds.indexOf(wrapper.parentId) !== -1) {\n                        if (isWNodeWrapper(wrapper) || isVirtualWrapper(wrapper)) {\n                            bodyIds.push(wrapper.id);\n                        }\n                        else if (wrapper.domNode && wrapper.domNode.parentNode) {\n                            wrapper.domNode.parentNode.removeChild(wrapper.domNode);\n                        }\n                    }\n                    _idToChildrenWrappers.delete(wrapper.id);\n                    _idToWrapperMap.delete(wrapper.id);\n                }\n            });\n        }\n        return {\n            dom: { type: 'delete', current }\n        };\n    }\n    return {\n        mount,\n        unmount,\n        invalidate\n    };\n}\nexport default renderer;\n//# sourceMappingURL=vdom.mjs.map","var _a;\nimport global from './global';\nvar isArrayLike = undefined, ShimIterator = undefined;\n// !has('es6-iterator')\n// elided: import './iterator'\nimport has from '../core/has';\n// !has('es6-symbol')\n// elided: import './Symbol'\nexport let Set = global.Set;\nif (!true) {\n    Set = global.Set = (_a = class Set {\n            constructor(iterable) {\n                this._setData = [];\n                this[Symbol.toStringTag] = 'Set';\n                if (iterable) {\n                    if (isArrayLike(iterable)) {\n                        for (let i = 0; i < iterable.length; i++) {\n                            this.add(iterable[i]);\n                        }\n                    }\n                    else {\n                        for (const value of iterable) {\n                            this.add(value);\n                        }\n                    }\n                }\n            }\n            add(value) {\n                if (this.has(value)) {\n                    return this;\n                }\n                this._setData.push(value);\n                return this;\n            }\n            clear() {\n                this._setData.length = 0;\n            }\n            delete(value) {\n                const idx = this._setData.indexOf(value);\n                if (idx === -1) {\n                    return false;\n                }\n                this._setData.splice(idx, 1);\n                return true;\n            }\n            entries() {\n                return new ShimIterator(this._setData.map((value) => [value, value]));\n            }\n            forEach(callbackfn, thisArg) {\n                const iterator = this.values();\n                let result = iterator.next();\n                while (!result.done) {\n                    callbackfn.call(thisArg, result.value, result.value, this);\n                    result = iterator.next();\n                }\n            }\n            has(value) {\n                return this._setData.indexOf(value) > -1;\n            }\n            keys() {\n                return new ShimIterator(this._setData);\n            }\n            get size() {\n                return this._setData.length;\n            }\n            values() {\n                return new ShimIterator(this._setData);\n            }\n            [Symbol.iterator]() {\n                return new ShimIterator(this._setData);\n            }\n        },\n        _a[Symbol.species] = _a,\n        _a);\n}\nexport default Set;","/* tslint:disable:interface-name */\nimport Map from '../../shim/Map';\nimport { create, invalidator, destroy } from '../vdom';\nconst factory = create({ invalidator, destroy });\nexport function createICacheMiddleware() {\n    const icache = factory(({ middleware: { invalidator, destroy } }) => {\n        const cacheMap = new Map();\n        destroy(() => {\n            cacheMap.clear();\n        });\n        const api = {\n            get: (key) => {\n                const cachedValue = cacheMap.get(key);\n                if (!cachedValue || cachedValue.status === 'pending') {\n                    return undefined;\n                }\n                return cachedValue.value;\n            }\n        };\n        api.set = (key, value, invalidate = true) => {\n            const current = api.get(key);\n            if (typeof value === 'function') {\n                value = value(current);\n                if (value && typeof value.then === 'function') {\n                    cacheMap.set(key, {\n                        status: 'pending',\n                        value\n                    });\n                    value.then((result) => {\n                        const cachedValue = cacheMap.get(key);\n                        if (cachedValue && cachedValue.value === value) {\n                            cacheMap.set(key, {\n                                status: 'resolved',\n                                value: result\n                            });\n                            invalidate && invalidator();\n                        }\n                    });\n                    return undefined;\n                }\n            }\n            cacheMap.set(key, {\n                status: 'resolved',\n                value\n            });\n            invalidate && invalidator();\n            return value;\n        };\n        api.has = (key) => {\n            return cacheMap.has(key);\n        };\n        api.delete = (key, invalidate = true) => {\n            cacheMap.delete(key);\n            invalidate && invalidator();\n        };\n        api.clear = (invalidate = true) => {\n            cacheMap.clear();\n            invalidate && invalidator();\n        };\n        api.getOrSet = (key, value, invalidate = true) => {\n            let cachedValue = cacheMap.get(key);\n            if (!cachedValue) {\n                api.set(key, value, invalidate);\n            }\n            cachedValue = cacheMap.get(key);\n            if (!cachedValue || cachedValue.status === 'pending') {\n                return undefined;\n            }\n            return cachedValue.value;\n        };\n        return api;\n    });\n    return icache;\n}\nexport const icache = createICacheMiddleware();\nexport default icache;\n//# sourceMappingURL=icache.mjs.map","import { WIDGET_BASE_TYPE } from './Registry';\nfunction isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Array.isArray(value);\n}\nexport function always(previousProperty, newProperty) {\n    return {\n        changed: true,\n        value: newProperty\n    };\n}\nexport function ignore(previousProperty, newProperty) {\n    return {\n        changed: false,\n        value: newProperty\n    };\n}\nexport function reference(previousProperty, newProperty) {\n    return {\n        changed: previousProperty !== newProperty,\n        value: newProperty\n    };\n}\nexport function shallow(previousProperty, newProperty, depth = 0) {\n    let changed = false;\n    const validOldProperty = previousProperty && isObjectOrArray(previousProperty);\n    const validNewProperty = newProperty && isObjectOrArray(newProperty);\n    if (!validOldProperty || !validNewProperty) {\n        return {\n            changed: true,\n            value: newProperty\n        };\n    }\n    const previousKeys = Object.keys(previousProperty);\n    const newKeys = Object.keys(newProperty);\n    if (previousKeys.length !== newKeys.length) {\n        changed = true;\n    }\n    else {\n        changed = newKeys.some((key) => {\n            if (depth > 0) {\n                return auto(newProperty[key], previousProperty[key], depth - 1).changed;\n            }\n            return newProperty[key] !== previousProperty[key];\n        });\n    }\n    return {\n        changed,\n        value: newProperty\n    };\n}\nexport function auto(previousProperty, newProperty, depth = 0) {\n    let result;\n    if (typeof newProperty === 'function') {\n        if (newProperty._type === WIDGET_BASE_TYPE) {\n            result = reference(previousProperty, newProperty);\n        }\n        else {\n            result = ignore(previousProperty, newProperty);\n        }\n    }\n    else if (isObjectOrArray(newProperty)) {\n        result = shallow(previousProperty, newProperty, depth);\n    }\n    else {\n        result = reference(previousProperty, newProperty);\n    }\n    return result;\n}\n//# sourceMappingURL=diff.mjs.map","// extracted by mini-css-extract-plugin\nmodule.exports = {\" _key\":\"@dojo/widgets/three-column-layout\",\"root\":\"three-column-layout-m__root__31HFf\",\"center\":\"three-column-layout-m__center__3u6bV\"};","var isArrayLike = undefined, isIterable = undefined;\n// !has('es6-iterator')\n// elided: import './iterator'\nimport has from '../core/has';\nimport { wrapNative } from './support/util';\nexport let from;\nexport let of;\nexport let copyWithin;\nexport let fill;\nexport let find;\nexport let findIndex;\nexport let includes;\nexport let flat;\nexport let flatMap;\nlet toLength;\nlet toInteger;\nlet normalizeOffset;\nif (!true || !true || !true) {\n    const MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n    /**\n     * Ensures a non-negative, non-infinite, safe integer.\n     *\n     * @param length The number to validate\n     * @return A proper length\n     */\n    toLength = function toLength(length) {\n        if (isNaN(length)) {\n            return 0;\n        }\n        length = Number(length);\n        if (isFinite(length)) {\n            length = Math.floor(length);\n        }\n        // Ensure a non-negative, real, safe integer\n        return Math.min(Math.max(length, 0), MAX_SAFE_INTEGER);\n    };\n    /**\n     * From ES6 7.1.4 ToInteger()\n     *\n     * @param value A value to convert\n     * @return An integer\n     */\n    toInteger = function toInteger(value) {\n        value = Number(value);\n        if (isNaN(value)) {\n            return 0;\n        }\n        if (value === 0 || !isFinite(value)) {\n            return value;\n        }\n        return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n    };\n    /**\n     * Normalizes an offset against a given length, wrapping it if negative.\n     *\n     * @param value The original offset\n     * @param length The total length to normalize against\n     * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n     */\n    normalizeOffset = function normalizeOffset(value, length) {\n        return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n    };\n}\nif (!true) {\n    Array.from = function from(arrayLike, mapFunction, thisArg) {\n        if (arrayLike == null) {\n            throw new TypeError('from: requires an array-like object');\n        }\n        if (mapFunction && thisArg) {\n            mapFunction = mapFunction.bind(thisArg);\n        }\n        /* tslint:disable-next-line:variable-name */\n        const Constructor = this;\n        const length = toLength(arrayLike.length);\n        // Support extension\n        const array = typeof Constructor === 'function' ? Object(new Constructor(length)) : new Array(length);\n        if (!isArrayLike(arrayLike) && !isIterable(arrayLike)) {\n            return array;\n        }\n        // if this is an array and the normalized length is 0, just return an empty array. this prevents a problem\n        // with the iteration on IE when using a NaN array length.\n        if (isArrayLike(arrayLike)) {\n            if (length === 0) {\n                return [];\n            }\n            for (let i = 0; i < arrayLike.length; i++) {\n                array[i] = mapFunction ? mapFunction(arrayLike[i], i) : arrayLike[i];\n            }\n        }\n        else {\n            let i = 0;\n            for (const value of arrayLike) {\n                array[i] = mapFunction ? mapFunction(value, i) : value;\n                i++;\n            }\n        }\n        if (arrayLike.length !== undefined) {\n            array.length = length;\n        }\n        return array;\n    };\n    Array.of = function of(...items) {\n        return Array.prototype.slice.call(items);\n    };\n    Array.prototype.copyWithin = function copyWithin(offset, start, end) {\n        if (this == null) {\n            throw new TypeError('copyWithin: target must be an array-like object');\n        }\n        const length = toLength(this.length);\n        offset = normalizeOffset(toInteger(offset), length);\n        start = normalizeOffset(toInteger(start), length);\n        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n        let count = Math.min(end - start, length - offset);\n        let direction = 1;\n        if (offset > start && offset < start + count) {\n            direction = -1;\n            start += count - 1;\n            offset += count - 1;\n        }\n        while (count > 0) {\n            if (start in this) {\n                this[offset] = this[start];\n            }\n            else {\n                delete this[offset];\n            }\n            offset += direction;\n            start += direction;\n            count--;\n        }\n        return this;\n    };\n    Array.prototype.find = function find(callback, thisArg) {\n        const index = this.findIndex(callback, thisArg);\n        return index !== -1 ? this[index] : undefined;\n    };\n    Array.prototype.findIndex = function findIndex(callback, thisArg) {\n        const length = toLength(this.length);\n        if (!callback) {\n            throw new TypeError('find: second argument must be a function');\n        }\n        if (thisArg) {\n            callback = callback.bind(thisArg);\n        }\n        for (let i = 0; i < length; i++) {\n            if (callback(this[i], i, this)) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\nif (!true) {\n    Array.prototype.fill = function fill(value, start, end) {\n        const length = toLength(this.length);\n        let i = normalizeOffset(toInteger(start), length);\n        end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n        while (i < (end || 0)) {\n            this[i++] = value;\n        }\n        return this;\n    };\n}\nif (!true) {\n    Array.prototype.includes = function includes(searchElement, fromIndex = 0) {\n        let len = toLength(this.length);\n        for (let i = fromIndex; i < len; ++i) {\n            const currentElement = this[i];\n            if (searchElement === currentElement ||\n                (searchElement !== searchElement && currentElement !== currentElement)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nif (!true) {\n    Array.prototype.flat = function flat(depth = 1) {\n        return depth > 0\n            ? this.reduce((acc, val) => acc.concat(Array.isArray(val) ? val.flat(depth - 1) : val), [])\n            : this.slice();\n    };\n    Array.prototype.flatMap = function flatMap(callback) {\n        return this.map(callback).flat();\n    };\n}\nfrom = Array.from;\nof = Array.of;\ncopyWithin = wrapNative(Array.prototype.copyWithin);\nfill = wrapNative(Array.prototype.fill);\nfind = wrapNative(Array.prototype.find);\nflat = wrapNative(Array.prototype.flat);\nflatMap = wrapNative(Array.prototype.flatMap);\nfindIndex = wrapNative(Array.prototype.findIndex);\nincludes = wrapNative(Array.prototype.includes);\nexport default Array;","// extracted by mini-css-extract-plugin\nmodule.exports = {\" _key\":\"@dojo/widgets/three-column-layout\",\"root\":\"three-column-layout-m__root__Io1yp\",\"leading\":\"three-column-layout-m__leading__cWlTV\",\"center\":\"three-column-layout-m__center__2PvVq\",\"trailing\":\"three-column-layout-m__trailing__hs2u9\"};","import { Map } from '../shim/Map';\nimport { Evented } from '../core/Evented';\nimport { Registry } from './Registry';\nexport class RegistryHandler extends Evented {\n    constructor() {\n        super();\n        this._registry = new Registry();\n        this._registryWidgetLabelMap = new Map();\n        this._registryInjectorLabelMap = new Map();\n        this.own(this._registry);\n        const destroy = () => {\n            if (this.baseRegistry) {\n                this._registryWidgetLabelMap.delete(this.baseRegistry);\n                this._registryInjectorLabelMap.delete(this.baseRegistry);\n                this.baseRegistry = undefined;\n            }\n        };\n        this.own({ destroy });\n    }\n    set base(baseRegistry) {\n        if (this.baseRegistry) {\n            this._registryWidgetLabelMap.delete(this.baseRegistry);\n            this._registryInjectorLabelMap.delete(this.baseRegistry);\n        }\n        this.baseRegistry = baseRegistry;\n    }\n    get base() {\n        return this.baseRegistry;\n    }\n    define(label, widget) {\n        this._registry.define(label, widget);\n    }\n    defineInjector(label, injector) {\n        this._registry.defineInjector(label, injector);\n    }\n    has(label) {\n        return this._registry.has(label) || Boolean(this.baseRegistry && this.baseRegistry.has(label));\n    }\n    hasInjector(label) {\n        return this._registry.hasInjector(label) || Boolean(this.baseRegistry && this.baseRegistry.hasInjector(label));\n    }\n    get(label, globalPrecedence = false) {\n        return this._get(label, globalPrecedence, 'get', this._registryWidgetLabelMap);\n    }\n    getInjector(label, globalPrecedence = false) {\n        return this._get(label, globalPrecedence, 'getInjector', this._registryInjectorLabelMap);\n    }\n    _get(label, globalPrecedence, getFunctionName, labelMap) {\n        const registries = globalPrecedence ? [this.baseRegistry, this._registry] : [this._registry, this.baseRegistry];\n        for (let i = 0; i < registries.length; i++) {\n            const registry = registries[i];\n            if (!registry) {\n                continue;\n            }\n            const item = registry[getFunctionName](label);\n            const registeredLabels = labelMap.get(registry) || [];\n            if (item) {\n                return item;\n            }\n            else if (registeredLabels.indexOf(label) === -1) {\n                const handle = registry.on(label, (event) => {\n                    if (event.action === 'loaded' &&\n                        this[getFunctionName](label, globalPrecedence) === event.item) {\n                        this.emit({ type: 'invalidate' });\n                    }\n                });\n                this.own(handle);\n                labelMap.set(registry, [...registeredLabels, label]);\n            }\n        }\n        return null;\n    }\n}\nexport default RegistryHandler;\n//# sourceMappingURL=RegistryHandler.mjs.map","import { create } from '@dojo/framework/core/vdom';\nimport coreTheme, {\n\tThemeProperties as CoreThemeProperties\n} from '@dojo/framework/core/middleware/theme';\nimport { ThemeWithVariant, ClassNames, Theme } from '@dojo/framework/core/interfaces';\nimport { isThemeInjectorPayloadWithVariant } from '@dojo/framework/core/ThemeInjector';\n\nconst factory = create({ coreTheme });\nexport const THEME_KEY = ' _key';\n\nfunction uppercaseFirstChar(value: string) {\n\treturn `${value.charAt(0).toUpperCase()}${value.slice(1)}`;\n}\n\nfunction lowercaseFirstChar(value: string) {\n\treturn `${value.charAt(0).toLowerCase()}${value.slice(1)}`;\n}\n\nfunction isThemeWithVariant(theme: any): theme is ThemeWithVariant {\n\treturn theme && theme.hasOwnProperty('variant');\n}\n\nexport interface ThemeProperties extends CoreThemeProperties {}\n\nexport const theme = factory(function({ middleware: { coreTheme }, properties }) {\n\tfunction getTheme() {\n\t\tconst { theme } = properties();\n\t\tif (theme) {\n\t\t\treturn theme;\n\t\t}\n\n\t\tconst themePayload = coreTheme.get();\n\t\tif (isThemeInjectorPayloadWithVariant(themePayload)) {\n\t\t\treturn { theme: themePayload.theme, variant: themePayload.variant };\n\t\t} else if (themePayload) {\n\t\t\treturn themePayload.theme;\n\t\t}\n\t}\n\n\treturn {\n\t\tcompose: <T extends ClassNames, B extends ClassNames>(\n\t\t\tbaseCss: B,\n\t\t\tcss: T,\n\t\t\tprefix?: string\n\t\t): Theme | ThemeWithVariant => {\n\t\t\tconst theme = getTheme();\n\t\t\tconst baseKey = baseCss[THEME_KEY];\n\t\t\tconst variantKey = css[THEME_KEY];\n\t\t\tconst virtualCss = Object.keys(baseCss).reduce(\n\t\t\t\t(virtualCss, key) => {\n\t\t\t\t\tif (key === THEME_KEY) {\n\t\t\t\t\t\treturn virtualCss;\n\t\t\t\t\t}\n\t\t\t\t\tif (prefix && !virtualCss[`${prefix}${uppercaseFirstChar(key)}`]) {\n\t\t\t\t\t\tvirtualCss[`${prefix}${uppercaseFirstChar(key)}`] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tif (!css[key]) {\n\t\t\t\t\t\tvirtualCss[key] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\treturn virtualCss;\n\t\t\t\t},\n\t\t\t\t{ [THEME_KEY]: variantKey } as ClassNames\n\t\t\t);\n\t\t\tconst virtualTheme = coreTheme.classes(virtualCss);\n\t\t\tconst variantTheme = coreTheme.classes(css);\n\t\t\tlet baseTheme = coreTheme.classes(baseCss);\n\t\t\tif (prefix) {\n\t\t\t\tconst prefixedCss = Object.keys({ ...virtualTheme, ...variantTheme }).reduce(\n\t\t\t\t\t(prefixCss, key) => {\n\t\t\t\t\t\tif (key.indexOf(prefix) === 0 && key !== prefix) {\n\t\t\t\t\t\t\tconst classKey = lowercaseFirstChar(key.replace(prefix, ''));\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!variantTheme[key] &&\n\t\t\t\t\t\t\t\tvirtualTheme[key] &&\n\t\t\t\t\t\t\t\tvirtualTheme[key].trim()\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tprefixCss[classKey] = `${baseTheme[classKey]} ${virtualTheme[\n\t\t\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t\t].trim()}`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (variantTheme[key]) {\n\t\t\t\t\t\t\t\tprefixCss[classKey] = variantTheme[key];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn prefixCss;\n\t\t\t\t\t},\n\t\t\t\t\t{} as ClassNames\n\t\t\t\t);\n\t\t\t\tbaseTheme = { ...baseTheme, ...prefixedCss };\n\n\t\t\t\tif (isThemeWithVariant(theme)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttheme: {\n\t\t\t\t\t\t\ttheme: {\n\t\t\t\t\t\t\t\t...theme.theme.theme,\n\t\t\t\t\t\t\t\t[baseKey]: baseTheme\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvariants: theme.theme.variants\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvariant: theme.variant\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...theme,\n\t\t\t\t\t[baseKey]: baseTheme\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst constructedTheme = Object.keys(baseTheme).reduce(\n\t\t\t\t(theme, key) => {\n\t\t\t\t\tif (key === THEME_KEY) {\n\t\t\t\t\t\treturn theme;\n\t\t\t\t\t}\n\t\t\t\t\tconst variantComposesClass = variantTheme[key] && variantTheme[key].trim();\n\t\t\t\t\tif (variantTheme[key]) {\n\t\t\t\t\t\ttheme[key] = variantComposesClass;\n\t\t\t\t\t} else if (virtualTheme[key] && virtualTheme[key].trim()) {\n\t\t\t\t\t\ttheme[key] = `${theme[key]} ${virtualTheme[key].trim()}`;\n\t\t\t\t\t}\n\t\t\t\t\treturn theme;\n\t\t\t\t},\n\t\t\t\t{ ...baseTheme } as ClassNames\n\t\t\t);\n\n\t\t\tif (isThemeWithVariant(theme)) {\n\t\t\t\treturn {\n\t\t\t\t\ttheme: {\n\t\t\t\t\t\ttheme: {\n\t\t\t\t\t\t\t...theme.theme.theme,\n\t\t\t\t\t\t\t[baseKey]: constructedTheme\n\t\t\t\t\t\t},\n\t\t\t\t\t\tvariants: theme.theme.variants\n\t\t\t\t\t},\n\t\t\t\t\tvariant: theme.variant\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...theme,\n\t\t\t\t[baseKey]: constructedTheme\n\t\t\t};\n\t\t},\n\t\t...coreTheme\n\t};\n});\n\nexport default theme;\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nimport { create, invalidator, diffProperty, getRegistry } from '../vdom';\nimport icache from './icache';\nimport injector from './injector';\nimport Set from '../../shim/Set';\nimport { auto } from '../diff';\nimport { ThemeInjector, isThemeInjectorPayloadWithVariant, isThemeWithVariants, isThemeWithVariant } from '../ThemeInjector';\nexport const THEME_KEY = ' _key';\nexport const INJECTED_THEME_KEY = '__theme_injector';\nfunction registerThemeInjector(theme, themeRegistry) {\n    const themeInjector = new ThemeInjector(theme);\n    themeRegistry.defineInjector(INJECTED_THEME_KEY, (invalidator) => {\n        themeInjector.setInvalidator(invalidator);\n        return () => themeInjector;\n    });\n    return themeInjector;\n}\nconst factory = create({ invalidator, icache, diffProperty, injector, getRegistry }).properties();\nexport const theme = factory(({ middleware: { invalidator, icache, diffProperty, injector, getRegistry }, properties }) => {\n    let themeKeys = new Set();\n    diffProperty('theme', properties, (current, next) => {\n        const { changed } = auto(current.theme, next.theme, 3);\n        if (changed) {\n            icache.clear();\n            invalidator();\n        }\n    });\n    diffProperty('classes', (current, next) => {\n        let result = false;\n        if ((current.classes && !next.classes) || (!current.classes && next.classes)) {\n            result = true;\n        }\n        else if (current.classes && next.classes) {\n            const keys = [...themeKeys.values()];\n            for (let i = 0; i < keys.length; i++) {\n                let key = keys[i];\n                result = auto(current.classes[key], next.classes[key], 2).changed;\n                if (result) {\n                    break;\n                }\n            }\n        }\n        if (result) {\n            icache.clear();\n            invalidator();\n        }\n    });\n    function getTheme() {\n        const { theme } = properties();\n        if (theme) {\n            return theme;\n        }\n        const themeInjector = injector.get(INJECTED_THEME_KEY);\n        if (themeInjector) {\n            const themePayload = themeInjector.get();\n            if (isThemeInjectorPayloadWithVariant(themePayload)) {\n                return { theme: themePayload.theme, variant: themePayload.variant };\n            }\n            else if (themePayload) {\n                return themePayload.theme;\n            }\n        }\n    }\n    const themeInjector = injector.get(INJECTED_THEME_KEY);\n    if (!themeInjector) {\n        const registry = getRegistry();\n        if (registry) {\n            registerThemeInjector(undefined, registry.base);\n        }\n    }\n    injector.subscribe(INJECTED_THEME_KEY, () => {\n        icache.clear();\n        invalidator();\n    });\n    function set(theme, variant) {\n        const currentTheme = injector.get(INJECTED_THEME_KEY);\n        if (currentTheme) {\n            if (isThemeWithVariants(theme)) {\n                currentTheme.set(theme, variant);\n            }\n            else {\n                currentTheme.set(theme);\n            }\n        }\n    }\n    return {\n        classes(css) {\n            const cachedTheme = icache.get(css);\n            if (cachedTheme) {\n                return cachedTheme;\n            }\n            const _a = THEME_KEY, key = css[_a], classes = __rest(css, [typeof _a === \"symbol\" ? _a : _a + \"\"]);\n            themeKeys.add(key);\n            let theme = classes;\n            let { classes: currentClasses } = properties();\n            let currentTheme = getTheme();\n            if (currentTheme && isThemeWithVariant(currentTheme)) {\n                currentTheme = isThemeWithVariants(currentTheme.theme)\n                    ? currentTheme.theme.theme\n                    : currentTheme.theme;\n            }\n            if (currentTheme && currentTheme[key]) {\n                theme = Object.assign({}, theme, currentTheme[key]);\n            }\n            if (currentClasses && currentClasses[key]) {\n                const classKeys = Object.keys(currentClasses[key]);\n                for (let i = 0; i < classKeys.length; i++) {\n                    const classKey = classKeys[i];\n                    if (theme[classKey]) {\n                        theme[classKey] = `${theme[classKey]} ${currentClasses[key][classKey].join(' ')}`;\n                    }\n                }\n            }\n            icache.set(css, theme, false);\n            return theme;\n        },\n        variant() {\n            const theme = getTheme();\n            if (theme && isThemeWithVariant(theme)) {\n                return theme.variant.value.root;\n            }\n        },\n        set,\n        get() {\n            const currentTheme = injector.get(INJECTED_THEME_KEY);\n            if (currentTheme) {\n                return currentTheme.get();\n            }\n        }\n    };\n});\nexport default theme;\n//# sourceMappingURL=theme.mjs.map","import { Evented } from '../core/Evented';\nexport class Injector extends Evented {\n    constructor(payload) {\n        super();\n        this._payload = payload;\n    }\n    setInvalidator(invalidator) {\n        this._invalidator = invalidator;\n    }\n    get() {\n        return this._payload;\n    }\n    set(payload) {\n        this._payload = payload;\n        if (this._invalidator) {\n            this._invalidator();\n        }\n    }\n}\nexport default Injector;\n//# sourceMappingURL=Injector.mjs.map","import { create, getRegistry, invalidator, destroy } from '../vdom';\nconst injectorFactory = create({ getRegistry, invalidator, destroy });\nexport const injector = injectorFactory(({ middleware: { getRegistry, invalidator, destroy } }) => {\n    const handles = [];\n    destroy(() => {\n        let handle;\n        while ((handle = handles.pop())) {\n            handle.destroy();\n        }\n    });\n    const registry = getRegistry();\n    return {\n        subscribe(label, callback = invalidator) {\n            if (registry) {\n                const item = registry.getInjector(label);\n                if (item) {\n                    const handle = item.invalidator.on('invalidate', () => {\n                        callback();\n                    });\n                    handles.push(handle);\n                    return () => {\n                        const index = handles.indexOf(handle);\n                        if (index !== -1) {\n                            handles.splice(index, 1);\n                            handle.destroy();\n                        }\n                    };\n                }\n            }\n        },\n        get(label) {\n            if (registry) {\n                const item = registry.getInjector(label);\n                if (item) {\n                    return item.injector();\n                }\n            }\n            return null;\n        }\n    };\n});\nexport default injector;\n//# sourceMappingURL=injector.mjs.map","var _a;\nvar isArrayLike = undefined, ShimIterator = undefined;\n// !has('es6-iterator')\n// elided: import './iterator'\nimport global from './global';\nimport { is as objectIs } from './object';\nimport has from '../core/has';\n// !has('es6-symbol')\n// elided: import './Symbol'\nexport let Map = global.Map;\nif (!true) {\n    Map = global.Map = (_a = class Map {\n            constructor(iterable) {\n                this._keys = [];\n                this._values = [];\n                this[Symbol.toStringTag] = 'Map';\n                if (iterable) {\n                    if (isArrayLike(iterable)) {\n                        for (let i = 0; i < iterable.length; i++) {\n                            const value = iterable[i];\n                            this.set(value[0], value[1]);\n                        }\n                    }\n                    else {\n                        for (const value of iterable) {\n                            this.set(value[0], value[1]);\n                        }\n                    }\n                }\n            }\n            /**\n             * An alternative to Array.prototype.indexOf using Object.is\n             * to check for equality. See http://mzl.la/1zuKO2V\n             */\n            _indexOfKey(keys, key) {\n                for (let i = 0, length = keys.length; i < length; i++) {\n                    if (objectIs(keys[i], key)) {\n                        return i;\n                    }\n                }\n                return -1;\n            }\n            get size() {\n                return this._keys.length;\n            }\n            clear() {\n                this._keys.length = this._values.length = 0;\n            }\n            delete(key) {\n                const index = this._indexOfKey(this._keys, key);\n                if (index < 0) {\n                    return false;\n                }\n                this._keys.splice(index, 1);\n                this._values.splice(index, 1);\n                return true;\n            }\n            entries() {\n                const values = this._keys.map((key, i) => {\n                    return [key, this._values[i]];\n                });\n                return new ShimIterator(values);\n            }\n            forEach(callback, context) {\n                const keys = this._keys;\n                const values = this._values;\n                for (let i = 0, length = keys.length; i < length; i++) {\n                    callback.call(context, values[i], keys[i], this);\n                }\n            }\n            get(key) {\n                const index = this._indexOfKey(this._keys, key);\n                return index < 0 ? undefined : this._values[index];\n            }\n            has(key) {\n                return this._indexOfKey(this._keys, key) > -1;\n            }\n            keys() {\n                return new ShimIterator(this._keys);\n            }\n            set(key, value) {\n                let index = this._indexOfKey(this._keys, key);\n                index = index < 0 ? this._keys.length : index;\n                this._keys[index] = key;\n                this._values[index] = value;\n                return this;\n            }\n            values() {\n                return new ShimIterator(this._values);\n            }\n            [Symbol.iterator]() {\n                return this.entries();\n            }\n        },\n        _a[Symbol.species] = _a,\n        _a);\n}\nexport default Map;","import Promise from '../shim/Promise';\n/**\n * No op function used to replace a Destroyable instance's `destroy` method, once the instance has been destroyed\n */\nfunction noop() {\n    return Promise.resolve(false);\n}\n/**\n * No op function used to replace a Destroyable instance's `own` method, once the instance has been destroyed\n */\nfunction destroyed() {\n    throw new Error('Call made to destroyed method');\n}\nexport class Destroyable {\n    /**\n     * @constructor\n     */\n    constructor() {\n        this.handles = [];\n    }\n    /**\n     * Register handles for the instance that will be destroyed when `this.destroy` is called\n     *\n     * @param {Handle} handle The handle to add for the instance\n     * @returns {Handle} A wrapper Handle. When the wrapper Handle's `destroy` method is invoked, the original handle is\n     *                   removed from the instance, and its `destroy` method is invoked.\n     */\n    own(handle) {\n        const { handles: _handles } = this;\n        _handles.push(handle);\n        return {\n            destroy() {\n                _handles.splice(_handles.indexOf(handle));\n                handle.destroy();\n            }\n        };\n    }\n    /**\n     * Destroys all handlers registered for the instance\n     *\n     * @returns {Promise<any} A Promise that resolves once all handles have been destroyed\n     */\n    destroy() {\n        return new Promise((resolve) => {\n            this.handles.forEach((handle) => {\n                handle && handle.destroy && handle.destroy();\n            });\n            this.destroy = noop;\n            this.own = destroyed;\n            resolve(true);\n        });\n    }\n}\nexport default Destroyable;\n//# sourceMappingURL=Destroyable.mjs.map","// extracted by mini-css-extract-plugin\nmodule.exports = {\" _key\":\"@dojo/widgets/base\",\"visuallyHidden\":\"base-m__visuallyHidden__1AeWe\",\"focusable\":\"base-m__focusable__1_qAN\",\"hidden\":\"base-m__hidden__3QddU\"};","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import has from '../core/has';\nexport let assign;\n/**\n * Gets the own property descriptor of the specified object.\n * An own property descriptor is one that is defined directly on the object and is not\n * inherited from the object's prototype.\n * @param o Object that contains the property.\n * @param p Name of the property.\n */\nexport let getOwnPropertyDescriptor;\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\n * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\n * @param o Object that contains the own properties.\n */\nexport let getOwnPropertyNames;\n/**\n * Returns an array of all symbol properties found directly on object o.\n * @param o Object to retrieve the symbols from.\n */\nexport let getOwnPropertySymbols;\n/**\n * Returns true if the values are the same value, false otherwise.\n * @param value1 The first value.\n * @param value2 The second value.\n */\nexport let is;\n/**\n * Returns the names of the enumerable properties and methods of an object.\n * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n */\nexport let keys;\n/* ES7 Object static methods */\nexport let getOwnPropertyDescriptors;\nexport let entries;\nexport let values;\nif (!true) {\n    const keys = Object.keys.bind(Object);\n    Object.keys = function symbolAwareKeys(o) {\n        return keys(o).filter((key) => !Boolean(key.match(/^@@.+/)));\n    };\n    Object.assign = function assign(target, ...sources) {\n        if (target == null) {\n            // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n        const to = Object(target);\n        sources.forEach((nextSource) => {\n            if (nextSource) {\n                // Skip over if undefined or null\n                keys(nextSource).forEach((nextKey) => {\n                    to[nextKey] = nextSource[nextKey];\n                });\n            }\n        });\n        return to;\n    };\n    const getOwnPropertyNames = Object.getOwnPropertyNames.bind(Object);\n    Object.getOwnPropertyNames = function symbolAwareGetOwnPropertyNames(o) {\n        return getOwnPropertyNames(o).filter((key) => !Boolean(key.match(/^@@.+/)));\n    };\n    Object.getOwnPropertySymbols = function getOwnPropertySymbols(o) {\n        return getOwnPropertyNames(o)\n            .filter((key) => Boolean(key.match(/^@@.+/)))\n            .map((key) => Symbol.for(key.substring(2)));\n    };\n    Object.is = function is(value1, value2) {\n        if (value1 === value2) {\n            return value1 !== 0 || 1 / value1 === 1 / value2; // -0\n        }\n        return value1 !== value1 && value2 !== value2; // NaN\n    };\n}\nif (!true) {\n    Object.getOwnPropertyDescriptors = function getOwnPropertyDescriptors(o) {\n        return Object.getOwnPropertyNames(o).reduce((previous, key) => {\n            previous[key] = Object.getOwnPropertyDescriptor(o, key);\n            return previous;\n        }, {});\n    };\n    Object.entries = function entries(o) {\n        return keys(o).map((key) => [key, o[key]]);\n    };\n    Object.values = function values(o) {\n        return keys(o).map((key) => o[key]);\n    };\n}\nassign = Object.assign;\ngetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\ngetOwnPropertyNames = Object.getOwnPropertyNames;\ngetOwnPropertySymbols = Object.getOwnPropertySymbols;\nis = Object.is;\nkeys = Object.keys;\ngetOwnPropertyDescriptors = Object.getOwnPropertyDescriptors;\nentries = Object.entries;\nvalues = Object.values;\nexport default Object;\n//# sourceMappingURL=object.mjs.map","/*** IMPORTS FROM imports-loader ***/\nvar widgetFactory = require(\"src/three-column-layout\");\n\nvar registerCustomElement = require('@dojo/framework/core/registerCustomElement').default;\n\nvar defaultExport = widgetFactory.default;\ndefaultExport && registerCustomElement(defaultExport);\n\n","import { create, tsx } from '@dojo/framework/core/vdom';\nimport { RenderResult } from '@dojo/framework/core/interfaces';\nimport breakpoint from '@dojo/framework/core/middleware/breakpoint';\nimport theme from '../middleware/theme';\nimport * as fixedCss from './styles/three-column-layout.m.css';\nimport * as baseCss from '../common/styles/base.m.css';\nimport * as css from '../theme/default/three-column-layout.m.css';\n\nexport interface ThreeColumnLayoutProperties {\n\t/** The breakpoint at which one column should collapse. Defaults to 1024px.\n\t * The column that collapses will be the trailing column by default or the column that is not specified by the\n\t * `bias` property if it is provided\n\t */\n\ttwoColumnBreakpoint?: number;\n\t/** The breakpoint at which both side columns will collapse. Defaults to 600px. */\n\toneColumnBreakpoint?: number;\n\t/** Determines which column is more important, and will remain at the `twoColumnBreakpoint`. Defaults to `'leading'`. */\n\tbias?: 'leading' | 'trailing';\n}\n\nexport interface ThreeColumnLayoutChildren {\n\t/** The content for the leading column */\n\tleading: RenderResult;\n\t/** The content for the center column */\n\tcenter: RenderResult;\n\t/** The content for the trailing column */\n\ttrailing: RenderResult;\n}\n\nconst factory = create({ breakpoint, theme })\n\t.properties<ThreeColumnLayoutProperties>()\n\t.children<ThreeColumnLayoutChildren>();\n\nexport const ThreeColumnLayout = factory(function({\n\tproperties,\n\tchildren,\n\tmiddleware: { breakpoint, theme }\n}) {\n\tconst {\n\t\ttwoColumnBreakpoint = 1024,\n\t\toneColumnBreakpoint = 600,\n\t\tbias = 'leading'\n\t} = properties();\n\tconst [{ leading, center, trailing }] = children();\n\tconst classes = theme.classes(css);\n\tconst { breakpoint: currentBreakpoint } = breakpoint.get('root', {\n\t\tLARGE: twoColumnBreakpoint,\n\t\tMEDIUM: oneColumnBreakpoint,\n\t\tSMALL: 0\n\t}) || { breakpoint: 'LARGE' };\n\tconst shouldCollapseLeading =\n\t\tcurrentBreakpoint === 'SMALL' || (currentBreakpoint === 'MEDIUM' && bias === 'trailing');\n\tconst shouldCollapseTrailing =\n\t\tcurrentBreakpoint === 'SMALL' || (currentBreakpoint === 'MEDIUM' && bias === 'leading');\n\n\treturn (\n\t\t<div key=\"root\" classes={[theme.variant(), fixedCss.root, classes.root]}>\n\t\t\t<div\n\t\t\t\tkey=\"leading\"\n\t\t\t\tclasses={[classes.leading, shouldCollapseLeading && baseCss.visuallyHidden]}\n\t\t\t>\n\t\t\t\t{leading}\n\t\t\t</div>\n\t\t\t<div key=\"center\" classes={[fixedCss.center, classes.center]}>\n\t\t\t\t{center}\n\t\t\t</div>\n\t\t\t<div\n\t\t\t\tkey=\"trailing\"\n\t\t\t\tclasses={[classes.trailing, shouldCollapseTrailing && baseCss.visuallyHidden]}\n\t\t\t>\n\t\t\t\t{trailing}\n\t\t\t</div>\n\t\t</div>\n\t);\n});\n\nexport default ThreeColumnLayout;\n","import Registry from './Registry';\nimport { create as vdomCreate, diffProperty, dom as vdomDom, invalidator, isTextNode, renderer, w as vdomW } from './vdom';\nimport { from } from '../shim/array';\nimport global from '../shim/global';\nimport ThemeInjector from './ThemeInjector';\nconst RESERVED_PROPS = ['focus'];\nexport var CustomElementChildType;\n(function (CustomElementChildType) {\n    CustomElementChildType[\"DOJO\"] = \"DOJO\";\n    CustomElementChildType[\"NODE\"] = \"NODE\";\n    CustomElementChildType[\"TEXT\"] = \"TEXT\";\n})(CustomElementChildType || (CustomElementChildType = {}));\nfunction isElement(item) {\n    return item && item.nodeType === 1;\n}\nfunction isDojoChild(item) {\n    return isElement(item) && item.tagName.indexOf('-') > -1;\n}\nfunction w(node, properties, children) {\n    const wrappedWNode = vdomW(node, properties, children);\n    function wrapper(...args) {\n        const { domNode } = node;\n        if (args.length && domNode) {\n            setTimeout(() => {\n                domNode.dispatchEvent(new CustomEvent('render', {\n                    bubbles: false,\n                    detail: args\n                }));\n            });\n        }\n        return wrappedWNode;\n    }\n    Object.keys(wrappedWNode).forEach((key) => (wrapper[key] = wrappedWNode[key]));\n    return wrapper;\n}\nfunction dom(options, children) {\n    const wrappedDomNode = vdomDom(options, children);\n    function wrapper(...args) {\n        const { domNode } = wrappedDomNode;\n        if (args.length && domNode) {\n            setTimeout(() => {\n                domNode.dispatchEvent(new CustomEvent('render', {\n                    bubbles: false,\n                    detail: args\n                }));\n            });\n        }\n        return wrappedDomNode;\n    }\n    Object.keys(wrappedDomNode).forEach((key) => (wrapper[key] = wrappedDomNode[key]));\n    return wrapper;\n}\nconst factory = vdomCreate({ diffProperty, invalidator }).properties();\nexport function DomToWidgetWrapper(domNode) {\n    const wrapper = factory(function DomToWidgetWrapper({ properties, middleware: { invalidator, diffProperty } }) {\n        diffProperty('', invalidator);\n        const props = Object.keys(properties()).reduce((props, key) => {\n            const value = properties()[key];\n            if (key.indexOf('on') === 0 || RESERVED_PROPS.indexOf(key) !== -1) {\n                key = `__${key}`;\n            }\n            props[key] = value;\n            return props;\n        }, {});\n        return dom({ node: domNode, props, diffType: 'dom' });\n    });\n    wrapper.domNode = domNode;\n    return wrapper;\n}\nfunction registerThemeInjector(theme, themeRegistry) {\n    const themeInjector = new ThemeInjector(theme);\n    themeRegistry.defineInjector('__theme_injector', (invalidator) => {\n        themeInjector.setInvalidator(invalidator);\n        return () => themeInjector;\n    });\n    return themeInjector;\n}\nexport function create(descriptor, WidgetConstructor) {\n    const { attributes = [], properties = [], registryFactory = () => new Registry() } = descriptor;\n    const attributeMap = {};\n    attributes.forEach((propertyName) => {\n        const attributeName = propertyName.toLowerCase();\n        attributeMap[attributeName] = propertyName;\n    });\n    properties.forEach((propertyName) => {\n        const attributeName = propertyName.toLowerCase();\n        attributeMap[attributeName] = propertyName;\n    });\n    return class extends HTMLElement {\n        constructor() {\n            super(...arguments);\n            this._properties = {};\n            this._children = [];\n            this._eventProperties = {};\n            this._propertiesMap = {};\n            this._initialised = false;\n            this._childType = descriptor.childType;\n        }\n        connectedCallback() {\n            if (this._initialised) {\n                return;\n            }\n            this._waitTillReady();\n        }\n        _hasBeenParsed() {\n            if (document.readyState !== 'loading') {\n                return true;\n            }\n            let element = this;\n            while (element) {\n                if (element.nextSibling) {\n                    return true;\n                }\n                element = element.parentNode;\n            }\n            return false;\n        }\n        _waitTillReady() {\n            this._initialised = true;\n            if (this._hasBeenParsed()) {\n                this._readyCallback();\n            }\n            else {\n                setTimeout(() => {\n                    this._waitTillReady();\n                }, 100);\n            }\n        }\n        _readyCallback() {\n            const domProperties = {};\n            const { properties = [], events = [] } = descriptor;\n            this._properties = Object.assign({}, this._propertiesWithAttributes(properties), this._attributesToProperties(attributes));\n            [...attributes, ...properties].forEach((propertyName) => {\n                const isReservedProp = RESERVED_PROPS.indexOf(propertyName) !== -1;\n                const value = this._propertiesMap[propertyName] || !isReservedProp ? this[propertyName] : undefined;\n                let filteredPropertyName = propertyName.replace(/^on/, '__');\n                if (isReservedProp) {\n                    filteredPropertyName = `__${propertyName}`;\n                }\n                if (value !== undefined) {\n                    this._properties[propertyName] = value;\n                }\n                if (filteredPropertyName !== propertyName) {\n                    domProperties[filteredPropertyName] = {\n                        get: () => this._getProperty(propertyName),\n                        set: (value) => this._setProperty(propertyName, value)\n                    };\n                }\n                if (!isReservedProp) {\n                    domProperties[propertyName] = {\n                        get: () => this._getProperty(propertyName),\n                        set: (value) => this._setProperty(propertyName, value)\n                    };\n                }\n            });\n            events.forEach((propertyName) => {\n                const eventName = propertyName.replace(/^on/, '').toLowerCase();\n                const filteredPropertyName = propertyName.replace(/^on/, '__on');\n                domProperties[filteredPropertyName] = {\n                    get: () => this._getEventProperty(propertyName),\n                    set: (value) => this._setEventProperty(propertyName, value)\n                };\n                this._eventProperties[propertyName] = undefined;\n                this._properties[propertyName] = (...args) => {\n                    const eventCallback = this._getEventProperty(propertyName);\n                    if (typeof eventCallback === 'function') {\n                        eventCallback(...args);\n                    }\n                    this.dispatchEvent(new CustomEvent(eventName, {\n                        bubbles: false,\n                        detail: args\n                    }));\n                };\n            });\n            Object.defineProperties(this, domProperties);\n            const children = from(this.childNodes).filter((childNode) => !isTextNode(childNode) || childNode.data.replace(/^\\s+|\\s+$/g, ''));\n            if (!this._childType) {\n                if (children.some((child) => isDojoChild(child))) {\n                    this._childType = CustomElementChildType.DOJO;\n                }\n                else {\n                    this._childType = CustomElementChildType.NODE;\n                }\n            }\n            from(children).forEach((childNode) => {\n                if (this._childType === CustomElementChildType.DOJO) {\n                    childNode.addEventListener('dojo-ce-render', () => this._render());\n                    childNode.addEventListener('dojo-ce-connected', () => this._render());\n                    this._children.push(DomToWidgetWrapper(childNode));\n                }\n                else {\n                    this._children.push(dom({ node: childNode, diffType: 'dom' }));\n                }\n            });\n            this.addEventListener('dojo-ce-connected', (e) => this._childConnected(e));\n            const widgetProperties = this._properties;\n            const renderChildren = () => this.__children__();\n            const Wrapper = factory(() => w(WidgetConstructor, widgetProperties, renderChildren()));\n            const registry = registryFactory();\n            const themeContext = registerThemeInjector(this._getVariant() ? { theme: this._getTheme(), variant: this._getVariant() } : this._getTheme(), registry);\n            global.addEventListener('dojo-theme-set', () => {\n                const variant = this._getVariant();\n                if (variant !== 'noVariant') {\n                    themeContext.set(this._getTheme(), variant);\n                }\n                else {\n                    themeContext.set(this._getTheme());\n                }\n            });\n            const r = renderer(() => w(Wrapper, {}));\n            this._renderer = r;\n            r.mount({ domNode: this, merge: false, registry });\n            const root = this.children[0];\n            if (root) {\n                const { display = 'block' } = global.getComputedStyle(root);\n                this.style.display = display;\n            }\n            this.dispatchEvent(new CustomEvent('dojo-ce-connected', {\n                bubbles: true,\n                detail: this\n            }));\n        }\n        _getTheme() {\n            if (global && global.dojoce && global.dojoce.theme) {\n                return global.dojoce.themes[global.dojoce.theme];\n            }\n        }\n        _getVariant() {\n            if (global && global.dojoce && global.dojoce.variant) {\n                return global.dojoce.variant;\n            }\n        }\n        _childConnected(e) {\n            const node = e.detail;\n            if (node.parentNode === this) {\n                const exists = this._children.some((child) => child.domNode === node);\n                if (!exists) {\n                    node.addEventListener('dojo-ce-render', () => this._render());\n                    this._children.push(DomToWidgetWrapper(node));\n                    this._render();\n                }\n            }\n        }\n        _render() {\n            if (this._renderer) {\n                this._renderer.invalidate();\n                this.dispatchEvent(new CustomEvent('dojo-ce-render', {\n                    bubbles: false,\n                    detail: this\n                }));\n            }\n        }\n        __properties__() {\n            return Object.assign({}, this._properties, this._eventProperties);\n        }\n        __children__() {\n            if (this._children.some((child) => child.domNode.getAttribute && child.domNode.getAttribute('slot'))) {\n                const slots = this._children.reduce((slots, child) => {\n                    const { domNode } = child;\n                    const slotName = domNode.getAttribute && domNode.getAttribute('slot');\n                    if (!slotName) {\n                        return slots;\n                    }\n                    let slotResult = child.isFactory\n                        ? w(child, domNode.__properties__ ? Object.assign({}, domNode.__properties__()) : {}, domNode.__children__ ? [...domNode.__children__()] : [])\n                        : child;\n                    const existingSlotValue = slots[slotName];\n                    return Object.assign({}, slots, { [slotName]: existingSlotValue ? [...existingSlotValue, slotResult] : [slotResult] });\n                }, {});\n                return [\n                    Object.keys(slots).reduce((result, key) => {\n                        const value = slots[key];\n                        return Object.assign({}, result, { [key]: value.length === 1 ? value[0] : value });\n                    }, {})\n                ];\n            }\n            if (this._childType === CustomElementChildType.DOJO) {\n                return this._children.filter((Child) => Child.domNode.isWidget).map((Child) => {\n                    const { domNode } = Child;\n                    return w(Child, Object.assign({}, domNode.__properties__()), [...domNode.__children__()]);\n                });\n            }\n            else {\n                return this._children;\n            }\n        }\n        attributeChangedCallback(name, oldValue, value) {\n            const propertyName = attributeMap[name];\n            if (attributes.indexOf(propertyName) >= 0) {\n                this._setProperty(propertyName, value);\n            }\n            else {\n                try {\n                    const parsedValue = value ? JSON.parse(value) : null;\n                    this._setProperty(propertyName, parsedValue);\n                }\n                catch (e) {\n                    // if json parsing error, we do not set the property\n                }\n            }\n        }\n        _setEventProperty(propertyName, value) {\n            this._eventProperties[propertyName] = value;\n        }\n        _getEventProperty(propertyName) {\n            return this._eventProperties[propertyName];\n        }\n        _setProperty(propertyName, value) {\n            this._properties[propertyName] = value;\n            this._render();\n        }\n        _getProperty(propertyName) {\n            return this._properties[propertyName];\n        }\n        _propertiesWithAttributes(properties) {\n            return properties.reduce((properties, propertyName) => {\n                const attributeName = propertyName.toLowerCase();\n                const value = this.getAttribute(attributeName);\n                if (value !== null) {\n                    try {\n                        properties[propertyName] = JSON.parse(value);\n                    }\n                    catch (e) {\n                        // invalid json values do not get set\n                    }\n                }\n                return properties;\n            }, {});\n        }\n        _attributesToProperties(attributes) {\n            return attributes.reduce((properties, propertyName) => {\n                const attributeName = propertyName.toLowerCase();\n                const value = this.getAttribute(attributeName);\n                if (value !== null) {\n                    properties[propertyName] = value;\n                }\n                return properties;\n            }, {});\n        }\n        static get observedAttributes() {\n            return Object.keys(attributeMap);\n        }\n        get isWidget() {\n            return true;\n        }\n        set(key, value) {\n            this._propertiesMap[key] = value;\n            if (this._renderer) {\n                this._setProperty(key, value);\n            }\n        }\n    };\n}\nexport function register(WidgetConstructor) {\n    const descriptor = WidgetConstructor.__customElementDescriptor;\n    if (!descriptor) {\n        throw new Error('Cannot get descriptor for Custom Element, have you added the @customElement decorator to your Widget?');\n    }\n    global.customElements.define(descriptor.tagName, create(descriptor, WidgetConstructor));\n}\nexport default register;\n//# sourceMappingURL=registerCustomElement.mjs.map","import global from '../shim/global';\n/**\n * A cache of results of feature tests\n */\nexport const testCache = {};\n/**\n * A cache of the un-resolved feature tests\n */\nexport const testFunctions = {};\n/* Grab the staticFeatures if there are available */\nconst { staticFeatures } = global.DojoHasEnvironment || {};\n/* Cleaning up the DojoHasEnviornment */\nif ('DojoHasEnvironment' in global) {\n    delete global.DojoHasEnvironment;\n}\n/**\n * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n * returns a map.\n *\n * @param value The value to guard for\n */\nfunction isStaticFeatureFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * The cache of asserted features that were available in the global scope when the\n * module loaded\n */\nconst staticCache = staticFeatures\n    ? isStaticFeatureFunction(staticFeatures)\n        ? staticFeatures.apply(global)\n        : staticFeatures\n    : {}; /* Providing an empty cache, if none was in the environment\n\n\n/**\n* AMD plugin function.\n*\n* Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n* value(s).\n*\n* @param resourceId The id of the module\n* @param normalize Resolves a relative module id into an absolute module id\n*/\nexport function normalize(resourceId, normalize) {\n    const tokens = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n    let i = 0;\n    function get(skip) {\n        const term = tokens[i++];\n        if (term === ':') {\n            // empty string module name, resolves to null\n            return null;\n        }\n        else {\n            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n            if (tokens[i++] === '?') {\n                if (!skip && has(term)) {\n                    // matched the feature, get the first value from the options\n                    return get();\n                }\n                else {\n                    // did not match, get the second value, passing over the first\n                    get(true);\n                    return get(skip);\n                }\n            }\n            // a module\n            return term;\n        }\n    }\n    const id = get();\n    return id && normalize(id);\n}\n/**\n * Check if a feature has already been registered\n *\n * @param feature the name of the feature\n */\nexport function exists(feature) {\n    const normalizedFeature = feature.toLowerCase();\n    return Boolean(normalizedFeature in staticCache || normalizedFeature in testCache || testFunctions[normalizedFeature]);\n}\n/**\n * Register a new test for a named feature.\n *\n * @example\n * has.add('dom-addeventlistener', !!document.addEventListener);\n *\n * @example\n * has.add('touch-events', function () {\n *    return 'ontouchstart' in document\n * });\n *\n * @param feature the name of the feature\n * @param value the value reported of the feature, or a function that will be executed once on first test\n * @param overwrite if an existing value should be overwritten. Defaults to false.\n */\nexport function add(feature, value, overwrite = false) {\n    const normalizedFeature = feature.toLowerCase();\n    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {\n        throw new TypeError(`Feature \"${feature}\" exists and overwrite not true.`);\n    }\n    if (typeof value === 'function') {\n        testFunctions[normalizedFeature] = value;\n    }\n    else {\n        testCache[normalizedFeature] = value;\n        delete testFunctions[normalizedFeature];\n    }\n}\n/**\n * Return the current value of a named feature.\n *\n * @param feature The name of the feature to test.\n */\nexport default function has(feature, strict = false) {\n    let result;\n    const normalizedFeature = feature.toLowerCase();\n    if (normalizedFeature in staticCache) {\n        result = staticCache[normalizedFeature];\n    }\n    else if (testFunctions[normalizedFeature]) {\n        result = testCache[normalizedFeature] = testFunctions[normalizedFeature].call(null);\n        delete testFunctions[normalizedFeature];\n    }\n    else if (normalizedFeature in testCache) {\n        result = testCache[normalizedFeature];\n    }\n    else if (strict) {\n        throw new TypeError(`Attempt to detect unregistered has feature \"${feature}\"`);\n    }\n    return result;\n}\n/*\n * Out of the box feature tests\n */\nadd('public-path', undefined);\n/* flag for dojo debug, default to false */\nadd('dojo-debug', false);\n/* Detects if the environment is \"browser like\" */\nadd('host-browser', true);\n/* Detects if the environment is \"jsdom\" */\nadd('host-jsdom', true && typeof navigator !== 'undefined' && navigator.userAgent.indexOf('jsdom') !== -1);\n/* Detects if the environment appears to be NodeJS */\nadd('host-node', false);\nadd('fetch', true);\nadd('es6-array', true);\nadd('es6-array-fill', true);\nadd('es7-array', true);\nadd('es2019-array', true);\n/* Map */\nadd('es6-map', true);\nadd('es6-iterator', true);\n/* Math */\nadd('es6-math', true);\nadd('es6-math-imul', true);\n/* Object */\nadd('es6-object', true);\nadd('es2017-object', true);\n/* Observable */\nadd('es-observable', false);\n/* Promise */\nadd('es6-promise', true);\nadd('es2018-promise-finally', () => true && typeof global.Promise.prototype.finally !== 'undefined', true);\n/* Set */\nadd('es6-set', true);\n/* String */\nadd('es6-string', true);\nadd('es6-string-raw', true);\nadd('es2017-string', true);\n/* Symbol */\nadd('es6-symbol', true);\n/* WeakMap */\nadd('es6-weakmap', true);\n/* Miscellaneous features */\nadd('microtasks', true);\nadd('postmessage', true);\nadd('raf', true);\nadd('setimmediate', false);\n/* DOM Features */\nadd('dom-mutationobserver', true);\nadd('dom-webanimation', () => true && global.Animation !== undefined && global.KeyframeEffect !== undefined, true);\nadd('abort-controller', () => typeof global.AbortController !== 'undefined');\nadd('abort-signal', () => typeof global.AbortSignal !== 'undefined');\nadd('dom-intersection-observer', () => true && global.IntersectionObserver !== undefined, true);\nadd('dom-resize-observer', () => true && global.ResizeObserver !== undefined, true);\nadd('dom-pointer-events', () => true && global.onpointerdown !== undefined, true);\nadd('dom-css-variables', true);\nadd('dom-inert', () => true && Element.prototype.hasOwnProperty('inert'), true);\nadd('build-elide', false);\nadd('test', false);\nadd('global-this', () => typeof global.globalThis !== 'undefined');\n//# sourceMappingURL=has.mjs.map","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ResizeObserver = factory());\n}(this, (function () { 'use strict';\n\n/**\n * A collection of shims that provide minimal functionality of the ES6 collections.\n *\n * These implementations are not meant to be used outside of the ResizeObserver\n * modules as they cover only a limited range of use cases.\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = (function () {\n    if (typeof Map !== 'undefined') {\n        return Map;\n    }\n\n    /**\n     * Returns index in provided array that matches the specified key.\n     *\n     * @param {Array<Array>} arr\n     * @param {*} key\n     * @returns {number}\n     */\n    function getIndex(arr, key) {\n        var result = -1;\n\n        arr.some(function (entry, index) {\n            if (entry[0] === key) {\n                result = index;\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    return (function () {\n        function anonymous() {\n            this.__entries__ = [];\n        }\n\n        var prototypeAccessors = { size: { configurable: true } };\n\n        /**\n         * @returns {boolean}\n         */\n        prototypeAccessors.size.get = function () {\n            return this.__entries__.length;\n        };\n\n        /**\n         * @param {*} key\n         * @returns {*}\n         */\n        anonymous.prototype.get = function (key) {\n            var index = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index];\n\n            return entry && entry[1];\n        };\n\n        /**\n         * @param {*} key\n         * @param {*} value\n         * @returns {void}\n         */\n        anonymous.prototype.set = function (key, value) {\n            var index = getIndex(this.__entries__, key);\n\n            if (~index) {\n                this.__entries__[index][1] = value;\n            } else {\n                this.__entries__.push([key, value]);\n            }\n        };\n\n        /**\n         * @param {*} key\n         * @returns {void}\n         */\n        anonymous.prototype.delete = function (key) {\n            var entries = this.__entries__;\n            var index = getIndex(entries, key);\n\n            if (~index) {\n                entries.splice(index, 1);\n            }\n        };\n\n        /**\n         * @param {*} key\n         * @returns {void}\n         */\n        anonymous.prototype.has = function (key) {\n            return !!~getIndex(this.__entries__, key);\n        };\n\n        /**\n         * @returns {void}\n         */\n        anonymous.prototype.clear = function () {\n            this.__entries__.splice(0);\n        };\n\n        /**\n         * @param {Function} callback\n         * @param {*} [ctx=null]\n         * @returns {void}\n         */\n        anonymous.prototype.forEach = function (callback, ctx) {\n            var this$1 = this;\n            if ( ctx === void 0 ) ctx = null;\n\n            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {\n                var entry = list[i];\n\n                callback.call(ctx, entry[1], entry[0]);\n            }\n        };\n\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\n\n        return anonymous;\n    }());\n})();\n\n/**\n * Detects whether window and document objects are available in current environment.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = (function () {\n    if (typeof global !== 'undefined' && global.Math === Math) {\n        return global;\n    }\n\n    if (typeof self !== 'undefined' && self.Math === Math) {\n        return self;\n    }\n\n    if (typeof window !== 'undefined' && window.Math === Math) {\n        return window;\n    }\n\n    // eslint-disable-next-line no-new-func\n    return Function('return this')();\n})();\n\n/**\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\n * first one is not supported.\n *\n * @returns {number} Requests' identifier.\n */\nvar requestAnimationFrame$1 = (function () {\n    if (typeof requestAnimationFrame === 'function') {\n        // It's required to use a bounded function because IE sometimes throws\n        // an \"Invalid calling object\" error if rAF is invoked without the global\n        // object on the left hand side.\n        return requestAnimationFrame.bind(global$1);\n    }\n\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\n})();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n\n/**\n * Creates a wrapper function which ensures that provided callback will be\n * invoked only once during the specified delay period.\n *\n * @param {Function} callback - Function to be invoked after the delay period.\n * @param {number} delay - Delay after which to invoke callback.\n * @returns {Function}\n */\nvar throttle = function (callback, delay) {\n    var leadingCall = false,\n        trailingCall = false,\n        lastCallTime = 0;\n\n    /**\n     * Invokes the original callback function and schedules new invocation if\n     * the \"proxy\" was called during current request.\n     *\n     * @returns {void}\n     */\n    function resolvePending() {\n        if (leadingCall) {\n            leadingCall = false;\n\n            callback();\n        }\n\n        if (trailingCall) {\n            proxy();\n        }\n    }\n\n    /**\n     * Callback invoked after the specified delay. It will further postpone\n     * invocation of the original function delegating it to the\n     * requestAnimationFrame.\n     *\n     * @returns {void}\n     */\n    function timeoutCallback() {\n        requestAnimationFrame$1(resolvePending);\n    }\n\n    /**\n     * Schedules invocation of the original function.\n     *\n     * @returns {void}\n     */\n    function proxy() {\n        var timeStamp = Date.now();\n\n        if (leadingCall) {\n            // Reject immediately following calls.\n            if (timeStamp - lastCallTime < trailingTimeout) {\n                return;\n            }\n\n            // Schedule new call to be in invoked when the pending one is resolved.\n            // This is important for \"transitions\" which never actually start\n            // immediately so there is a chance that we might miss one if change\n            // happens amids the pending invocation.\n            trailingCall = true;\n        } else {\n            leadingCall = true;\n            trailingCall = false;\n\n            setTimeout(timeoutCallback, delay);\n        }\n\n        lastCallTime = timeStamp;\n    }\n\n    return proxy;\n};\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n\n/**\n * Singleton controller class which handles updates of ResizeObserver instances.\n */\nvar ResizeObserverController = function() {\n    this.connected_ = false;\n    this.mutationEventsAdded_ = false;\n    this.mutationsObserver_ = null;\n    this.observers_ = [];\n\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n};\n\n/**\n * Adds observer to observers list.\n *\n * @param {ResizeObserverSPI} observer - Observer to be added.\n * @returns {void}\n */\n\n\n/**\n * Holds reference to the controller's instance.\n *\n * @private {ResizeObserverController}\n */\n\n\n/**\n * Keeps reference to the instance of MutationObserver.\n *\n * @private {MutationObserver}\n */\n\n/**\n * Indicates whether DOM listeners have been added.\n *\n * @private {boolean}\n */\nResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n        this.observers_.push(observer);\n    }\n\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n        this.connect_();\n    }\n};\n\n/**\n * Removes observer from observers list.\n *\n * @param {ResizeObserverSPI} observer - Observer to be removed.\n * @returns {void}\n */\nResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n\n    // Remove observer if it's present in registry.\n    if (~index) {\n        observers.splice(index, 1);\n    }\n\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n        this.disconnect_();\n    }\n};\n\n/**\n * Invokes the update of observers. It will continue running updates insofar\n * it detects changes.\n *\n * @returns {void}\n */\nResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n        this.refresh();\n    }\n};\n\n/**\n * Updates every observer from observers list and notifies them of queued\n * entries.\n *\n * @private\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\n *  dimensions of it's elements.\n */\nResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n        return observer.gatherActive(), observer.hasActive();\n    });\n\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\n\n    return activeObservers.length > 0;\n};\n\n/**\n * Initializes DOM listeners.\n *\n * @private\n * @returns {void}\n */\nResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n        return;\n    }\n\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n\n    window.addEventListener('resize', this.refresh);\n\n    if (mutationObserverSupported) {\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\n\n        this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n        });\n    } else {\n        document.addEventListener('DOMSubtreeModified', this.refresh);\n\n        this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n};\n\n/**\n * Removes DOM listeners.\n *\n * @private\n * @returns {void}\n */\nResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n        return;\n    }\n\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n\n    if (this.mutationsObserver_) {\n        this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n};\n\n/**\n * \"Transitionend\" event handler.\n *\n * @private\n * @param {TransitionEvent} event\n * @returns {void}\n */\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\n        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';\n\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n        return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n        this.refresh();\n    }\n};\n\n/**\n * Returns instance of the ResizeObserverController.\n *\n * @returns {ResizeObserverController}\n */\nResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n        this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n};\n\nResizeObserverController.instance_ = null;\n\n/**\n * Defines non-writable/enumerable properties of the provided target object.\n *\n * @param {Object} target - Object for which to define properties.\n * @param {Object} props - Properties to be defined.\n * @returns {Object} Target object.\n */\nvar defineConfigurable = (function (target, props) {\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\n        var key = list[i];\n\n        Object.defineProperty(target, key, {\n            value: props[key],\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n    }\n\n    return target;\n});\n\n/**\n * Returns the global object associated with provided element.\n *\n * @param {Object} target\n * @returns {Object}\n */\nvar getWindowOf = (function (target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n\n    // Return the local global object if it's not possible extract one from\n    // provided element.\n    return ownerGlobal || global$1;\n});\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n\n/**\n * Converts provided string to a number.\n *\n * @param {number|string} value\n * @returns {number}\n */\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\n/**\n * Extracts borders size from provided styles.\n *\n * @param {CSSStyleDeclaration} styles\n * @param {...string} positions - Borders positions (top, right, ...)\n * @returns {number}\n */\nfunction getBordersSize(styles) {\n    var positions = [], len = arguments.length - 1;\n    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];\n\n    return positions.reduce(function (size, position) {\n        var value = styles['border-' + position + '-width'];\n\n        return size + toFloat(value);\n    }, 0);\n}\n\n/**\n * Extracts paddings sizes from provided styles.\n *\n * @param {CSSStyleDeclaration} styles\n * @returns {Object} Paddings box.\n */\nfunction getPaddings(styles) {\n    var positions = ['top', 'right', 'bottom', 'left'];\n    var paddings = {};\n\n    for (var i = 0, list = positions; i < list.length; i += 1) {\n        var position = list[i];\n\n        var value = styles['padding-' + position];\n\n        paddings[position] = toFloat(value);\n    }\n\n    return paddings;\n}\n\n/**\n * Calculates content rectangle of provided SVG element.\n *\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\n *      to be calculated.\n * @returns {DOMRectInit}\n */\nfunction getSVGContentRect(target) {\n    var bbox = target.getBBox();\n\n    return createRectInit(0, 0, bbox.width, bbox.height);\n}\n\n/**\n * Calculates content rectangle of provided HTMLElement.\n *\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\n * @returns {DOMRectInit}\n */\nfunction getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth;\n    var clientHeight = target.clientHeight;\n\n    // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n    if (!clientWidth && !clientHeight) {\n        return emptyRect;\n    }\n\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom;\n\n    // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n    var width = toFloat(styles.width),\n        height = toFloat(styles.height);\n\n    // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n    if (styles.boxSizing === 'border-box') {\n        // Following conditions are required to handle Internet Explorer which\n        // doesn't include paddings and borders to computed CSS dimensions.\n        //\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\n        // properties then it's either IE, and thus we don't need to subtract\n        // anything, or an element merely doesn't have paddings/borders styles.\n        if (Math.round(width + horizPad) !== clientWidth) {\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\n        }\n\n        if (Math.round(height + vertPad) !== clientHeight) {\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n        }\n    }\n\n    // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n    if (!isDocumentElement(target)) {\n        // In some browsers (only in Firefox, actually) CSS width & height\n        // include scroll bars size which can be removed at this step as scroll\n        // bars are the only difference between rounded dimensions + paddings\n        // and \"client\" properties, though that is not always true in Chrome.\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n\n        // Chrome has a rather weird rounding of \"client\" properties.\n        // E.g. for an element with content width of 314.2px it sometimes gives\n        // the client width of 315px and for the width of 314.7px it may give\n        // 314px. And it doesn't happen all the time. So just ignore this delta\n        // as a non-relevant.\n        if (Math.abs(vertScrollbar) !== 1) {\n            width -= vertScrollbar;\n        }\n\n        if (Math.abs(horizScrollbar) !== 1) {\n            height -= horizScrollbar;\n        }\n    }\n\n    return createRectInit(paddings.left, paddings.top, width, height);\n}\n\n/**\n * Checks whether provided element is an instance of the SVGGraphicsElement.\n *\n * @param {Element} target - Element to be checked.\n * @returns {boolean}\n */\nvar isSVGGraphicsElement = (function () {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== 'undefined') {\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\n    }\n\n    // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };\n})();\n\n/**\n * Checks whether provided element is a document element (<html>).\n *\n * @param {Element} target - Element to be checked.\n * @returns {boolean}\n */\nfunction isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n}\n\n/**\n * Calculates an appropriate content rectangle for provided html or svg element.\n *\n * @param {Element} target - Element content rectangle of which needs to be calculated.\n * @returns {DOMRectInit}\n */\nfunction getContentRect(target) {\n    if (!isBrowser) {\n        return emptyRect;\n    }\n\n    if (isSVGGraphicsElement(target)) {\n        return getSVGContentRect(target);\n    }\n\n    return getHTMLElementContentRect(target);\n}\n\n/**\n * Creates rectangle with an interface of the DOMRectReadOnly.\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\n *\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\n * @returns {DOMRectReadOnly}\n */\nfunction createReadOnlyRect(ref) {\n    var x = ref.x;\n    var y = ref.y;\n    var width = ref.width;\n    var height = ref.height;\n\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype);\n\n    // Rectangle's properties are not writable and non-enumerable.\n    defineConfigurable(rect, {\n        x: x, y: y, width: width, height: height,\n        top: y,\n        right: x + width,\n        bottom: height + y,\n        left: x\n    });\n\n    return rect;\n}\n\n/**\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n * @param {number} width - Rectangle's width.\n * @param {number} height - Rectangle's height.\n * @returns {DOMRectInit}\n */\nfunction createRectInit(x, y, width, height) {\n    return { x: x, y: y, width: width, height: height };\n}\n\n/**\n * Class that is responsible for computations of the content rectangle of\n * provided DOM element and for keeping track of it's changes.\n */\nvar ResizeObservation = function(target) {\n    this.broadcastWidth = 0;\n    this.broadcastHeight = 0;\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n\n    this.target = target;\n};\n\n/**\n * Updates content rectangle and tells whether it's width or height properties\n * have changed since the last broadcast.\n *\n * @returns {boolean}\n */\n\n\n/**\n * Reference to the last observed content rectangle.\n *\n * @private {DOMRectInit}\n */\n\n\n/**\n * Broadcasted width of content rectangle.\n *\n * @type {number}\n */\nResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n\n    this.contentRect_ = rect;\n\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n};\n\n/**\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\n * from the corresponding properties of the last observed content rectangle.\n *\n * @returns {DOMRectInit} Last observed content rectangle.\n */\nResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n\n    return rect;\n};\n\nvar ResizeObserverEntry = function(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, { target: target, contentRect: contentRect });\n};\n\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\n    this.activeObservations_ = [];\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== 'function') {\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n};\n\n/**\n * Starts observing provided element.\n *\n * @param {Element} target - Element to be observed.\n * @returns {void}\n */\n\n\n/**\n * Registry of the ResizeObservation instances.\n *\n * @private {Map<Element, ResizeObservation>}\n */\n\n\n/**\n * Public ResizeObserver instance which will be passed to the callback\n * function and used as a value of it's \"this\" binding.\n *\n * @private {ResizeObserver}\n */\n\n/**\n * Collection of resize observations that have detected changes in dimensions\n * of elements.\n *\n * @private {Array<ResizeObservation>}\n */\nResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n        return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n\n    this.controller_.addObserver(this);\n\n    // Force the update of observations.\n    this.controller_.refresh();\n};\n\n/**\n * Stops observing provided element.\n *\n * @param {Element} target - Element to stop observing.\n * @returns {void}\n */\nResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n        return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n        this.controller_.removeObserver(this);\n    }\n};\n\n/**\n * Stops observing all elements.\n *\n * @returns {void}\n */\nResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n};\n\n/**\n * Collects observation instances the associated element of which has changed\n * it's content rectangle.\n *\n * @returns {void}\n */\nResizeObserverSPI.prototype.gatherActive = function () {\n        var this$1 = this;\n\n    this.clearActive();\n\n    this.observations_.forEach(function (observation) {\n        if (observation.isActive()) {\n            this$1.activeObservations_.push(observation);\n        }\n    });\n};\n\n/**\n * Invokes initial callback function with a list of ResizeObserverEntry\n * instances collected from active resize observations.\n *\n * @returns {void}\n */\nResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n        return;\n    }\n\n    var ctx = this.callbackCtx_;\n\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n};\n\n/**\n * Clears the collection of active observations.\n *\n * @returns {void}\n */\nResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n};\n\n/**\n * Tells whether observer has active observations.\n *\n * @returns {boolean}\n */\nResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n};\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n\n/**\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\n * exposing only those methods and properties that are defined in the spec.\n */\nvar ResizeObserver = function(callback) {\n    if (!(this instanceof ResizeObserver)) {\n        throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n\n    observers.set(this, observer);\n};\n\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n    ResizeObserver.prototype[method] = function () {\n        return (ref = observers.get(this))[method].apply(ref, arguments);\n        var ref;\n    };\n});\n\nvar index = (function () {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== 'undefined') {\n        return global$1.ResizeObserver;\n    }\n\n    return ResizeObserver;\n})();\n\nreturn index;\n\n})));\n","import Promise from '../shim/Promise';\nimport Map from '../shim/Map';\nimport { Evented } from '../core/Evented';\n/**\n * Widget base type\n */\nexport const WIDGET_BASE_TYPE = '__widget_base_type';\n/**\n * Checks is the item is a subclass of WidgetBase (or a WidgetBase)\n *\n * @param item the item to check\n * @returns true/false indicating if the item is a WidgetBaseConstructor\n */\nexport function isWidgetBaseConstructor(item) {\n    return Boolean(item && item._type === WIDGET_BASE_TYPE);\n}\nexport function isWidgetFunction(item) {\n    return Boolean(item && item.isWidget);\n}\nexport function isWNodeFactory(node) {\n    if (typeof node === 'function' && node.isFactory) {\n        return true;\n    }\n    return false;\n}\nexport function isWidget(item) {\n    return isWidgetBaseConstructor(item) || isWidgetFunction(item);\n}\nexport function isWidgetConstructorDefaultExport(item) {\n    return Boolean(item &&\n        item.hasOwnProperty('__esModule') &&\n        item.hasOwnProperty('default') &&\n        (isWidget(item.default) || isWNodeFactory(item.default)));\n}\n/**\n * The Registry implementation\n */\nexport class Registry extends Evented {\n    /**\n     * Emit loaded event for registry label\n     */\n    emitLoadedEvent(widgetLabel, item) {\n        this.emit({\n            type: widgetLabel,\n            action: 'loaded',\n            item\n        });\n    }\n    define(label, item) {\n        if (this._widgetRegistry === undefined) {\n            this._widgetRegistry = new Map();\n        }\n        if (this._widgetRegistry.has(label)) {\n            throw new Error(`widget has already been registered for '${label.toString()}'`);\n        }\n        this._widgetRegistry.set(label, item);\n        if (item instanceof Promise) {\n            item.then((widgetCtor) => {\n                this._widgetRegistry.set(label, widgetCtor);\n                this.emitLoadedEvent(label, widgetCtor);\n                return widgetCtor;\n            }, (error) => {\n                throw error;\n            });\n        }\n        else if (isWidgetBaseConstructor(item)) {\n            this.emitLoadedEvent(label, item);\n        }\n    }\n    defineInjector(label, injectorFactory) {\n        if (this._injectorRegistry === undefined) {\n            this._injectorRegistry = new Map();\n        }\n        if (this._injectorRegistry.has(label)) {\n            throw new Error(`injector has already been registered for '${label.toString()}'`);\n        }\n        const invalidator = new Evented();\n        const injectorItem = {\n            injector: injectorFactory(() => invalidator.emit({ type: 'invalidate' })),\n            invalidator\n        };\n        this._injectorRegistry.set(label, injectorItem);\n        this.emitLoadedEvent(label, injectorItem);\n    }\n    get(label) {\n        if (!this._widgetRegistry || !this.has(label)) {\n            return null;\n        }\n        const item = this._widgetRegistry.get(label);\n        if (isWidget(item) || isWNodeFactory(item)) {\n            return item;\n        }\n        if (item instanceof Promise) {\n            return null;\n        }\n        const promise = item();\n        this._widgetRegistry.set(label, promise);\n        promise.then((widgetCtor) => {\n            if (isWidgetConstructorDefaultExport(widgetCtor)) {\n                widgetCtor = widgetCtor.default;\n            }\n            this._widgetRegistry.set(label, widgetCtor);\n            this.emitLoadedEvent(label, widgetCtor);\n            return widgetCtor;\n        }, (error) => {\n            throw error;\n        });\n        return null;\n    }\n    getInjector(label) {\n        if (!this._injectorRegistry || !this.hasInjector(label)) {\n            return null;\n        }\n        return this._injectorRegistry.get(label);\n    }\n    has(label) {\n        return Boolean(this._widgetRegistry && this._widgetRegistry.has(label));\n    }\n    hasInjector(label) {\n        return Boolean(this._injectorRegistry && this._injectorRegistry.has(label));\n    }\n}\nexport default Registry;\n//# sourceMappingURL=Registry.mjs.map","import global from './global';\nimport has from '../core/has';\n// !has('build-elide')\nimport * as Resize from 'resize-observer-polyfill';\nimport wrapper from './util/wrapper';\nif (!has('build-elide')) {\n    if (!global.ResizeObserver) {\n        // default is undefined when UMD module is used\n        global.ResizeObserver = Resize.default || Resize;\n    }\n}\nexport default wrapper('ResizeObserver', true);","import global from '../global';\nimport has from '../../core/has';\nexport default function wrapper(nameOnGlobal, constructor = false, bind = false) {\n    if (has('test')) {\n        if (constructor) {\n            return function (...args) {\n                return new global[nameOnGlobal](...args);\n            };\n        }\n        else {\n            return function (...args) {\n                return global[nameOnGlobal](...args);\n            };\n        }\n    }\n    return bind ? global[nameOnGlobal].bind(global) : global[nameOnGlobal];\n}\n//# sourceMappingURL=wrapper.mjs.map","import ResizeObserver from '../../shim/ResizeObserver';\nimport { create, node, destroy } from '../vdom';\nimport { icache } from './icache';\nconst factory = create({ node, destroy, icache });\nexport const resize = factory(({ middleware: { node, destroy, icache } }) => {\n    const keys = [];\n    const handles = [];\n    destroy(() => {\n        let handle;\n        while ((handle = handles.pop())) {\n            handle && handle();\n        }\n    });\n    return {\n        get(key) {\n            const domNode = node.get(key);\n            if (!domNode) {\n                return null;\n            }\n            if (keys.indexOf(key) === -1) {\n                keys.push(key);\n                const resizeObserver = new ResizeObserver(([entry]) => {\n                    icache.set(key, entry.contentRect);\n                });\n                resizeObserver.observe(domNode);\n                handles.push(() => resizeObserver.disconnect());\n            }\n            return icache.get(key) || null;\n        }\n    };\n});\nexport default resize;\n//# sourceMappingURL=resize.mjs.map","import global from './global';\nvar isArrayLike = undefined;\n// !has('es6-iterator')\n// elided: import './iterator'\nimport has from '../core/has';\n// !has('es6-symbol')\n// elided: import './Symbol'\nexport let WeakMap = global.WeakMap;\nif (!true) {\n    const DELETED = {};\n    const getUID = function getUID() {\n        return Math.floor(Math.random() * 100000000);\n    };\n    const generateName = (function () {\n        let startId = Math.floor(Date.now() % 100000000);\n        return function generateName() {\n            return '__wm' + getUID() + (startId++ + '__');\n        };\n    })();\n    WeakMap = global.WeakMap = class WeakMap {\n        constructor(iterable) {\n            this[Symbol.toStringTag] = 'WeakMap';\n            this._name = generateName();\n            this._frozenEntries = [];\n            if (iterable) {\n                if (isArrayLike(iterable)) {\n                    for (let i = 0; i < iterable.length; i++) {\n                        const item = iterable[i];\n                        this.set(item[0], item[1]);\n                    }\n                }\n                else {\n                    for (const [key, value] of iterable) {\n                        this.set(key, value);\n                    }\n                }\n            }\n        }\n        _getFrozenEntryIndex(key) {\n            for (let i = 0; i < this._frozenEntries.length; i++) {\n                if (this._frozenEntries[i].key === key) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        delete(key) {\n            if (key === undefined || key === null) {\n                return false;\n            }\n            const entry = key[this._name];\n            if (entry && entry.key === key && entry.value !== DELETED) {\n                entry.value = DELETED;\n                return true;\n            }\n            const frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                this._frozenEntries.splice(frozenIndex, 1);\n                return true;\n            }\n            return false;\n        }\n        get(key) {\n            if (key === undefined || key === null) {\n                return undefined;\n            }\n            const entry = key[this._name];\n            if (entry && entry.key === key && entry.value !== DELETED) {\n                return entry.value;\n            }\n            const frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                return this._frozenEntries[frozenIndex].value;\n            }\n        }\n        has(key) {\n            if (key === undefined || key === null) {\n                return false;\n            }\n            const entry = key[this._name];\n            if (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n                return true;\n            }\n            const frozenIndex = this._getFrozenEntryIndex(key);\n            if (frozenIndex >= 0) {\n                return true;\n            }\n            return false;\n        }\n        set(key, value) {\n            if (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n                throw new TypeError('Invalid value used as weak map key');\n            }\n            let entry = key[this._name];\n            if (!entry || entry.key !== key) {\n                entry = Object.create(null, {\n                    key: { value: key }\n                });\n                if (Object.isFrozen(key)) {\n                    this._frozenEntries.push(entry);\n                }\n                else {\n                    Object.defineProperty(key, this._name, {\n                        value: entry\n                    });\n                }\n            }\n            entry.value = value;\n            return this;\n        }\n    };\n}\nexport default WeakMap;","import global from '../shim/global';\nimport Injector from './Injector';\nimport cssVars from '../shim/cssVariables';\nimport Map from '../shim/Map';\nimport has from './has';\nexport function isVariantModule(variant) {\n    return typeof variant !== 'string';\n}\nexport function isThemeWithVariant(theme) {\n    return theme && theme.hasOwnProperty('variant');\n}\nexport function isThemeWithVariants(theme) {\n    return theme && theme.hasOwnProperty('variants');\n}\nexport function isThemeInjectorPayloadWithVariant(theme) {\n    return !!theme && theme.hasOwnProperty('variant');\n}\nlet processCssVariant = function (_) { };\nif (!true) {\n    const setUpCssVariantSupport = () => {\n        const styleId = '__dojo_processed_styles';\n        const processedCssMap = new Map();\n        let variantStyleElement;\n        function applyStyles(css) {\n            const style = document.createElement('style');\n            style.textContent = css;\n            style.setAttribute('id', styleId);\n            if (variantStyleElement && variantStyleElement.parentNode) {\n                variantStyleElement.parentNode.replaceChild(style, variantStyleElement);\n            }\n            else {\n                global.document.head.appendChild(style);\n            }\n            variantStyleElement = style;\n        }\n        return function processCssVariant(variantName) {\n            const processedCss = processedCssMap.get(variantName);\n            if (processedCss) {\n                applyStyles(processedCss);\n            }\n            else {\n                cssVars({\n                    exclude: `style[id=${styleId}]`,\n                    onSuccess: (css) => {\n                        let temp = css;\n                        let index = temp.indexOf(variantName);\n                        let variantCss = '';\n                        while (index !== -1) {\n                            temp = temp.substring(index + variantName.length);\n                            const match = temp.match(/\\{([^}]+)\\}/);\n                            if (match) {\n                                if (variantCss) {\n                                    variantCss = `${variantCss.substring(0, variantCss.length - 1)}${match[0].substring(1)}`;\n                                }\n                                else {\n                                    variantCss = match[0];\n                                }\n                            }\n                            index = temp.indexOf(variantName);\n                        }\n                        if (variantCss) {\n                            css = `:root ${variantCss}${css}`;\n                        }\n                        return css;\n                    },\n                    onComplete: (css) => {\n                        processedCssMap.set(variantName, css);\n                        applyStyles(css);\n                    },\n                    updateDOM: false,\n                    silent: true\n                });\n            }\n        };\n    };\n    processCssVariant = setUpCssVariantSupport();\n}\nfunction createThemeInjectorPayload(theme, variant) {\n    if (isThemeWithVariant(theme)) {\n        if (typeof theme.variant === 'string') {\n            return {\n                theme: theme.theme,\n                variant: { name: theme.variant, value: theme.theme.variants[theme.variant] }\n            };\n        }\n        return { theme: theme.theme, variant: theme.variant };\n    }\n    else if (isThemeWithVariants(theme)) {\n        variant = variant || 'default';\n        if (isVariantModule(variant)) {\n            if (!true) {\n                processCssVariant(variant.value.root);\n            }\n            return { theme, variant };\n        }\n        if (!true) {\n            processCssVariant(theme.variants[variant].root);\n        }\n        return { theme: theme, variant: { name: variant, value: theme.variants[variant] } };\n    }\n    return { theme };\n}\nexport class ThemeInjector extends Injector {\n    constructor(theme) {\n        super(theme ? createThemeInjectorPayload(theme) : theme);\n    }\n    set(theme, variant) {\n        super.set(createThemeInjectorPayload(theme, variant));\n    }\n    get() {\n        return super.get();\n    }\n}\nexport default ThemeInjector;\n//# sourceMappingURL=ThemeInjector.mjs.map","/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nexport function getValueDescriptor(value, enumerable = false, writable = true, configurable = true) {\n    return {\n        value: value,\n        enumerable: enumerable,\n        writable: writable,\n        configurable: configurable\n    };\n}\nexport function wrapNative(nativeFunction) {\n    return function (target, ...args) {\n        return nativeFunction.apply(target, args);\n    };\n}\n//# sourceMappingURL=util.mjs.map","var _a;\nimport global from './global';\nvar queueMicroTask = undefined;\n// !has('microtasks')\n// elided: import './support/queue'\n// !has('es6-symbol')\n// elided: import './Symbol'\nimport has from '../core/has';\nexport let ShimPromise = global.Promise;\nexport const isThenable = function isThenable(value) {\n    return value && typeof value.then === 'function';\n};\nif (!true) {\n    global.Promise = ShimPromise = (_a = class Promise {\n            /**\n             * Creates a new Promise.\n             *\n             * @constructor\n             *\n             * @param executor\n             * The executor function is called immediately when the Promise is instantiated. It is responsible for\n             * starting the asynchronous operation when it is invoked.\n             *\n             * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n             * successfully, or the `reject` function when the operation fails.\n             */\n            constructor(executor) {\n                /**\n                 * The current state of this promise.\n                 */\n                this.state = 1 /* Pending */;\n                this[Symbol.toStringTag] = 'Promise';\n                /**\n                 * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n                 */\n                let isChained = false;\n                /**\n                 * Whether or not this promise is in a resolved state.\n                 */\n                const isResolved = () => {\n                    return this.state !== 1 /* Pending */ || isChained;\n                };\n                /**\n                 * Callbacks that should be invoked once the asynchronous operation has completed.\n                 */\n                let callbacks = [];\n                /**\n                 * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n                 * enqueues callbacks for execution on the next event loop turn.\n                 */\n                let whenFinished = function (callback) {\n                    if (callbacks) {\n                        callbacks.push(callback);\n                    }\n                };\n                /**\n                 * Settles this promise.\n                 *\n                 * @param newState The resolved state for this promise.\n                 * @param {T|any} value The resolved value for this promise.\n                 */\n                const settle = (newState, value) => {\n                    // A promise can only be settled once.\n                    if (this.state !== 1 /* Pending */) {\n                        return;\n                    }\n                    this.state = newState;\n                    this.resolvedValue = value;\n                    whenFinished = queueMicroTask;\n                    // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n                    // wait an extra turn.\n                    if (callbacks && callbacks.length > 0) {\n                        queueMicroTask(function () {\n                            if (callbacks) {\n                                let count = callbacks.length;\n                                for (let i = 0; i < count; ++i) {\n                                    callbacks[i].call(null);\n                                }\n                                callbacks = null;\n                            }\n                        });\n                    }\n                };\n                /**\n                 * Resolves this promise.\n                 *\n                 * @param newState The resolved state for this promise.\n                 * @param {T|any} value The resolved value for this promise.\n                 */\n                const resolve = (newState, value) => {\n                    if (isResolved()) {\n                        return;\n                    }\n                    if (isThenable(value)) {\n                        value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));\n                        isChained = true;\n                    }\n                    else {\n                        settle(newState, value);\n                    }\n                };\n                this.then = (onFulfilled, onRejected) => {\n                    return new Promise((resolve, reject) => {\n                        // whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n                        // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n                        // event loop.\n                        whenFinished(() => {\n                            const callback = this.state === 2 /* Rejected */ ? onRejected : onFulfilled;\n                            if (typeof callback === 'function') {\n                                try {\n                                    resolve(callback(this.resolvedValue));\n                                }\n                                catch (error) {\n                                    reject(error);\n                                }\n                            }\n                            else if (this.state === 2 /* Rejected */) {\n                                reject(this.resolvedValue);\n                            }\n                            else {\n                                resolve(this.resolvedValue);\n                            }\n                        });\n                    });\n                };\n                try {\n                    executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));\n                }\n                catch (error) {\n                    settle(2 /* Rejected */, error);\n                }\n            }\n            static all(iterable) {\n                return new this(function (resolve, reject) {\n                    const values = [];\n                    let complete = 0;\n                    let total = 0;\n                    let populating = true;\n                    function fulfill(index, value) {\n                        values[index] = value;\n                        ++complete;\n                        finish();\n                    }\n                    function finish() {\n                        if (populating || complete < total) {\n                            return;\n                        }\n                        resolve(values);\n                    }\n                    function processItem(index, item) {\n                        ++total;\n                        if (isThenable(item)) {\n                            // If an item Promise rejects, this Promise is immediately rejected with the item\n                            // Promise's rejection error.\n                            item.then(fulfill.bind(null, index), reject);\n                        }\n                        else {\n                            Promise.resolve(item).then(fulfill.bind(null, index));\n                        }\n                    }\n                    let i = 0;\n                    for (const value of iterable) {\n                        processItem(i, value);\n                        i++;\n                    }\n                    populating = false;\n                    finish();\n                });\n            }\n            static race(iterable) {\n                return new this(function (resolve, reject) {\n                    for (const item of iterable) {\n                        if (item instanceof Promise) {\n                            // If a Promise item rejects, this Promise is immediately rejected with the item\n                            // Promise's rejection error.\n                            item.then(resolve, reject);\n                        }\n                        else {\n                            Promise.resolve(item).then(resolve);\n                        }\n                    }\n                });\n            }\n            static reject(reason) {\n                return new this(function (resolve, reject) {\n                    reject(reason);\n                });\n            }\n            static resolve(value) {\n                return new this(function (resolve) {\n                    resolve(value);\n                });\n            }\n            catch(onRejected) {\n                return this.then(undefined, onRejected);\n            }\n        },\n        _a[Symbol.species] = ShimPromise,\n        _a);\n    // this cast is needed in order to omit finally in the class declaration; this was done so the finally code\n    // is not duplicated and always added in the conditional below\n}\nif (!has('es2018-promise-finally')) {\n    global.Promise.prototype.finally = function (onFinally) {\n        return this.then(onFinally && ((value) => Promise.resolve(onFinally()).then(() => value)), onFinally &&\n            ((reason) => Promise.resolve(onFinally()).then(() => {\n                throw reason;\n            })));\n    };\n}\nexport default ShimPromise;","import { create } from '../vdom';\nimport { resize } from './resize';\nconst factory = create({ resize });\nexport function createBreakpointMiddleware(breakpoints = { SM: 0, MD: 576, LG: 768, XL: 960 }) {\n    const defaultBreakpoints = breakpoints;\n    const breakpoint = factory(({ middleware: { resize } }) => {\n        return {\n            get: (key, breakpoints = defaultBreakpoints) => {\n                const contentRect = resize.get(key);\n                if (!contentRect) {\n                    return null;\n                }\n                let currentBreakpoint = null;\n                const keys = Object.keys(breakpoints);\n                for (let i = 0; i < keys.length; i++) {\n                    const breakpoint = breakpoints[keys[i]];\n                    if (contentRect.width >= breakpoint &&\n                        (!currentBreakpoint || breakpoint > currentBreakpoint.size)) {\n                        currentBreakpoint = {\n                            name: keys[i],\n                            size: breakpoint\n                        };\n                    }\n                }\n                if (currentBreakpoint) {\n                    return {\n                        breakpoint: currentBreakpoint.name,\n                        contentRect\n                    };\n                }\n                return null;\n            }\n        };\n    });\n    return breakpoint;\n}\nconst breakpoint = createBreakpointMiddleware();\nexport default breakpoint;\n//# sourceMappingURL=breakpoint.mjs.map","import Map from '../shim/Map';\nimport { Destroyable } from './Destroyable';\n/**\n * Map of computed regular expressions, keyed by string\n */\nconst regexMap = new Map();\n/**\n * Determines if the event type glob has been matched\n *\n * @returns boolean that indicates if the glob is matched\n */\nexport function isGlobMatch(globString, targetString) {\n    if (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {\n        let regex;\n        if (regexMap.has(globString)) {\n            regex = regexMap.get(globString);\n        }\n        else {\n            regex = new RegExp(`^${globString.replace(/\\*/g, '.*')}$`);\n            regexMap.set(globString, regex);\n        }\n        return regex.test(targetString);\n    }\n    else {\n        return globString === targetString;\n    }\n}\n/**\n * Event Class\n */\nexport class Evented extends Destroyable {\n    constructor() {\n        super(...arguments);\n        /**\n         * map of listeners keyed by event type\n         */\n        this.listenersMap = new Map();\n    }\n    emit(event) {\n        this.listenersMap.forEach((methods, type) => {\n            if (isGlobMatch(type, event.type)) {\n                [...methods].forEach((method) => {\n                    method.call(this, event);\n                });\n            }\n        });\n    }\n    on(type, listener) {\n        if (Array.isArray(listener)) {\n            const handles = listener.map((listener) => this._addListener(type, listener));\n            return {\n                destroy() {\n                    handles.forEach((handle) => handle.destroy());\n                }\n            };\n        }\n        return this._addListener(type, listener);\n    }\n    _addListener(type, listener) {\n        const listeners = this.listenersMap.get(type) || [];\n        listeners.push(listener);\n        this.listenersMap.set(type, listeners);\n        return {\n            destroy: () => {\n                const listeners = this.listenersMap.get(type) || [];\n                listeners.splice(listeners.indexOf(listener), 1);\n            }\n        };\n    }\n}\nexport default Evented;\n//# sourceMappingURL=Evented.mjs.map"],"sourceRoot":""}